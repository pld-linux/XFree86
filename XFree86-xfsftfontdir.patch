--- XFree86-3.3.5/xc/programs/mkfontdir/mkfontdir.c.xfsftfontdir	Fri Nov 13 09:17:34 1998
+++ XFree86-3.3.5/xc/programs/mkfontdir/mkfontdir.c	Thu Aug 19 10:01:45 1999
@@ -111,6 +111,7 @@
 #include <X11/X.h>
 #include <X11/Xproto.h>
 #include "fntfilst.h"
+#include "fontenc.h"
 
 #include <errno.h>
 #ifdef X_NOT_STDC_ENV
@@ -122,16 +123,67 @@
 #include <X11/keysymdef.h>
 
 char *progName;
+char *prefix = "";
+Bool relative = FALSE;
+
+/* The possible extensions for encoding files, in decreasing priority */
+#ifdef X_GZIP_FONT_COMPRESSION
+#define NUMENCODINGEXTENSIONS 2
+char *encodingExtensions[]={".gz", ".Z"};
+#else
+#define NUMENCODINGEXTENSIONS 1
+char *encodingExtensions[]={".Z"};
+#endif
+
+typedef struct _nameBucket {
+  struct _nameBucket        *next;
+  char              *name;
+  FontRendererPtr   renderer;
+} NameBucketRec, *NameBucketPtr;
+
+typedef struct _encodingBucket {
+  struct _encodingBucket *next;
+  char *name;
+  char *fileName;
+  int priority;
+} EncodingBucketRec, *EncodingBucketPtr;
+
+#define HASH_SIZE   1024
+/* should be a divisor of HASH_SIZE */
+#define ENCODING_HASH_SIZE 256
+
+
+static Bool WriteFontTable ( char *dirName, FontTablePtr table,
+                             EncodingBucketPtr *encodings, int count);
+static char * NameForAtomOrNone ( Atom a );
+static Bool GetFontName ( char *file_name, char *font_name );
+static char * FontNameExists ( FontTablePtr table, char *font_name );
+int AddEntry ( FontTablePtr table, char *fontName, char *fileName );
+static Bool ProcessFile ( char *dirName, char *fileName, FontTablePtr table );
+static void Estrip ( char *ext, char *name );
+char * MakeName ( char *name );
+int Hash ( char *name );
+Bool LoadEncodings(EncodingBucketPtr *encodings, char *dirName, int priority);
+static Bool LoadDirectory ( char *dirName, FontTablePtr table );
+int LoadScalable ( char *dirName, FontTablePtr table );
+static Bool DoDirectory(char *dirName,
+                        EncodingBucketPtr *encodings, int count);
+int GetDefaultPointSize ( void );
+void RegisterFPEFunctions ( void );
+void ErrorF ( void );
 
 static Bool
-WriteFontTable(dirName, table)
+WriteFontTable(dirName, table, encodings, count)
     char	    *dirName;
     FontTablePtr    table;
+    EncodingBucketPtr *encodings;
+    int count;
 {
     int		    i;
     FILE	    *file;
     char	    full_name[PATH_MAX];
     FontEntryPtr    entry;
+    EncodingBucketPtr encoding;
 
     sprintf (full_name, "%s/%s", dirName, FontDirFile);
 
@@ -155,6 +207,30 @@
 	fprintf (file, "%s %s\n", entry->u.bitmap.fileName, entry->name.name);
     }
     fclose (file);
+
+
+    /* Write out encodings directory */
+
+    sprintf (full_name, "%s/%s", dirName, "encodings.dir");
+    if (unlink(full_name) < 0 && errno != ENOENT)
+    {
+      fprintf(stderr, "%s: warning: cannot unlink %s\n", progName, full_name);
+      return TRUE;              /* non fatal error */
+    }
+    if(!count) return TRUE;
+    file = fopen (full_name, "w");
+    if (!file)
+    {
+      fprintf (stderr, "%s: can't create directory %s\n", progName, full_name);
+      return TRUE;
+    }
+    fprintf(file, "%d\n", count);
+    for(i=0; i<ENCODING_HASH_SIZE; i++)
+      for(encoding=encodings[i]; encoding; encoding=encoding->next)
+        fprintf(file, "%s %s%s\n",
+                encoding->name, prefix, encoding->fileName);
+    fclose(file);
+
     return TRUE;
 }
 
@@ -215,6 +291,7 @@
     return 0;
 }
 
+int
 AddEntry (table, fontName, fileName)
     FontTablePtr    table;
     char	    *fontName, *fileName;
@@ -249,7 +326,7 @@
 
     CopyISOLatin1Lowered (font_name, font_name, strlen(font_name));
 
-    if (existing = FontNameExists (table, font_name))
+    if ((existing = FontNameExists (table, font_name)) != 0)
     {
 	fprintf (stderr, "%s: Duplicate font names %s\n", progName, font_name);
 	fprintf (stderr, "\t%s %s\n", existing, fileName);
@@ -259,6 +336,7 @@
 }
 
 static
+void
 Estrip(ext,name)
     char	*ext;
     char	*name;
@@ -268,16 +346,8 @@
 
 /***====================================================================***/
 
-typedef struct _nameBucket {
-    struct _nameBucket	*next;
-    char		*name;
-    FontRendererPtr	renderer;
-} NameBucketRec, *NameBucketPtr;
-    
 #define New(type,count)	((type *) malloc (count * sizeof (type)))
 
-#define HASH_SIZE   1024
-
 char *
 MakeName(name)
     char	*name;
@@ -297,7 +367,7 @@
     char    c;
 
     i = 0;
-    while (c = *name++)
+    while ((c = *name++) != 0)
 	i = (i << 1) ^ c;
     return i & (HASH_SIZE - 1);
 }
@@ -319,7 +389,6 @@
     int			hash;
     char		*extension;
     NameBucketPtr	*hashTable, bucket, *prev, next;
-    Bool		status;
     
 #ifdef WIN32
     if ((dirh = FindFirstFile("*.*", &file)) == INVALID_HANDLE_VALUE)
@@ -435,8 +504,141 @@
 }
 
 static Bool
-DoDirectory(dirName)
+CompareEncodingFiles(char *name1, char *name2)
+{
+  int len, len1, len2, p1, p2, i;
+  char *extension;
+
+  len1=strlen(name1);
+  len2=strlen(name2);
+  p1=p2=-1;
+
+  for(extension=encodingExtensions[0], i=0;
+      i<NUMENCODINGEXTENSIONS;
+      extension++, i++) {
+    len=strlen(extension);
+    if(p1<0 && len1>=len && !strcmp(name1+len1-len, extension))
+      p1=i;
+    if(p2<0 && len2>=len && !strcmp(name2+len2-len, extension))
+      p2=i;
+  }
+
+  if(p1<0)
+    return FALSE;
+  else if(p2<0)
+    return TRUE;
+  else
+    return(p1<p2);
+}
+
+static Bool
+InsertEncoding(EncodingBucketPtr *encodings,
+               char *name, char *fileName, int priority)
+{
+  int bucket;
+  EncodingBucketPtr encoding;
+
+  bucket=Hash(name)%ENCODING_HASH_SIZE;
+
+  for(encoding=encodings[bucket]; encoding; encoding=encoding->next) {
+    if(!strcmp(name, encoding->name)) {
+      if(encoding->priority<priority)
+        return TRUE;
+      else if(encoding->priority>priority)
+        break;
+      else if(CompareEncodingFiles(fileName, encoding->fileName))
+        break;
+      else
+        return TRUE;
+
+    }
+  }
+
+  if(!encoding) {
+    /* Need to insert new bucket */
+    if((encoding=New(EncodingBucketRec, 1))==NULL)
+      return FALSE;
+    encoding->next=encodings[bucket];
+    encodings[bucket]=encoding;
+  }
+
+  /* Now encoding points to a bucket to fill in */
+  encoding->name=name;
+  encoding->fileName=fileName;
+  encoding->priority=priority;
+  return TRUE;
+}
+
+Bool
+LoadEncodings(EncodingBucketPtr *encodings, char *dirName, int priority)
+{
+  EncodingBucketPtr new;
+  char *filename;
+  char **names;
+  char **name;
+  char fullname[MAXFONTFILENAMELEN];
+  int len;
+#ifdef WIN32
+  HANDLE              dirh;
+  WIN32_FIND_DATA     file;
+#else
+  DIR                 *dirp;
+  struct dirent               *file;
+#endif
+
+  if (strcmp(dirName, ".") == 0) {
+    len=0;
+  } else {
+    len=strlen(dirName);
+    strcpy(fullname, dirName);
+    if(fullname[len-1]!='/')
+      fullname[len++]='/';
+  }
+
+
+#ifdef WIN32
+  if ((dirh = FindFirstFile("*.*", &file)) == INVALID_HANDLE_VALUE)
+    return FALSE;
+#else
+  if ((dirp = opendir (dirName)) == NULL)
+    return FALSE;
+#endif
+#ifdef WIN32
+  do {
+#else
+  while ((file = readdir (dirp)) != NULL) {
+#endif
+    if(len+strlen(FileName(file))>=MAXFONTFILENAMELEN) {
+      fprintf(stderr, "%s: warning: filename `%s/%s' too long, ignored\n",
+              progName, dirName, FileName(file));
+      continue;
+    }
+    strcpy(fullname+len, FileName(file));
+    names=identifyEncodingFile(fullname);
+    if(names) {
+      if((filename=New(char, strlen(fullname)+1))==NULL) {
+        fprintf(stderr, "%s: warning: out of memory.\n", progName);
+        break;
+      }
+      strcpy(filename, fullname);
+      for(name=names; *name; name++)
+        if(!InsertEncoding(encodings, *name, filename, priority))
+          fprintf(stderr, "%s: warning: failed to insert encoding %s\n", *name);
+      /* Only free the spine -- the names themselves may be used */
+      free(names);
+    }
+  }
+#ifdef WIN32
+    while (FindNextFile(dirh, &file));
+#endif
+  return TRUE;
+}
+
+static Bool
+DoDirectory(dirName, encodings, count)
     char	*dirName;
+    EncodingBucketPtr *encodings;
+    int count;
 {
     FontTableRec	table;
     Bool		status;
@@ -455,42 +657,113 @@
     }
     status = TRUE;
     if (table.used >= 0)
-	status = WriteFontTable (dirName, &table);
+	status = WriteFontTable (dirName, &table, encodings, count);
     FontFileFreeTable (&table);
     return status;
 }
 
-GetDefaultPointSize ()
+int
+GetDefaultPointSize (void)
 {
     return 120;
 }
 
-FontResolutionPtr GetClientResolutions ()
+FontResolutionPtr GetClientResolutions (num)
+    int *num;
 {
     return 0;
 }
 
-RegisterFPEFunctions ()
+void
+RegisterFPEFunctions (void)
 {
 }
 
-ErrorF ()
+void
+ErrorF (void)
 {
 }
 
 /***====================================================================***/
 
+int
 main (argc, argv)
     int argc;
     char **argv;
 {
-    int i;
+    int argn, i, count;
+    char *dirname, fulldirname[MAXFONTFILENAMELEN];
+    EncodingBucketPtr *encodings, encoding;
+    char **name;
 
     BitmapRegisterFontFileFunctions ();
     progName = argv[0];
-    if (argc == 1)
+    if((encodings=New(EncodingBucketPtr, ENCODING_HASH_SIZE))==NULL) {
+       fprintf(stderr, "%s: out of memory\n", progName);
+       exit(2);
+    }  
+    for(i=0; i<ENCODING_HASH_SIZE; i++)
+      encodings[i]=NULL;
+
+    for(argn=1; argn<argc; argn++) {
+      if(argv[argn][0]=='\0' || argv[argn][0]!='-')
+        break;
+      if(argv[argn][1]=='-') {
+        argn++;
+        break;
+      } else if(argv[argn][1]=='e') {
+        if(argv[argn][2]=='\0') {
+          argn++;
+        if (argn < argc)
+            dirname=argv[argn];
+        else {
+          fprintf(stderr, "%s: -e requires an argument\n", progName);
+          break;
+        }
+        } else
+          dirname=argv[argn]+2;
+        if(dirname[0]=='/' || relative)
+          LoadEncodings(encodings, dirname, argn);
+        else {
+          if(getcwd(fulldirname, MAXFONTFILENAMELEN)==NULL) {
+            fprintf(stderr, "%s: failed to get cwd\n", progName);
+            break;
+          }
+          i=strlen(fulldirname);
+          if(i+1+strlen(dirname)>=MAXFONTFILENAMELEN-1) {
+          fprintf(stderr, "%s: directory name `%s' too long\n", progName,
+                dirname);
+          break;
+          }
+          fulldirname[i++]='/';
+          strcpy(fulldirname+i, dirname);
+          LoadEncodings(encodings, fulldirname, argn);
+        }
+      } else if(argv[argn][1]=='p') {
+        if(argv[argn][2]=='\0') {
+          argn++;
+          prefix=argv[argn];
+        } else
+          prefix=argv[argn]+2;
+      } else if(argv[argn][1]=='r') {
+        if(argv[argn][2]=='\0')
+          relative=TRUE;
+        else {
+          fprintf(stderr, "%s: unknown option `%s'\n", progName, argv[argn]);
+          continue;
+        }
+      } else
+        fprintf(stderr, "%s: unknown option `%s'\n", progName, argv[argn]);
+    }
+
+    count=0;
+    for(i=0; i<ENCODING_HASH_SIZE; i++)
+      for(encoding=encodings[i]; encoding; encoding=encoding->next)
+        count++;
+
+    if (argc == argc)
     {
-	if (!DoDirectory("."))
+	if (!DoDirectory(".", encodings, count))
 	{
 	    fprintf (stderr, "%s: failed to create directory in %s\n",
 		     progName, ".");
@@ -498,11 +771,11 @@
 	}
     }
     else
-	for (i = 1; i < argc; i++) {
-	    if (!DoDirectory(argv[i]))
+	for (; argn < argc; argn++) {
+	    if (!DoDirectory(argv[argn], encodings, count))
 	    {
 		fprintf (stderr, "%s: failed to create directory in %s\n",
-			 progName, argv[i]);
+			 progName, argv[argn]);
 		exit (1);
 	    }
  	}
--- XFree86-3.3.5/xc/programs/mkfontdir/mkfontdir.man.xfsftfontdir	Sat Dec 21 23:11:23 1996
+++ XFree86-3.3.5/xc/programs/mkfontdir/mkfontdir.man	Wed Aug 18 17:23:04 1999
@@ -26,12 +26,22 @@
 .\" from the X Consortium.
 .TH MKFONTDIR 1 "Release 6.3" "X Version 11"
 .SH NAME
-mkfontdir, fonts.dir, fonts.scale, fonts.alias \- create an index of X font files in a directory
+mkfontdir, fonts.dir, fonts.scale, fonts.alias, encodings.dir \- create an index of X font files in a directory
 .SH SYNOPSIS
 .B "mkfontdir"
-[\fIdirectory-name\fP .\|.\|. ]
+.RB [ \-r ]
+.RB [ \-p
+.IR prefix ]
+.RB [ \-e
+.IR encoding-directory-name ]
+\|.\|.\|.
+.RB [ \-\- ]
+.RI [ directory-name
+\|.\|.\|. ]
 .SH DESCRIPTION
-For each directory argument, \fImkfontdir\fP reads all of the font files in the
+For each directory argument,
+.Imkfontdir
+reads all of the font files in the
 directory searching for properties named "FONT", or (failing that) the name
 of the file stripped of its suffix.  These are converted to lower case and
 used as font names, and,
@@ -39,7 +49,9 @@
 written out to the file "fonts.dir" in the directory.
 The X server and font server use "fonts.dir" to find font files.
 .PP
-The kinds of font files read by \fImkfontdir\fP depend on configuration
+The kinds of font files read by 
+.Imkfontdir
+depend on configuration
 parameters, but typically include PCF (suffix ".pcf"), SNF (suffix ".snf")
 and BDF (suffix ".bdf").  If a font exists in multiple formats,
 .I mkfontdir
@@ -53,7 +65,8 @@
 Because scalable font files do not usually include the X font name, the
 file "fonts.scale" can be used to name the scalable fonts in the
 directory.
-The fonts listed in it are copied to fonts.dir by \fImkfontdir\fP.
+The fonts listed in it are copied to fonts.dir by 
+.Imkfontdir .
 "fonts.scale" has the same format as the "fonts.dir" file.
 .SH "FONT NAME ALIASES"
 The file "fonts.alias", which can be put in any directory of the font-path, is
@@ -83,6 +96,48 @@
 If the string "FILE_NAMES_ALIASES" stands alone on a line, each file-name
 in the directory (stripped of its suffix) will be used as an alias for
 that font.
+.SH ENCODING FILES
+The option
+.B -e
+can be used to specify a directory with encoding files.  Every such
+directory is scanned for encoding files, the list of which is then
+written to an "encodings.dir" file in every font directory.  The
+"encodings.dir" file is used by the server to find encoding
+information.
+.PP
+The "encodings.dir" file has the same format as "fonts.dir".
+It maps encoding names (strings of the form
+.BI CHARSET_REGISTRY \- CHARSET_ENCODING
+) to encoding file names.
+.SH OPTIONS
+The following options are supported:
+.TP
+.B \-e
+Specify a directory containing encoding files.  The
+.B \-e
+option may be specified multiple times, and all the specified
+directories will be read.  The order of the entries is significant, as
+encodings found in earlier directories override those in later ones;
+encoding files in the same directory are discriminated by preferring
+compressed versions.
+.TP
+.B \-p
+Specify a prefix that is prepended to the encoding file path names
+when the are written to the "encodings.dir" file.  The prefix is
+prepended as-is.  If a `/' is required between the prefix and the path
+names, it must be supplied explicitly as part of the prefix.
+.TP
+.B \-r
+Keep non-absolute encoding directories in their relative form when
+writing the "encodings.dir" file.  The default is to convert relative
+encoding directories to absolute directories by prepending the current
+directory.  The positioning of this options is significant, as this
+option only applies to subsequent
+.B \-e
+options.
+.TP
+.B \-\-
+End options.
 .SH FILES
 .TP 15
 .B fonts.dir
@@ -98,5 +153,10 @@
 List of font name aliases.
 Read by the X server and font server each
 time the font path is set (see xset(1)).
+.TP 15
+.B encodings.dir
+List of known encodings and the files they are stored in.
+Created by \fImkfontdir\fP.  Read by the X server and font server each
+time a font with an unknown charset is opened.
 .SH "SEE ALSO"
 X(1), Xserver(1), xfs(1), xset(1)
