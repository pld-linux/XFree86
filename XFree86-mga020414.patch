--- XFree86-4.2.0/xc/programs/Xserver/hw/xfree86/drivers/mga.orig/mga.h	Sat Jan 12 00:42:57 2002
+++ XFree86-4.2.0/xc/programs/Xserver/hw/xfree86/drivers/mga/mga.h	Sun Apr 14 15:07:08 2002
@@ -120,6 +120,7 @@
     CARD32		Option;
     CARD32		Option2;
     CARD32		Option3;
+    long		Clock;
 } MGARegRec, *MGARegPtr;
 
 /* For programming the second CRTC */
@@ -350,9 +351,11 @@
     void		(*GetQuiescence)(ScrnInfoPtr pScrn);
 
     int 		agpMode;
+    int		agpSize;
 
 #endif
     XF86VideoAdaptorPtr adaptor;
+    Bool		DualHeadEnabled;
     Bool		SecondCrtc;
     Bool                SecondOutput;
     GDevPtr		device;
@@ -495,6 +498,9 @@
 void MGACRTC2GetDisplayStart(ScrnInfoPtr pScrn, xMODEINFO *pModeInfo, CARD32 base, CARD32 ulX, CARD32 ulY);
  
 double MGAG450SetPLLFreq(ScrnInfoPtr pScrn, long f_out);
+
+double MGAG450SetPLLFreq(ScrnInfoPtr pScrn, long f_out);
+long MGAG450SavePLLFreq(ScrnInfoPtr pScrn);
 void MGAprintDac(ScrnInfoPtr pScrn);
 
 #ifdef USEMGAHAL
--- XFree86-4.2.0/xc/programs/Xserver/hw/xfree86/drivers/mga.orig/mga.man	Tue Dec 18 05:52:32 2001
+++ XFree86-4.2.0/xc/programs/Xserver/hw/xfree86/drivers/mga/mga.man	Sun Apr 14 15:07:08 2002
@@ -19,11 +19,14 @@
 8, 15, 16, 24, and an 8+24 overlay mode.  All
 visual types are supported for depth 8, and both TrueColor and DirectColor
 visuals are supported for the other depths except 8+24 mode which supports
-PseudoColor, GrayScale and TrueColor.  Multi-head configurations
+PseudoColor, GrayScale and TrueColor.  Multi-card configurations
 are supported.  XVideo is supported on G200 and newer systems, with
 either
 .B TexturedVideo
-or video overlay.
+or video overlay.  The second head of dual-head cards is supported for
+the G450 and G550.  Support for the second head on G400 cards requires
+a binary-only "mga_hal" module that is available from Matrox
+<http://www.matrox.com>.  That module also provides various other enhancements.
 .SH SUPPORTED HARDWARE
 The
 .B mga
@@ -44,6 +47,10 @@
 Millennium G200 and Mystique G200
 .TP 12
 .B G400
+.TP 12
+.B G450
+.TP 12
+.B G550
 .SH CONFIGURATION DETAILS
 Please refer to XF86Config(__filemansuffix__) for general configuration
 details.  This section only covers configuration details specific to this
@@ -57,9 +64,11 @@
 .PP
 .RS 4
 "mga2064w", "mga1064sg", "mga2164w", "mga2164w agp", "mgag100", "mgag200",
-"mgag200 pci" "mgag400".
+"mgag200 pci", "mgag400", "mgag550".
 .RE
 .PP
+The G450 is Chipset "mgag400" with ChipRev 0x80.
+.PP
 The driver will auto-detect the amount of video memory present for all
 chips except the Millennium II.  In the Millennium II case it defaults
 to 4096\ kBytes.  When using a Millennium II, the actual amount of video
@@ -91,6 +100,10 @@
 .TP
 .BI "Option \*qNoAccel\*q \*q" boolean \*q
 Disable or enable acceleration.  Default: acceleration is enabled.
+.TP
+.BI "Option \*qNoHal\*q \*q" boolean \*q
+Disable or enable loading the "mga_hal" module.  Default: the module is
+loaded when available and when using hardware that it supports.
 .TP
 .BI "Option \*qOverclockMem\*q"
 Set clocks to values used by some commercial X-Servers (G100, G200 and G400
--- XFree86-4.2.0/xc/programs/Xserver/hw/xfree86/drivers/mga.orig/mga_dacG.c	Sat Jan 12 00:42:57 2002
+++ XFree86-4.2.0/xc/programs/Xserver/hw/xfree86/drivers/mga/mga_dacG.c	Sun Apr 14 15:07:08 2002
@@ -212,8 +212,8 @@
 	double f_pll;
 
 	if(MGAISGx50(pMga)) {
-		MGAG450SetPLLFreq(pScrn, f_out);
-		return;
+	    pReg->Clock = f_out;
+	    return;
 	}
 
 	/* Do the calculations for m, n, p and s */
@@ -285,7 +285,7 @@
 	    pReg->DacRegs[i] = initDAC[i]; 
 	}
 	);	/* MGA_NOT_HAL */
-
+	    
 	switch(pMga->Chipset)
 	{
 	case PCI_CHIP_MGA1064:
@@ -529,7 +529,7 @@
 		OUTREG(MGAREG_ZORG, 0);
 	}
 
-	MGAGSetPCLK(pScrn, mode->Clock);
+  	MGAGSetPCLK(pScrn, mode->Clock);
 	);	/* MGA_NOT_HAL */
 
 	/* This disables the VGA memory aperture */
@@ -616,6 +616,7 @@
 /*
  * MGAGRestorePalette
  */
+
 static void
 MGAGRestorePalette(ScrnInfoPtr pScrn, unsigned char* pntr)
 {
@@ -623,8 +624,8 @@
     int i = 768;
 
     outMGAdreg(MGA1064_WADR_PAL, 0x00);
-    while(i--) 
-        outMGAdreg(MGA1064_COL_PAL, *(pntr++));
+    while(i--)
+	outMGAdreg(MGA1064_COL_PAL, *(pntr++));
 }
 
 /*
@@ -637,8 +638,8 @@
     int i = 768;
 
     outMGAdreg(MGA1064_RADR_PAL, 0x00);
-    while(i--)
-        *(pntr++) = inMGAdreg(MGA1064_COL_PAL);
+    while(i--) 
+	*(pntr++) = inMGAdreg(MGA1064_COL_PAL);
 }
 
 /*
@@ -655,7 +656,21 @@
 	MGAPtr pMga = MGAPTR(pScrn);
 	CARD32 optionMask;
 
+	/*
+	 * Pixel Clock needs to be restored regardless if we use
+	 * HALLib or not. HALlib doesn't do a good job restoring
+	 * VESA modes. MATROX: hint, hint.
+	 */
+	if (MGAISGx50(pMga) && mgaReg->Clock) {
+	    /* 
+	     * With HALlib program only when restoring to console!
+	     * To test this we check for Clock == 0.
+	     */
+	    MGAG450SetPLLFreq(pScrn, mgaReg->Clock);
+	}
+
         if(!pMga->SecondCrtc) {
+
 MGA_NOT_HAL(
 	   /*
 	    * Code is needed to get things back to bank zero.
@@ -696,7 +711,21 @@
 				mgaReg->Option3);
 	   }
 );	/* MGA_NOT_HAL */
-	
+#ifdef USEMGAHAL
+          /* 
+	   * Work around another bug in HALlib: it doesn't restore the
+	   * DAC width register correctly. MATROX: hint, hint.
+	   */
+           MGA_HAL(	 
+    	       outMGAdac(MGA1064_MUL_CTL,mgaReg->DacRegs[0]);
+  	       outMGAdac(MGA1064_MISC_CTL,mgaReg->DacRegs[1]); 
+	       if (!MGAISGx50(pMga)) {
+		   outMGAdac(MGA1064_PIX_PLLC_M,mgaReg->DacRegs[2]);
+		   outMGAdac(MGA1064_PIX_PLLC_N,mgaReg->DacRegs[3]);
+		   outMGAdac(MGA1064_PIX_PLLC_P,mgaReg->DacRegs[4]);
+	       } 
+	       ); 
+#endif
 	   /* restore CRTCEXT regs */
            for (i = 0; i < 6; i++)
 	      OUTREG16(0x1FDE, (mgaReg->ExtVga[i] << 8) | i);
@@ -706,7 +735,7 @@
 	    */
 	   vgaHWRestore(pScrn, vgaReg,
 			VGA_SR_MODE | (restoreFonts ? VGA_SR_FONTS : 0));
-	   MGAGRestorePalette(pScrn, vgaReg->DAC);
+  	   MGAGRestorePalette(pScrn, vgaReg->DAC); 
 	   
 	   /*
 	    * this is needed to properly restore start address
@@ -751,6 +780,7 @@
 	for (i=0; i<6; i++) ErrorF(" %02X", mgaReg->ExtVga[i]);
 	ErrorF("\n");
 #endif
+	
 }
 
 /*
@@ -765,6 +795,15 @@
 	int i;
 	MGAPtr pMga = MGAPTR(pScrn);
 
+	/*
+	 * Pixel Clock needs to be restored regardless if we use
+	 * HALLib or not. HALlib doesn't do a good job restoring
+	 * VESA modes (s.o.). MATROX: hint, hint.
+	 */
+	if (MGAISGx50(pMga)) {
+	    mgaReg->Clock = MGAG450SavePLLFreq(pScrn);
+	}
+
 	if(pMga->SecondCrtc == TRUE) {
 	   for(i = 0x80; i < 0xa0; i++)
 	      mgaReg->dac2[i-0x80] = inMGAdac(i);
@@ -790,7 +829,29 @@
 	 */
 	vgaHWSave(pScrn, vgaReg, VGA_SR_MODE | (saveFonts ? VGA_SR_FONTS : 0));
 	MGAGSavePalette(pScrn, vgaReg->DAC);
+	/* 
+	 * Work around another bug in HALlib: it doesn't restore the
+	 * DAC width register correctly.
+	 */
 
+#ifdef USEMGAHAL
+	/* 
+	 * Work around another bug in HALlib: it doesn't restore the
+	 * DAC width register correctly (s.o.). MATROX: hint, hint.
+	 */
+  	MGA_HAL(
+  	    if (mgaReg->DacRegs == NULL) {
+  		mgaReg->DacRegs = xnfcalloc(MGAISGx50(pMga) ? 2 : 5, 1);
+  	    }
+    	    mgaReg->DacRegs[0] = inMGAdac(MGA1064_MUL_CTL);
+  	    mgaReg->DacRegs[1] = inMGAdac(MGA1064_MISC_CTL);
+	    if (!MGAISGx50(pMga)) {
+		mgaReg->DacRegs[2] = inMGAdac(MGA1064_PIX_PLLC_M);
+		mgaReg->DacRegs[3] = inMGAdac(MGA1064_PIX_PLLC_N);
+		mgaReg->DacRegs[4] = inMGAdac(MGA1064_PIX_PLLC_P);
+	    } 
+  	);
+#endif
 	MGA_NOT_HAL(
 	/*
 	 * The port I/O code necessary to read in the extended registers.
--- XFree86-4.2.0/xc/programs/Xserver/hw/xfree86/drivers/mga.orig/mga_dri.c	Wed Sep 26 21:59:17 2001
+++ XFree86-4.2.0/xc/programs/Xserver/hw/xfree86/drivers/mga/mga_dri.c	Sun Apr 14 15:07:08 2002
@@ -571,11 +571,14 @@
    MGADRIServerPrivatePtr pMGADRIServer = pMga->DRIServerInfo;
    unsigned long mode;
    unsigned int vendor, device;
-   int ret, count;
+   int ret, count, i;
+
+   if(pMga->agpSize < 12)pMga->agpSize = 12;
+   if(pMga->agpSize > 64)pMga->agpSize = 64; /* cap */
 
    /* FIXME: Make these configurable...
     */
-   pMGADRIServer->agp.size = 12 * 1024 * 1024;
+   pMGADRIServer->agp.size = pMga->agpSize * 1024 * 1024;
 
    pMGADRIServer->warp.offset = 0;
    pMGADRIServer->warp.size = MGA_WARP_UCODE_SIZE;
@@ -588,6 +591,13 @@
 				    pMGADRIServer->primary.size);
    pMGADRIServer->buffers.size = MGA_NUM_BUFFERS * MGA_BUFFER_SIZE;
 
+
+   pMGADRIServer->agpTextures.offset = (pMGADRIServer->buffers.offset +
+                                    pMGADRIServer->buffers.size);
+
+   pMGADRIServer->agpTextures.size = pMGADRIServer->agp.size -
+                                     pMGADRIServer->agpTextures.offset;
+
    if ( drmAgpAcquire( pMga->drmFD ) < 0 ) {
       xf86DrvMsg( pScreen->myNum, X_ERROR, "[agp] AGP not available\n" );
       return FALSE;
@@ -750,6 +760,28 @@
 	       "[drm] Added %d %d byte DMA buffers\n",
 	       count, MGA_BUFFER_SIZE );
 
+   i = mylog2(pMGADRIServer->agpTextures.size / MGA_NR_TEX_REGIONS);
+   if(i < MGA_LOG_MIN_TEX_REGION_SIZE)
+      i = MGA_LOG_MIN_TEX_REGION_SIZE;
+   pMGADRIServer->agpTextures.size = (pMGADRIServer->agpTextures.size >> i) << i;
+
+   if ( drmAddMap( pMga->drmFD,
+                   pMGADRIServer->agpTextures.offset,
+                   pMGADRIServer->agpTextures.size,
+                   DRM_AGP, 0,
+                   &pMGADRIServer->agpTextures.handle ) < 0 ) {
+      xf86DrvMsg( pScreen->myNum, X_ERROR,
+                  "[agp] Could not add agpTexture mapping\n" );
+      return FALSE;
+   }
+/* should i map it ? */
+   xf86DrvMsg( pScreen->myNum, X_INFO,
+               "[agp] agpTexture handle = 0x%08lx\n",
+               pMGADRIServer->agpTextures.handle );
+   xf86DrvMsg( pScreen->myNum, X_INFO,
+               "[agp] agpTexture size: %d kb\n", pMGADRIServer->agpTextures.size/1024 );
+
+
    xf86EnablePciBusMaster( pMga->PciInfo, TRUE );
 
    return TRUE;
@@ -853,6 +885,9 @@
    init.primary_offset = pMGADRIServer->primary.handle;
    init.buffers_offset = pMGADRIServer->buffers.handle;
 
+   init.texture_offset[1] = pMGADRIServer->agpTextures.handle;
+   init.texture_size[1] = pMGADRIServer->agpTextures.size;
+
    ret = drmMGAInitDMA( pMga->drmFD, &init );
    if ( ret < 0 ) {
       xf86DrvMsg( pScrn->scrnIndex, X_ERROR,
@@ -1192,6 +1227,14 @@
    pMGADRI->logTextureGranularity = i;
    pMGADRI->textureSize = (pMGADRI->textureSize >> i) << i; /* truncate */
 
+   i = mylog2( pMGADRIServer->agpTextures.size / MGA_NR_TEX_REGIONS );
+   if ( i < MGA_LOG_MIN_TEX_REGION_SIZE )
+      i = MGA_LOG_MIN_TEX_REGION_SIZE;
+
+   pMGADRI->logAgpTextureGranularity = i;
+   pMGADRI->agpTextureOffset = (unsigned int)pMGADRIServer->agpTextures.handle;
+   pMGADRI->agpTextureSize = (unsigned int)pMGADRIServer->agpTextures.size;
+
    pMGADRI->registers.handle	= pMGADRIServer->registers.handle;
    pMGADRI->registers.size	= pMGADRIServer->registers.size;
    pMGADRI->status.handle	= pMGADRIServer->status.handle;
@@ -1233,6 +1276,11 @@
    if ( pMGADRIServer->warp.map ) {
       drmUnmap( pMGADRIServer->warp.map, pMGADRIServer->warp.size );
       pMGADRIServer->warp.map = NULL;
+   }
+
+   if ( pMGADRIServer->agpTextures.map ) {
+      drmUnmap( pMGADRIServer->agpTextures.map, pMGADRIServer->agpTextures.size );
+      pMGADRIServer->agpTextures.map = NULL;
    }
 
    if ( pMGADRIServer->agp.handle ) {
--- XFree86-4.2.0/xc/programs/Xserver/hw/xfree86/drivers/mga.orig/mga_driver.c	Tue Jan  8 06:50:11 2002
+++ XFree86-4.2.0/xc/programs/Xserver/hw/xfree86/drivers/mga/mga_driver.c	Sun Apr 14 15:36:52 2002
@@ -213,6 +213,7 @@
     OPTION_CRTC2RAM,
     OPTION_INT10,
     OPTION_AGP_MODE,
+    OPTION_AGP_SIZE,
     OPTION_DIGITAL,
     OPTION_TV,
     OPTION_TVSTANDARD,
@@ -244,6 +245,7 @@
     { OPTION_CRTC2RAM,		"Crtc2Ram",	OPTV_INTEGER,	{0}, FALSE },
     { OPTION_INT10,		"Int10",	OPTV_BOOLEAN,	{0}, FALSE },
     { OPTION_AGP_MODE,		"AGPMode",	OPTV_INTEGER,	{0}, FALSE },
+    { OPTION_AGP_SIZE,		"AGPSize",      OPTV_INTEGER,   {0}, FALSE },
     { OPTION_DIGITAL,		"DigitalScreen",OPTV_BOOLEAN,	{0}, FALSE },
     { OPTION_TV,		"TV",		OPTV_BOOLEAN,	{0}, FALSE },
     { OPTION_TVSTANDARD,	"TVStandard",	OPTV_ANYSTR,	{0}, FALSE },
@@ -1299,28 +1301,122 @@
     pScrn->monitor = pScrn->confScreen->monitor;
 
     /*
-     * In case of DualHead, we need to determine if we are the 'master' head or the 'slave'
-     * head. In order to do that, at the end of the first initialisation, PrimInit is set as
-     * DONE to the shared entity. So that the second initialisation knows that something has
-     * been done before it. This always assume that the first device initialised is the master
+     * Set the Chipset and ChipRev, allowing config file entries to
+     * override.
+     */
+    if (pMga->device->chipset && *pMga->device->chipset) {
+	pScrn->chipset = pMga->device->chipset;
+        pMga->Chipset = xf86StringToToken(MGAChipsets, pScrn->chipset);
+        from = X_CONFIG;
+    } else if (pMga->device->chipID >= 0) {
+	pMga->Chipset = pMga->device->chipID;
+	pScrn->chipset = (char *)xf86TokenToString(MGAChipsets, pMga->Chipset);
+	from = X_CONFIG;
+	xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "ChipID override: 0x%04X\n",
+		   pMga->Chipset);
+    } else {
+	from = X_PROBED;
+	pMga->Chipset = pMga->PciInfo->chipType;
+	pScrn->chipset = (char *)xf86TokenToString(MGAChipsets, pMga->Chipset);
+    }
+    if (pMga->device->chipRev >= 0) {
+	pMga->ChipRev = pMga->device->chipRev;
+	xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "ChipRev override: %d\n",
+		   pMga->ChipRev);
+    } else {
+	pMga->ChipRev = pMga->PciInfo->chipRev;
+    }
+
+    /*
+     * This shouldn't happen because such problems should be caught in
+     * MGAProbe(), but check it just in case.
+     */
+    if (pScrn->chipset == NULL) {
+	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+		   "ChipID 0x%04X is not recognised\n", pMga->Chipset);
+	return FALSE;
+    }
+    if (pMga->Chipset < 0) {
+	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+		   "Chipset \"%s\" is not recognised\n", pScrn->chipset);
+	return FALSE;
+    }
+
+    xf86DrvMsg(pScrn->scrnIndex, from, "Chipset: \"%s\"", pScrn->chipset);
+    if ((pMga->Chipset == PCI_CHIP_MGAG400) &&
+	(pMga->ChipRev >= 0x80))
+	xf86ErrorF(" (G450)\n");
+    else
+	xf86ErrorF(" (G400)\n");
+
+#ifdef USEMGAHAL
+    if (HAL_CHIPSETS) {
+	Bool loadHal = TRUE;
+	
+	from = X_DEFAULT;
+	if (xf86FindOption(pMga->device->options, "NoHal")) {
+	    loadHal = !xf86SetBoolOption(pMga->device->options,
+					 "NoHal", !loadHal);
+	    from = X_CONFIG;
+	} else if (xf86FindOption(pMga->device->options, "Hal")) {
+	    loadHal = xf86SetBoolOption(pMga->device->options,
+					"Hal", loadHal);
+	    from = X_CONFIG;
+	}
+        if (loadHal && xf86LoadSubModule(pScrn, "mga_hal")) {
+	  xf86LoaderReqSymLists(halSymbols, NULL);
+	  xf86DrvMsg(pScrn->scrnIndex, from,"Matrox HAL module used\n");
+	  pMga->HALLoaded = TRUE;
+	} else {
+	  xf86DrvMsg(pScrn->scrnIndex, from, "Matrox HAL module not loaded "
+		     "- using builtin mode setup instead\n");
+	  pMga->HALLoaded = FALSE;
+	}
+    }
+#endif
+
+    pMga->DualHeadEnabled = FALSE;
+    if (xf86IsEntityShared(pScrn->entityList[0])) {/* dual-head mode requested*/
+#ifdef USEMGAHAL
+	if (pMga->HALLoaded || !MGA_DH_NEEDS_HAL(pMga)) {
+#else
+	if (!MGA_DH_NEEDS_HAL(pMga)) {
+#endif
+	    pMga->DualHeadEnabled = TRUE;
+	} else if (xf86IsPrimInitDone(pScrn->entityList[0])) {
+	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+	 "This card requires the \"mga_hal\" module for dual-head operation\n"
+	 "\tIt can be found at the Matrox web site <http://www.matrox.com>\n");
+	}
+    }
+
+    /*
+     * In case of DualHead, we need to determine if we are the 'master' head
+     * or the 'slave' head. In order to do that, at the end of the first
+     * initialisation, PrimInit is set as DONE to the shared entity. So that
+     * the second initialisation knows that something has been done before it.
+     * This always assume that the first device initialised is the master
      * head, and the second the slave.
      * 
      */
     if (xf86IsEntityShared(pScrn->entityList[0])) {      /* dual-head mode */
-        
         if (!xf86IsPrimInitDone(pScrn->entityList[0])) { /* Is it the first initialisation? */
             /* First CRTC  */
             pMga->SecondCrtc = FALSE;
             pMga->HWCursor = TRUE;
             pMgaEnt->pScrn_1 = pScrn;
-        }
-        else {
+        } else if (pMga->DualHeadEnabled) {
             /* Second CRTC */
             pMga->SecondCrtc = TRUE;
             pMga->HWCursor = FALSE;
             pMgaEnt->pScrn_2 = pScrn;
             pScrn->AdjustFrame = MGAAdjustFrameCrtc2;
-        }
+        } else {
+	    return FALSE;
+	}
+    }
+
+    if (pMga->DualHeadEnabled) {
 #ifdef XF86DRI
         pMga->GetQuiescence = MGAGetQuiescenceShared;
 #endif
@@ -1421,65 +1517,6 @@
     if (pScrn->depth == 8)
 	pScrn->rgbBits = 8;
 
-    /*
-     * Set the Chipset and ChipRev, allowing config file entries to
-     * override.
-     */
-    if (pMga->device->chipset && *pMga->device->chipset) {
-	pScrn->chipset = pMga->device->chipset;
-        pMga->Chipset = xf86StringToToken(MGAChipsets, pScrn->chipset);
-        from = X_CONFIG;
-    } else if (pMga->device->chipID >= 0) {
-	pMga->Chipset = pMga->device->chipID;
-	pScrn->chipset = (char *)xf86TokenToString(MGAChipsets, pMga->Chipset);
-	from = X_CONFIG;
-	xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "ChipID override: 0x%04X\n",
-		   pMga->Chipset);
-    } else {
-	from = X_PROBED;
-	pMga->Chipset = pMga->PciInfo->chipType;
-	pScrn->chipset = (char *)xf86TokenToString(MGAChipsets, pMga->Chipset);
-    }
-    if (pMga->device->chipRev >= 0) {
-	pMga->ChipRev = pMga->device->chipRev;
-	xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "ChipRev override: %d\n",
-		   pMga->ChipRev);
-    } else {
-	pMga->ChipRev = pMga->PciInfo->chipRev;
-    }
-
-#ifdef USEMGAHAL
-    if (HAL_CHIPSETS) {
-        if (!xf86ReturnOptValBool(pMga->Options, OPTION_NOHAL, FALSE)
-	    && xf86LoadSubModule(pScrn, "mga_hal")) {
-	  xf86LoaderReqSymLists(halSymbols, NULL);
-	  xf86DrvMsg(pScrn->scrnIndex, X_INFO,"Matrox HAL module used\n");
-	  pMga->HALLoaded = TRUE;
-	} else {
-	  xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Matrox HAL module not loaded "
-		     "- using builtin mode setup instead\n");
-	  pMga->HALLoaded = FALSE;
-	}
-    }
-#endif
-
-    /*
-     * This shouldn't happen because such problems should be caught in
-     * MGAProbe(), but check it just in case.
-     */
-    if (pScrn->chipset == NULL) {
-	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
-		   "ChipID 0x%04X is not recognised\n", pMga->Chipset);
-	return FALSE;
-    }
-    if (pMga->Chipset < 0) {
-	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
-		   "Chipset \"%s\" is not recognised\n", pScrn->chipset);
-	return FALSE;
-    }
-
-    xf86DrvMsg(pScrn->scrnIndex, from, "Chipset: \"%s\"\n", pScrn->chipset);
-
 #ifdef XF86DRI
     from = X_DEFAULT;
     pMga->agpMode = MGA_DEFAULT_AGP_MODE;
@@ -1494,6 +1531,12 @@
        }
        from = X_CONFIG;
     }
+    if (xf86GetOptValInteger(pMga->Options,
+                             OPTION_AGP_SIZE, &(pMga->agpSize))) {
+                             /* check later */
+       xf86DrvMsg(pScrn->scrnIndex, from, "Using %d MB of AGP memory\n",
+	          pMga->agpSize);
+    }
 
     xf86DrvMsg(pScrn->scrnIndex, from, "Using AGP %dx mode\n",
 	       pMga->agpMode);
@@ -1812,7 +1855,7 @@
 	pScrn->videoRam = MGACountRam(pScrn);
     }
 
-    if(xf86IsEntityShared(pScrn->entityList[0])) {
+    if (pMga->DualHeadEnabled) {
        /* This takes gives either half or 8 meg to the second head
 	* whichever is less. */
         if(pMga->SecondCrtc == FALSE) {
@@ -2073,6 +2116,17 @@
         pMga->pClientStruct->pMga = (MGAPtr) pMga;
 
         MGAMapMem(pScrn);
+	/* 
+	 * For some reason the MGAOPM_DMA_BLIT bit needs to be set
+	 * on G200 before opening the HALlib. I don't know why.
+	 * MATROX: hint, hint.
+	 */
+	/*if (pMga->Chipset == PCI_CHIP_MGAG200 ||
+	  pMga->Chipset == PCI_CHIP_MGAG200_PCI) */{
+	    CARD32 opmode;
+	    opmode = INREG(MGAREG_OPMODE);
+	    OUTREG(MGAREG_OPMODE,  MGAOPM_DMA_BLIT | opmode);
+	}
         MGAOpenLibrary(pMga->pBoard,pMga->pClientStruct,sizeof(CLIENTDATA));
         MGAUnmapMem(pScrn);
         pMga->pMgaHwInfo = xalloc(sizeof(MGAHWINFO));
@@ -2101,7 +2155,7 @@
         }
 
         /* copy the board handles */
-        if (xf86IsEntityShared(pScrn->entityList[0])) {
+        if (pMga->DualHeadEnabled) {
             pMgaEnt->pClientStruct = pMga->pClientStruct;
             pMgaEnt->pBoard = pMga->pBoard;
             pMgaEnt->pMgaHwInfo = pMga->pMgaHwInfo;
@@ -2182,7 +2236,11 @@
      * Can we trust HALlib to set the memory configuration
      * registers correctly?
      */
+#ifdef USEMGAHAL
     else if ((pMga->softbooted || pMga->Primary /*|| pMga->HALLoaded*/ ) &&
+#else
+    else if ((pMga->softbooted || pMga->Primary) &&
+#endif
 	     (pMga->Chipset != PCI_CHIP_MGA2064) &&
 	     (pMga->Chipset != PCI_CHIP_MGA2164) &&
 	     (pMga->Chipset != PCI_CHIP_MGA2164_AGP)) {
@@ -2264,7 +2322,7 @@
 
     xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 2, "YDstOrg is set to %d\n",
 		   pMga->YDstOrg);
-    if(xf86IsEntityShared(pScrn->entityList[0])) {
+    if(pMga->DualHeadEnabled) {
         if(pMga->SecondCrtc == FALSE) {
 	    pMga->FbUsableSize = pMgaEnt->masterFbMapSize;
             /* Allocate HW cursor buffer at the end of video ram */
@@ -2368,7 +2426,7 @@
     /* This needs to only happen after this board has completed preinit
      * both times
      */
-      if(xf86IsEntityShared(pScrn->entityList[0])) {
+      if(pMga->DualHeadEnabled) {
 	  /* Entity is shared make sure refcount == 2 */
 	  /* If ref count is 2 then reset it to 0 */
 	  if(pMgaEnt->refCount == 2) {
@@ -2630,6 +2688,7 @@
     vgaRegPtr vgaReg;
     MGAPtr pMga = MGAPTR(pScrn);
     MGARegPtr mgaReg;
+
 #ifdef USEMGAHAL
     Bool digital1 = FALSE;
     Bool digital2 = FALSE;
@@ -2736,7 +2795,7 @@
     
     );	/* MGA_HAL */
 
-    /* getting around bugs in the HAL lib. MATROX: hint, hint */
+    /* getting around bugs in the HAL lib. MATROX: hint, hint. */
     MGA_HAL(
 	    switch (pMga->Chipset) {
 	    case PCI_CHIP_MGA1064:
@@ -2745,7 +2804,8 @@
 	    case PCI_CHIP_MGAG200:
 	    case PCI_CHIP_MGAG200_PCI:
 	    case PCI_CHIP_MGAG400:	      
-	      if(pMga->SecondCrtc == FALSE && pMga->HWCursor == TRUE) {
+	    case PCI_CHIP_MGAG550:
+		if(pMga->SecondCrtc == FALSE && pMga->HWCursor == TRUE) {
 		outMGAdac(MGA1064_CURSOR_BASE_ADR_LOW, 
 			  pMga->FbCursorOffset >> 10);
 		outMGAdac(MGA1064_CURSOR_BASE_ADR_HI, 
@@ -2769,6 +2829,7 @@
 
     MGAStormSync(pScrn);
     MGAStormEngineInit(pScrn);
+
     vgaHWProtect(pScrn, FALSE);
 
     if (xf86IsPc98()) {
@@ -2840,7 +2901,6 @@
 
     if (pScrn->pScreen != NULL)
 	MGAStormSync(pScrn);
-
     if(pMga->SecondCrtc) {
         MGARestoreSecondCrtc(pScrn);
         return;
@@ -2930,7 +2990,7 @@
 	|| (pMga->Chipset == PCI_CHIP_MGAG100_PCI))
         MGAG100BlackMagic(pMga);
 
-    if (xf86IsEntityShared(pScrn->entityList[0])) {
+    if (pMga->DualHeadEnabled) {
        DevUnion *pPriv;
        pPriv = xf86GetEntityPrivate(pScrn->entityList[0], MGAEntityIndex);
        pMgaEnt = pPriv->ptr;
@@ -2988,7 +3048,7 @@
 #ifdef USEMGAHAL
     MGA_HAL(
 	/* There is a problem in the HALlib: set soft reset bit */
-	/* MATROX: hint, hint */
+	/* MATROX: hint, hint. */
 	if (!pMga->Primary && !pMga->FBDev &&
 	    (pMga->PciInfo->subsysCard == PCI_CARD_MILL_G200_SG) ) {
 	    OUTREG(MGAREG_Reset, 1);
@@ -3040,7 +3100,6 @@
 	if (!MGAModeInit(pScrn, pScrn->currentMode))
 	    return FALSE;
     }
-
     /* Darken the screen for aesthetic reasons and set the viewport */
     if (pMga->SecondCrtc == TRUE) {
         MGASaveScreenCrtc2(pScreen, SCREEN_SAVER_ON);
@@ -3290,7 +3349,7 @@
     } else {
         xf86DrvMsg(pScrn->scrnIndex, driFrom, "Direct rendering disabled\n");
     }
-    if (xf86IsEntityShared(pScrn->entityList[0]) && pMga->SecondCrtc == FALSE)
+    if (pMga->DualHeadEnabled && pMga->SecondCrtc == FALSE)
 	pMgaEnt->directRenderingEnabled = pMga->directRenderingEnabled;
     pMga->haveQuiescense = 1;
 #endif
@@ -3318,7 +3377,7 @@
 Bool
 MGASwitchMode(int scrnIndex, DisplayModePtr mode, int flags)
 {
-    return MGAModeInit(xf86Screens[scrnIndex], mode);
+    return  MGAModeInit(xf86Screens[scrnIndex], mode);
 }
 
 
@@ -3513,6 +3572,7 @@
     vgaHWPtr hwp = VGAHWPTR(pScrn);
     MGAPtr pMga = MGAPTR(pScrn);
     MGAEntPtr pMgaEnt = NULL;
+
 #ifdef USEMGAHAL    
     MGA_HAL( RESTORE_TEXTMODE_ON_DVI(pMga); );
 #endif
@@ -3534,7 +3594,7 @@
    }
 #endif
 
-   if (xf86IsEntityShared(pScrn->entityList[0])) {
+   if (pMga->DualHeadEnabled) {
        DevUnion *pPriv;
        pPriv = xf86GetEntityPrivate(pScrn->entityList[0], MGAEntityIndex);
        pMgaEnt = pPriv->ptr;
@@ -3543,7 +3603,7 @@
 
 #ifdef USEMGAHAL
    MGA_HAL(
-   if(xf86IsEntityShared(pScrn->entityList[0])) {
+   if(pMga->DualHeadEnabled) {
       if(pMgaEnt->refCount == 0) {
 	 /* Both boards have closed there screen */
 	 MGACloseLibrary(pMga->pBoard);
--- XFree86-4.2.0/xc/programs/Xserver/hw/xfree86/drivers/mga.orig/mga_g450pll.c	Sat Jan 12 00:42:57 2002
+++ XFree86-4.2.0/xc/programs/Xserver/hw/xfree86/drivers/mga/mga_g450pll.c	Sun Apr 14 15:07:08 2002
@@ -208,6 +208,26 @@
    return TRUE;
 }
 
+static CARD32 G450ReadMNP(ScrnInfoPtr pScrn)
+{
+   MGAPtr pMga = MGAPTR(pScrn);
+   MGARegPtr pReg;
+   CARD32 ret = 0;
+
+   pReg = &pMga->ModeReg;
+
+   if (!pMga->SecondCrtc) {
+      ret = (CARD8)inMGAdac(MGA1064_PIX_PLLC_M) << 16;   
+      ret |= (CARD8)inMGAdac(MGA1064_PIX_PLLC_N) << 8;   
+      ret |= (CARD8)inMGAdac(MGA1064_PIX_PLLC_P);   
+   } else {
+      ret = (CARD8)inMGAdac(MGA1064_VID_PLL_M) << 16;
+      ret |= (CARD8)inMGAdac(MGA1064_VID_PLL_N) << 8; 
+      ret |= (CARD8)inMGAdac(MGA1064_VID_PLL_P);
+   }
+   return ret;
+}
+
 
 static CARD32 G450CompareMNP(ScrnInfoPtr pScrn, CARD32 ulFout, CARD32 ulMNP1,
                       CARD32 ulMNP2, long *pulResult)
@@ -305,6 +325,9 @@
 
    MGAPtr pMga = MGAPTR(pScrn);
 
+#ifdef DEBUG
+   xf86DrvMsg(pScrn->scrnIndex,X_INFO, "Restoring PLLClk = %d\n",f_out);
+#endif
    G450FindFirstPLLParam(pScrn, f_out, &ulMNP);
    ulMNPTable[0] = ulMNP;
    G450FindNextPLLParam(pScrn, f_out, &ulMNP);
@@ -454,4 +477,21 @@
    }
   
    return TRUE;
+}
+
+long
+MGAG450SavePLLFreq(ScrnInfoPtr pScrn) 
+{
+    CARD32 ulMNP = G450ReadMNP(pScrn);
+    CARD8  ucP;
+    CARD32 freq;
+
+    G450CalculVCO(pScrn, ulMNP, &freq);
+    ucP = (CARD8)(ulMNP & 0x03);
+    G450ApplyPFactor(pScrn, ucP, &freq);
+
+#ifdef DEBUG
+    xf86DrvMsg(pScrn->scrnIndex,X_INFO,"Saved PLLClk = %d\n",freq);
+#endif
+    return freq;
 }
diff -urN XFree86-4.2.0/xc/programs/Xserver/hw/xfree86/drivers/mga.orig/mga_macros.h XFree86-4.2.0/xc/programs/Xserver/hw/xfree86/drivers/mga/mga_macros.h
--- XFree86-4.2.0/xc/programs/Xserver/hw/xfree86/drivers/mga.orig/mga_macros.h	Wed Sep 26 21:59:17 2001
+++ XFree86-4.2.0/xc/programs/Xserver/hw/xfree86/drivers/mga/mga_macros.h	Sun Apr 14 15:07:08 2002
@@ -111,5 +111,8 @@
 
 #define MGAISGx50(x) ( (((x)->Chipset == PCI_CHIP_MGAG400) && ((x)->ChipRev >= 0x80)) || \
 		       ((x)->Chipset == PCI_CHIP_MGAG550) )
+
+#define MGA_DH_NEEDS_HAL(x) (((x)->Chipset == PCI_CHIP_MGAG400) && \
+			     ((x)->ChipRev < 0x80))
 
 #endif /* _MGA_MACROS_H_ */
