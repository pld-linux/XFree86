diff -c -N -r xc.old/config/cf/X11.tmpl xc/config/cf/X11.tmpl
*** xc.old/config/cf/X11.tmpl	Mon Mar  2 03:55:22 1998
--- xc/config/cf/X11.tmpl	Sat Apr 11 13:56:54 1998
***************
*** 202,207 ****
--- 202,213 ----
  #ifndef BuildXF86DGALibrary
  #define BuildXF86DGALibrary	BuildXF86DGA
  #endif
+ #ifndef BuildXF86RushExt
+ #define BuildXF86RushExt	NO
+ #endif
+ #ifndef BuildXF86RushLibrary
+ #define BuildXF86RushLibrary	BuildXF86RushExt
+ #endif
  #ifndef BuildDPMSExt
  #define BuildDPMSExt		NO
  #endif
***************
*** 992,997 ****
--- 998,1019 ----
  #endif
  #endif
  
+ #if BuildXF86RushLibrary
+ #ifndef SharedLibXxf86rush
+ #define SharedLibXxf86rush	YES
+ #endif
+ #ifndef NormalLibXxf86rush
+ #define NormalLibXxf86rush	YES
+ #endif
+ #ifndef DebugLibXxf86rush
+ #define DebugLibXxf86rush	NO
+ #endif
+ #ifndef ProfileLibXxf86rush
+ #define ProfileLibXxf86rush	NO
+ #endif
+ #endif
+ 
+ 
  #if BuildDPMSLibrary
  #ifndef SharedLibXdpms
  #define SharedLibXdpms		NO
***************
*** 1078,1083 ****
--- 1100,1117 ----
  SharedLibReferences(XXF86DGA,Xxf86dga,$(XXF86DGALIBSRC),SOXXF86DGAREV,SharedXxf86dgaRev)
  #else
  ProjectUnsharedLibReferences(XXF86DGA,Xxf86dga,$(XXF86DGALIBSRC),XBuildLibDir)
+ #endif
+ #endif
+ 
+ #if BuildXF86RushLibrary
+    XXF86RUSHLIBSRC = $(LIBSRC)/Xxf86rush
+ #if SharedLibXxf86rush
+ #ifndef SharedXxf86RushRev
+ #define SharedXxf86RushRev 1.0
+ #endif
+ SharedLibReferences(XXF86RUSH,Xxf86rush,$(XXF86RUSHLIBSRC),SOXXF86RUSHREV,SharedXxf86RushRev)
+ #else
+ ProjectUnsharedLibReferences(XXF86RUSH,Xxf86rush,$(XXF86RUSHLIBSRC),XBuildLibDir)
  #endif
  #endif
  
diff -c -N -r xc.old/config/cf/xfree86.cf xc/config/cf/xfree86.cf
*** xc.old/config/cf/xfree86.cf	Mon Mar  2 03:55:22 1998
--- xc/config/cf/xfree86.cf	Sat Apr 11 15:34:02 1998
***************
*** 619,624 ****
--- 619,627 ----
  #ifndef BuildDPMSLibrary
  #define BuildDPMSLibrary	YES
  #endif
+ #ifndef BuildXF86RushLibrary
+ #define BuildXF86RushLibrary	YES
+ #endif
  
  /*
   * Build the XFree86-VidMode extension
***************
*** 673,678 ****
--- 676,688 ----
  #define BuildDPMSExt			YES
  #endif
  
+ /*
+  * Build the Rush extension support
+  */
+ #ifndef BuildXF86RushExt
+ #define BuildXF86RushExt		YES
+ #endif
+ 
  #if Malloc0ReturnsNull
  #ifndef XtMalloc0ReturnsNullDefines
  #define XtMalloc0ReturnsNullDefines	Malloc0ReturnsNullDefines -DXTMALLOC_BC
***************
*** 764,769 ****
--- 774,785 ----
  #define XFree86DGADefines	/**/
  #endif
  
+ #if BuildXF86RushExt
+ #define XFree86RushDefines	-DXFreeXRUSH
+ #else
+ #define XFree86RushDefines	/**/
+ #endif
+ 
  #ifndef MakeHasPosixVariableSubstitutions
  #if !HasBsdMake
  #define MakeHasPosixVariableSubstitutions	NO
***************
*** 774,780 ****
  
  /* Server defines required for all OSs */
  #ifndef XFree86ServerDefines
! #define XFree86ServerDefines	-DSTATIC_COLOR -DAVOID_GLYPHBLT -DPIXPRIV LinkKitDefines XFree86DGADefines
  #endif
  
  #ifndef XFree86ServerOSDefines
--- 790,796 ----
  
  /* Server defines required for all OSs */
  #ifndef XFree86ServerDefines
! #define XFree86ServerDefines	-DSTATIC_COLOR -DAVOID_GLYPHBLT -DPIXPRIV LinkKitDefines XFree86DGADefines XFree86RushDefines
  #endif
  
  #ifndef XFree86ServerOSDefines
*** xc.old/include/extensions/Imakefile	Sun Jan 12 02:39:14 1997
--- xc/include/extensions/Imakefile	Sun Apr  5 17:34:16 1998
***************
*** 14,19 ****
--- 14,22 ----
  #if BuildXF86DGALibrary
  XF86DGAHEADERS = xf86dga.h xf86dgastr.h
  #endif
+ #if BuildXF86RushLibrary
+ XF86RUSHHEADERS = xf86rush.h xf86rushstr.h
+ #endif
  #if BuildLBX
  LBXHEADERS = lbxbuf.h lbxbufstr.h lbxdeltastr.h lbximage.h lbxopts.h lbxstr.h lbxzlib.h
  #endif
***************
*** 21,27 ****
  DPMSHEADERS = dpms.h dpmsstr.h
  #endif
  
! EXTRAHEADERS = $(SCREENSAVERHEADERS) $(XF86VIDMODEHEADERS) $(XF86DGAHEADERS) $(XF86MISCHEADERS) $(LBXHEADERS) $(DPMSHEADERS)
  
  
  
--- 24,30 ----
  DPMSHEADERS = dpms.h dpmsstr.h
  #endif
  
! EXTRAHEADERS = $(SCREENSAVERHEADERS) $(XF86VIDMODEHEADERS) $(XF86DGAHEADERS) $(XF86RUSHHEADERS) $(XF86MISCHEADERS) $(LBXHEADERS) $(DPMSHEADERS)
  
  
  
diff -c -N -r xc.old/include/extensions/xf86rush.h xc/include/extensions/xf86rush.h
*** xc.old/include/extensions/xf86rush.h	Wed Dec 31 16:00:00 1969
--- xc/include/extensions/xf86rush.h	Sun Apr 19 15:56:23 1998
***************
*** 0 ****
--- 1,70 ----
+ /* $$ */
+ /*
+ 
+ Copyright (c) 1998  Daryll Strauss
+ 
+ */
+ 
+ #ifndef _XF86RUSH_H_
+ #define _XF86RUSH_H_
+ 
+ #include <X11/Xfuncproto.h>
+ 
+ #define X_XF86RushQueryVersion		0
+ #define X_XF86RushLockPixmap		1
+ #define X_XF86RushUnlockPixmap		2
+ #define X_XF86RushUnlockAllPixmaps	3
+ 
+ #define XF86RushNumberEvents		0
+ 
+ #define XF86RushClientNotLocal		0
+ #define XF86RushNumberErrors		(XF86RushClientNotLocal + 1)
+ 
+ #ifndef _XF86RUSH_SERVER_
+ 
+ _XFUNCPROTOBEGIN
+ 
+ Bool XF86RushQueryVersion(
+ #if NeedFunctionPrototypes
+     Display*		/* dpy */,
+     int*		/* majorVersion */,
+     int*		/* minorVersion */
+ #endif
+ );
+ 
+ Bool XF86RushQueryExtension(
+ #if NeedFunctionPrototypes
+     Display*		/* dpy */,
+     int*		/* event_base */,
+     int*		/* error_base */
+ #endif
+ );
+ 
+ Bool XF86RushLockPixmap(
+ #if NeedFunctionPrototypes
+     Display *		/* dpy */,
+     int			/* screen */,
+     Pixmap		/* Pixmap */,
+     void **		/* Return address */
+ #endif
+ );
+ 
+ Bool XF86RushUnlockPixmap(
+ #if NeedFunctionPrototypes
+     Display *		/* dpy */,
+     int			/* screen */,
+     Pixmap		/* Pixmap */
+ #endif
+ ); 
+ 
+ Bool XF86RushUnlockAllPixmaps(
+ #if NeedFunctionPrototypes
+     Display *		/* dpy */
+ #endif			    
+ );
+ 
+ _XFUNCPROTOEND
+ 
+ #endif /* _XF86RUSH_SERVER_ */
+ 
+ #endif /* _XF86RUSH_H_ */
diff -c -N -r xc.old/include/extensions/xf86rushstr.h xc/include/extensions/xf86rushstr.h
*** xc.old/include/extensions/xf86rushstr.h	Wed Dec 31 16:00:00 1969
--- xc/include/extensions/xf86rushstr.h	Sun Apr  5 21:44:32 1998
***************
*** 0 ****
--- 1,82 ----
+ /* $$ */
+ /*
+ 
+ Copyright (c) 1998  Daryll Strauss
+ 
+ */
+ 
+ #ifndef _XF86RUSHSTR_H_
+ #define _XF86RUSHSTR_H_
+ 
+ #include "xf86rush.h"
+ 
+ #define XF86RUSHNAME "XFree86-Rush"
+ 
+ #define XF86RUSH_MAJOR_VERSION	1	/* current version numbers */
+ #define XF86RUSH_MINOR_VERSION	0
+ 
+ typedef struct _XF86RushQueryVersion {
+     CARD8	reqType;		/* always RushReqCode */
+     CARD8	rushReqType;		/* always X_RushQueryVersion */
+     CARD16	length B16;
+ } xXF86RushQueryVersionReq;
+ #define sz_xXF86RushQueryVersionReq	4
+ 
+ typedef struct {
+     BYTE	type;			/* X_Reply */
+     BOOL	pad1;
+     CARD16	sequenceNumber B16;
+     CARD32	length B32;
+     CARD16	majorVersion B16;	/* major version of Rush protocol */
+     CARD16	minorVersion B16;	/* minor version of Rush protocol */
+     CARD32	pad2 B32;
+     CARD32	pad3 B32;
+     CARD32	pad4 B32;
+     CARD32	pad5 B32;
+     CARD32	pad6 B32;
+ } xXF86RushQueryVersionReply;
+ #define sz_xXF86RushQueryVersionReply	32
+ 
+ typedef struct _XF86RushLockPixmap {
+     CARD8	reqType;		/* always RushReqCode */
+     CARD8	rushReqType;		/* always X_RushLockPixmap */
+     CARD16	length B16;
+     CARD16	screen B16;
+     CARD16	pad B16;
+     CARD32	pixmap B32;
+ } xXF86RushLockPixmapReq;
+ #define sz_xXF86RushLockPixmapReq	12
+ 
+ typedef struct {
+     BYTE	type;
+     BOOL	pad1;
+     CARD16	sequenceNumber B16;
+     CARD32	length B32;
+     CARD32	addr B32;
+     CARD32	pad2 B32;
+     CARD32	pad3 B32;
+     CARD32	pad4 B32;
+     CARD32	pad5 B32;
+     CARD32	pad6 B32;
+ } xXF86RushLockPixmapReply;
+ #define sz_xXF86RushLockPixmapReply	32
+ 
+ typedef struct _XF86RushUnlockPixmap {
+     CARD8	reqType;		/* always RushReqCode */
+     CARD8	rushReqType;		/* always X_RushUnlockPixmap */
+     CARD16	length B16;
+     CARD16	screen B16;
+     CARD16	pad B16;
+     CARD32	pixmap B32;
+ } xXF86RushUnlockPixmapReq;
+ #define sz_xXF86RushUnlockPixmapReq	12
+ 
+ typedef struct _XF86RushUnlockAllPixmaps {
+     CARD8	reqType;		/* always RushReqCode */
+     CARD8	rushReqType;		/* always X_RushUnlockAllPixmaps */
+     CARD16      length B16;
+ } xXF86RushUnlockAllPixmapsReq;
+ #define sz_xXF86RushUnlockAllPixmapsReq   4
+ 
+ #endif /* _XF86RUSHSTR_H_ */
+ 
diff -c -N -r xc.old/lib/Imakefile xc/lib/Imakefile
*** xc.old/lib/Imakefile	Sat Jul  5 08:55:33 1997
--- xc/lib/Imakefile	Sat Apr 11 13:24:59 1998
***************
*** 39,45 ****
  XF86DGALIB = Xxf86dga
  #endif
  
! XF86EXTLIBS = $(XF86MISCLIB) $(XF86VMLIB) $(XF86DGALIB)
  
  #if BuildDPMSLibrary
  XDPMSLIBDIR = Xdpms
--- 39,49 ----
  XF86DGALIB = Xxf86dga
  #endif
  
! #if BuildXF86RushLibrary
! XF86RUSHLIB = Xxf86rush
! #endif
! 
! XF86EXTLIBS = $(XF86MISCLIB) $(XF86VMLIB) $(XF86DGALIB) $(XF86RUSHLIB)
  
  #if BuildDPMSLibrary
  XDPMSLIBDIR = Xdpms
***************
*** 61,67 ****
  
  #if !BuildServersOnly
  LINTSUBDIRS = Xau Xdmcp $(THRSTUBLIB) X11 oldX ICE SM Xext Xt \
! 	     $(SSLIB) $(XF86MISCLIB) $(XF86VMLIB) $(XF86DGALIB) \
  	     Xmu Xaw XIE Xi Xtst FS \
  	     PEX5 $(XKBLIBDIR) $(XKBUILIBDIR) $(LBXUTILDIR) $(XALIBDIR) \
  	     $(XDPMSLIBDIR) \
--- 65,71 ----
  
  #if !BuildServersOnly
  LINTSUBDIRS = Xau Xdmcp $(THRSTUBLIB) X11 oldX ICE SM Xext Xt \
! 	     $(SSLIB) $(XF86MISCLIB) $(XF86VMLIB) $(XF86DGALIB) $(XF86RUSHLIB) \
  	     Xmu Xaw XIE Xi Xtst FS \
  	     PEX5 $(XKBLIBDIR) $(XKBUILIBDIR) $(LBXUTILDIR) $(XALIBDIR) \
  	     $(XDPMSLIBDIR) \
diff -c -N -r xc.old/lib/Xext/XF86Rush.c xc/lib/Xext/XF86Rush.c
*** xc.old/lib/Xext/XF86Rush.c	Wed Dec 31 16:00:00 1969
--- xc/lib/Xext/XF86Rush.c	Sun Apr  5 18:01:55 1998
***************
*** 0 ****
--- 1,163 ----
+ /* $$ */
+ /*
+ 
+ Copyright (c) 1998 Daryll Strauss
+ 
+ */
+ 
+ /* THIS IS NOT AN X CONSORTIUM STANDARD */
+ 
+ #define NEED_EVENTS
+ #define NEED_REPLIES
+ #include "Xlibint.h"
+ #include "xf86rushstr.h"
+ #include "Xext.h"
+ #include "extutil.h"
+ 
+ static XExtensionInfo _xf86rush_info_data;
+ static XExtensionInfo *xf86rush_info = &_xf86rush_info_data;
+ static char *xf86rush_extension_name = XF86RUSHNAME;
+ 
+ #define XF86RushCheckExtension(dpy,i,val) \
+   XextCheckExtension (dpy, i, xf86rush_extension_name, val)
+ 
+ /*****************************************************************************
+  *                                                                           *
+  *			   private utility routines                          *
+  *                                                                           *
+  *****************************************************************************/
+ 
+ static int close_display();
+ static /* const */ XExtensionHooks xf86rush_extension_hooks = {
+     NULL,				/* create_gc */
+     NULL,				/* copy_gc */
+     NULL,				/* flush_gc */
+     NULL,				/* free_gc */
+     NULL,				/* create_font */
+     NULL,				/* free_font */
+     close_display,			/* close_display */
+     NULL,				/* wire_to_event */
+     NULL,				/* event_to_wire */
+     NULL,				/* error */
+     NULL,				/* error_string */
+ };
+ 
+ static XEXT_GENERATE_FIND_DISPLAY (find_display, xf86rush_info, 
+ 				   xf86rush_extension_name, 
+ 				   &xf86rush_extension_hooks, 
+ 				   0, NULL)
+ 
+ static XEXT_GENERATE_CLOSE_DISPLAY (close_display, xf86rush_info)
+ 
+ 
+ /*****************************************************************************
+  *                                                                           *
+  *		    public XFree86-DGA Extension routines                *
+  *                                                                           *
+  *****************************************************************************/
+ 
+ Bool XF86RushQueryExtension (dpy, event_basep, error_basep)
+     Display *dpy;
+     int *event_basep, *error_basep;
+ {
+     XExtDisplayInfo *info = find_display (dpy);
+ 
+     if (XextHasExtension(info)) {
+ 	*event_basep = info->codes->first_event;
+ 	*error_basep = info->codes->first_error;
+ 	return True;
+     } else {
+ 	return False;
+     }
+ }
+ 
+ Bool XF86RushQueryVersion(dpy, majorVersion, minorVersion)
+     Display* dpy;
+     int* majorVersion; 
+     int* minorVersion;
+ {
+     XExtDisplayInfo *info = find_display (dpy);
+     xXF86RushQueryVersionReply rep;
+     xXF86RushQueryVersionReq *req;
+ 
+     XF86RushCheckExtension (dpy, info, False);
+ 
+     LockDisplay(dpy);
+     GetReq(XF86RushQueryVersion, req);
+     req->reqType = info->codes->major_opcode;
+     req->dgaReqType = X_XF86RushQueryVersion;
+     if (!_XReply(dpy, (xReply *)&rep, 0, xFalse)) {
+ 	UnlockDisplay(dpy);
+ 	SyncHandle();
+ 	return False;
+     }
+     *majorVersion = rep.majorVersion;
+     *minorVersion = rep.minorVersion;
+     UnlockDisplay(dpy);
+     SyncHandle();
+     return True;
+ }
+ 
+ Bool XF86RushLockPixmap(dpy, screen, pixmap, addr)
+      Display *dpy;
+      int screen;
+      Pixmap pixmap;
+      void **addr;
+ {
+   XExtDisplayInfo *info = find_display (dpy);
+   xXF86RushLockPixmapReply rep;
+   xXF86RushLockPixmapReq *req;
+ 
+   XF86RushCheckExtension (dpy, info, False);
+   LockDisplay(dpy);
+   GetReq(XF86RushLockPixmap, req);
+   req->reqType = info->codes->major_opcode;
+   req->dgaReqType = X_XF86RushLockPixmap;
+   req->screen=screen;
+   req->pixmap=pixmap;
+   if (!_XReply(dpy, (xReply *)&rep, 0, xFalse)) {
+     UnlockDisplay(dpy);
+     SyncHandle();
+     return False;
+   }
+   *addr=(void*)rep.addr;
+   UnlockDisplay(dpy);
+   SyncHandle();
+   return True;
+ }
+ 
+ Bool XF86RushUnlockPixmap(dpy, screen, pixmap)
+      Display *dpy;
+      int screen;
+      Pixmap pixmap;
+ {
+   XExtDisplayInfo *info = find_display(dpy);
+   xXF86RushUnlockPixmapReq *req;
+ 
+   XF86RushCheckExtension (dpy, info, False);
+   LockDisplay(dpy);
+   GetReq(XF86RushUnlockPixmap, req);
+   req->reqType = info->codes->major_opcode;
+   req->dgaReqType = X_XF86RushUnlockPixmap;
+   req->screen=screen;
+   req->pixmap=pixmap;
+   UnlockDisplay(dpy);
+   SyncHandle();
+   return True;
+ }
+ 
+ Bool XF86RushUnlockAllPixmaps(dpy)
+      Display *dpy;
+ {
+   XExtDisplayInfo *info = find_display(dpy);
+   xXF86RushUnlockAllPixmapsReq *req;
+ 
+   XF86RushCheckExtension (dpy, info, False);
+   LockDisplay(dpy);
+   GetReq(XF86RushUnlockAllPixmaps, req);
+   req->reqType = info->codes->major_opcode;
+   req->dgaReqType = X_XF86RushUnlockAllPixmaps;
+   UnlockDisplay(dpy);
+   SyncHandle();
+   return True;
+ }
diff -c -N -r xc.old/lib/Xxf86rush/Imakefile xc/lib/Xxf86rush/Imakefile
*** xc.old/lib/Xxf86rush/Imakefile	Wed Dec 31 16:00:00 1969
--- xc/lib/Xxf86rush/Imakefile	Sat Apr 11 13:29:38 1998
***************
*** 0 ****
--- 1,33 ----
+ XCOMM $$
+ #define DoNormalLib NormalLibXxf86rush
+ #define DoSharedLib SharedLibXxf86rush
+ #define DoDebugLib DebugLibXxf86rush
+ #define DoProfileLib ProfileLibXxf86rush
+ #define LibName Xxf86rush
+ #define SoRev SOXXF86RUSHREV
+ #define LibHeaders NO
+ 
+ #include <Threads.tmpl>
+ 
+ #ifdef SharedXxf86rushReqs
+ REQUIREDLIBS = SharedXxf86rushReqs
+ #endif
+ 
+ XF86RUSHSRCS = XF86Rush.c
+ XF86RUSHOBJS = XF86Rush.o
+ 
+ #if Malloc0ReturnsNull
+ ALLOC_DEFINES = -DMALLOC_0_RETURNS_NULL
+ #endif
+ 
+       DEFINES = $(ALLOC_DEFINES)
+      INCLUDES = -I$(XLIBSRC) -I$(EXTINCSRC)
+          SRCS = $(XF86RUSHSRCS)
+          OBJS = $(XF86RUSHOBJS)
+      LINTLIBS = $(LINTXLIB)
+ 
+ #include <Library.tmpl>
+ 
+ DependTarget()
+ 
+ 
diff -c -N -r xc.old/lib/Xxf86rush/XF86Rush.c xc/lib/Xxf86rush/XF86Rush.c
*** xc.old/lib/Xxf86rush/XF86Rush.c	Wed Dec 31 16:00:00 1969
--- xc/lib/Xxf86rush/XF86Rush.c	Sat Apr 11 13:55:40 1998
***************
*** 0 ****
--- 1,163 ----
+ /* $$ */
+ /*
+ 
+ Copyright (c) 1998 Daryll Strauss
+ 
+ */
+ 
+ /* THIS IS NOT AN X CONSORTIUM STANDARD */
+ 
+ #define NEED_EVENTS
+ #define NEED_REPLIES
+ #include "Xlibint.h"
+ #include "xf86rushstr.h"
+ #include "Xext.h"
+ #include "extutil.h"
+ 
+ static XExtensionInfo _xf86rush_info_data;
+ static XExtensionInfo *xf86rush_info = &_xf86rush_info_data;
+ static char *xf86rush_extension_name = XF86RUSHNAME;
+ 
+ #define XF86RushCheckExtension(dpy,i,val) \
+   XextCheckExtension (dpy, i, xf86rush_extension_name, val)
+ 
+ /*****************************************************************************
+  *                                                                           *
+  *			   private utility routines                          *
+  *                                                                           *
+  *****************************************************************************/
+ 
+ static int close_display();
+ static /* const */ XExtensionHooks xf86rush_extension_hooks = {
+     NULL,				/* create_gc */
+     NULL,				/* copy_gc */
+     NULL,				/* flush_gc */
+     NULL,				/* free_gc */
+     NULL,				/* create_font */
+     NULL,				/* free_font */
+     close_display,			/* close_display */
+     NULL,				/* wire_to_event */
+     NULL,				/* event_to_wire */
+     NULL,				/* error */
+     NULL,				/* error_string */
+ };
+ 
+ static XEXT_GENERATE_FIND_DISPLAY (find_display, xf86rush_info, 
+ 				   xf86rush_extension_name, 
+ 				   &xf86rush_extension_hooks, 
+ 				   0, NULL)
+ 
+ static XEXT_GENERATE_CLOSE_DISPLAY (close_display, xf86rush_info)
+ 
+ 
+ /*****************************************************************************
+  *                                                                           *
+  *		    public XFree86-DGA Extension routines                *
+  *                                                                           *
+  *****************************************************************************/
+ 
+ Bool XF86RushQueryExtension (dpy, event_basep, error_basep)
+     Display *dpy;
+     int *event_basep, *error_basep;
+ {
+     XExtDisplayInfo *info = find_display (dpy);
+ 
+     if (XextHasExtension(info)) {
+ 	*event_basep = info->codes->first_event;
+ 	*error_basep = info->codes->first_error;
+ 	return True;
+     } else {
+ 	return False;
+     }
+ }
+ 
+ Bool XF86RushQueryVersion(dpy, majorVersion, minorVersion)
+     Display* dpy;
+     int* majorVersion; 
+     int* minorVersion;
+ {
+     XExtDisplayInfo *info = find_display (dpy);
+     xXF86RushQueryVersionReply rep;
+     xXF86RushQueryVersionReq *req;
+ 
+     XF86RushCheckExtension (dpy, info, False);
+ 
+     LockDisplay(dpy);
+     GetReq(XF86RushQueryVersion, req);
+     req->reqType = info->codes->major_opcode;
+     req->rushReqType = X_XF86RushQueryVersion;
+     if (!_XReply(dpy, (xReply *)&rep, 0, xFalse)) {
+ 	UnlockDisplay(dpy);
+ 	SyncHandle();
+ 	return False;
+     }
+     *majorVersion = rep.majorVersion;
+     *minorVersion = rep.minorVersion;
+     UnlockDisplay(dpy);
+     SyncHandle();
+     return True;
+ }
+ 
+ Bool XF86RushLockPixmap(dpy, screen, pixmap, addr)
+      Display *dpy;
+      int screen;
+      Pixmap pixmap;
+      void **addr;
+ {
+   XExtDisplayInfo *info = find_display (dpy);
+   xXF86RushLockPixmapReply rep;
+   xXF86RushLockPixmapReq *req;
+ 
+   XF86RushCheckExtension (dpy, info, False);
+   LockDisplay(dpy);
+   GetReq(XF86RushLockPixmap, req);
+   req->reqType = info->codes->major_opcode;
+   req->rushReqType = X_XF86RushLockPixmap;
+   req->screen=screen;
+   req->pixmap=pixmap;
+   if (!_XReply(dpy, (xReply *)&rep, 0, xFalse)) {
+     UnlockDisplay(dpy);
+     SyncHandle();
+     return False;
+   }
+   *addr=(void*)rep.addr;
+   UnlockDisplay(dpy);
+   SyncHandle();
+   return True;
+ }
+ 
+ Bool XF86RushUnlockPixmap(dpy, screen, pixmap)
+      Display *dpy;
+      int screen;
+      Pixmap pixmap;
+ {
+   XExtDisplayInfo *info = find_display(dpy);
+   xXF86RushUnlockPixmapReq *req;
+ 
+   XF86RushCheckExtension (dpy, info, False);
+   LockDisplay(dpy);
+   GetReq(XF86RushUnlockPixmap, req);
+   req->reqType = info->codes->major_opcode;
+   req->rushReqType = X_XF86RushUnlockPixmap;
+   req->screen=screen;
+   req->pixmap=pixmap;
+   UnlockDisplay(dpy);
+   SyncHandle();
+   return True;
+ }
+ 
+ Bool XF86RushUnlockAllPixmaps(dpy)
+      Display *dpy;
+ {
+   XExtDisplayInfo *info = find_display(dpy);
+   xXF86RushUnlockAllPixmapsReq *req;
+ 
+   XF86RushCheckExtension (dpy, info, False);
+   LockDisplay(dpy);
+   GetReq(XF86RushUnlockAllPixmaps, req);
+   req->reqType = info->codes->major_opcode;
+   req->rushReqType = X_XF86RushUnlockAllPixmaps;
+   UnlockDisplay(dpy);
+   SyncHandle();
+   return True;
+ }
diff -c -N -r xc.old/programs/Xserver/Xext/Imakefile ./Xext/Imakefile
*** xc.old/programs/Xserver/Xext/Imakefile	Fri Jan 23 04:35:11 1998
--- xc/programs/Xserver/Xext/Imakefile	Sun Apr  4 18:13:41 1999
***************
*** 32,37 ****
--- 32,42 ----
   DPMSOBJS = dpms.o
  #endif
  
+ #if BuildXF86RushExt
+  XF86RRUSHSRCS = xf86Rush.c
+  XF86RUSHOBJS = xf86Rush.o
+ #endif
+ 
  #if BuildAppgroup
    APPGROUPSRCS = appgroup.c
    APPGROUPOBJS = appgroup.o
***************
*** 47,59 ****
                mitmisc.c xtest.c xtest1di.c xtest1dd.c sleepuntil.c \
  	      bigreq.c sync.c $(SCRNSAVSRC) xcmisc.c $(VIDMODESRCS) \
  	      $(XF86MISCSRCS) $(XF86DGASRCS) $(SECURITYSRCS) \
! 	      $(DPMSSRCS) \
  	      $(APPGROUPSRCS) xprint.c
         OBJS = shape.o $(SHMOBJS) mbuf.o \
                mitmisc.o xtest.o xtest1di.o xtest1dd.o sleepuntil.o \
                bigreq.o sync.o $(SCRNSAVOBJ) xcmisc.o $(VIDMODEOBJS) \
  	      $(XF86MISCOBJS) $(XF86DGAOBJS) $(SECURITYOBJS) \
! 	      $(DPMSOBJS) \
  	      $(APPGROUPOBJS) xprint.o
  
  XF86INCLUDES = -I../hw/xfree86/common -I../hw/xfree86/os-support
--- 52,64 ----
                mitmisc.c xtest.c xtest1di.c xtest1dd.c sleepuntil.c \
  	      bigreq.c sync.c $(SCRNSAVSRC) xcmisc.c $(VIDMODESRCS) \
  	      $(XF86MISCSRCS) $(XF86DGASRCS) $(SECURITYSRCS) \
! 	      $(DPMSSRCS) $(XF86RUSHSRCS) \
  	      $(APPGROUPSRCS) xprint.c
         OBJS = shape.o $(SHMOBJS) mbuf.o \
                mitmisc.o xtest.o xtest1di.o xtest1dd.o sleepuntil.o \
                bigreq.o sync.o $(SCRNSAVOBJ) xcmisc.o $(VIDMODEOBJS) \
  	      $(XF86MISCOBJS) $(XF86DGAOBJS) $(SECURITYOBJS) \
! 	      $(DPMSOBJS) $(XF86RUSHOBJS) \
  	      $(APPGROUPOBJS) xprint.o
  
  XF86INCLUDES = -I../hw/xfree86/common -I../hw/xfree86/os-support
diff -c -N -r xc.old/programs/Xserver/Xext/xf86Rush.c ./Xext/xf86Rush.c
*** xc.old/programs/Xserver/Xext/xf86Rush.c	Wed Dec 31 16:00:00 1969
--- xc/programs/Xserver/Xext/xf86Rush.c	Sun Apr  4 18:13:41 1999
***************
*** 0 ****
--- 1,213 ----
+ /* $XFree86: $ */
+ 
+ /*
+ 
+ Copyright (c) 1998 Daryll Strauss
+ 
+ */
+ 
+ #define NEED_REPLIES
+ #define NEED_EVENTS
+ #include "X.h"
+ #include "Xproto.h"
+ #include "misc.h"
+ #include "dixstruct.h"
+ #include "extnsionst.h"
+ #include "colormapst.h"
+ #include "cursorstr.h"
+ #include "scrnintstr.h"
+ #include "servermd.h"
+ #define _XF86RUSH_SERVER_
+ #include "xf86rushstr.h"
+ #include "swaprep.h"
+ #include "../hw/xfree86/common/xf86.h"
+ #include <dlfcn.h>
+ 
+ #include <X11/Xtrans.h>
+ #include "../os/osdep.h"
+ #include <X11/Xauth.h>
+ #ifndef ESIX
+ #ifndef Lynx
+ #include <sys/socket.h>
+ #else
+ #include <socket.h>
+ #endif
+ #else
+ #include <lan/socket.h>
+ #endif
+ 
+ extern int xf86ScreenIndex;
+ static unsigned char RushReqCode = 0;
+ static int RushErrorBase;
+ 
+ static DISPATCH_PROC(ProcXF86RushDispatch);
+ static DISPATCH_PROC(ProcRushQueryVersion);
+ static DISPATCH_PROC(ProcRushLockPixmap);
+ static DISPATCH_PROC(ProcRushUnlockPixmap);
+ static DISPATCH_PROC(ProcRushUnlockAllPixmaps);
+ 
+ static DISPATCH_PROC(SProcXF86RushDispatch);
+ 
+ static void XF86RushResetProc(
+ #if NeedFunctionPrototypes
+     ExtensionEntry* /* extEntry */
+ #endif
+ );
+ 
+ void
+ XFree86RushExtensionInit()
+ {
+     ExtensionEntry* extEntry;
+ 
+     if (
+ 	(extEntry = AddExtension(XF86RUSHNAME,
+ 				XF86RushNumberEvents,
+ 				XF86RushNumberErrors,
+ 				ProcXF86RushDispatch,
+ 				SProcXF86RushDispatch,
+ 				XF86RushResetProc,
+ 				StandardMinorOpcode))) {
+ 	RushReqCode = (unsigned char)extEntry->base;
+ 	RushErrorBase = extEntry->errorBase;
+     }
+ }
+ 
+ /*ARGSUSED*/
+ static void
+ XF86RushResetProc (extEntry)
+     ExtensionEntry* extEntry;
+ {
+ }
+ 
+ static int
+ ProcRushQueryVersion(client)
+     register ClientPtr client;
+ {
+     xXF86RushQueryVersionReply rep;
+     register int n;
+ 
+     REQUEST_SIZE_MATCH(xXF86RushQueryVersionReq);
+     rep.type = X_Reply;
+     rep.length = 0;
+     rep.sequenceNumber = client->sequence;
+     rep.majorVersion = XF86RUSH_MAJOR_VERSION;
+     rep.minorVersion = XF86RUSH_MINOR_VERSION;
+     if (client->swapped) {
+     	swaps(&rep.sequenceNumber, n);
+     	swapl(&rep.length, n);
+     }
+     WriteToClient(client, sizeof(xXF86RushQueryVersionReply), (char *)&rep);
+     return (client->noClientException);
+ }
+ 
+ static int
+ ProcXF86RushLockPixmap(client)
+      register ClientPtr client;
+ {
+   REQUEST(xXF86RushLockPixmapReq);
+   xXF86RushLockPixmapReply rep;
+   ScrnInfoPtr vptr;
+   PixmapPtr pix;
+   void *handle;
+   void *(*func)();
+ 
+   if (stuff->screen > screenInfo.numScreens)
+     return BadValue;
+ 
+   vptr = (ScrnInfoPtr) screenInfo.screens[stuff->screen]->devPrivates[xf86ScreenIndex].ptr;
+ 
+   REQUEST_SIZE_MATCH(xXF86RushLockPixmapReq);
+   rep.type = X_Reply;
+   rep.length = 0;
+   rep.sequenceNumber = client->sequence;
+   pix = (PixmapPtr)SecurityLookupIDByType(client,
+ 					  stuff->pixmap, RT_PIXMAP, 
+ 					  SecurityReadAccess);
+   handle=dlopen(0, 0);
+   if (handle) {
+     func=(void*(*)())dlsym(handle, "xf86LockPixmap");
+     dlclose(handle);
+   }
+   if (handle && func) rep.addr=(int)func(pix);
+   else rep.addr = 0;
+ 
+   WriteToClient(client, SIZEOF(xXF86RushLockPixmapReply), (char*)&rep);
+   return client->noClientException;
+ }
+ 
+ static int
+ ProcXF86RushUnlockPixmap(client)
+      register ClientPtr client;
+ {
+   REQUEST(xXF86RushUnlockPixmapReq);
+   ScrnInfoPtr vptr;
+   PixmapPtr pix;
+   void *handle;
+   void (*func)();
+ 
+   if (stuff->screen > screenInfo.numScreens)
+     return BadValue;
+ 
+   vptr = (ScrnInfoPtr) screenInfo.screens[stuff->screen]->devPrivates[xf86ScreenIndex].ptr;
+   REQUEST_SIZE_MATCH(xXF86RushUnlockPixmapReq);
+   pix = (PixmapPtr)SecurityLookupIDByType(client,
+ 					  stuff->pixmap, RT_PIXMAP, 
+ 					  SecurityReadAccess);
+   handle=dlopen(0, 0);
+   if (handle) {
+     func=(void(*)())dlsym(handle, "xf86UnlockPixmap");
+     dlclose(handle);
+   }
+   if (handle && func) func(pix);
+   return client->noClientException;
+ }
+ 
+ static int
+ ProcXF86RushUnlockAllPixmaps(client)
+      register ClientPtr client;
+ {
+   void *handle;
+   void (*func)();
+ 
+   REQUEST(xXF86RushUnlockAllPixmapsReq);
+   REQUEST_SIZE_MATCH(xXF86RushUnlockAllPixmapsReq);
+   handle=dlopen(0, 0);
+   if (handle) {
+     func=(void(*)())dlsym(handle, "xf86UnlockAllPixmaps");
+     dlclose(handle);
+   }
+   if (handle && func) func();
+   return client->noClientException;
+ }
+ 
+ ProcXF86RushDispatch (client)
+     register ClientPtr	client;
+ {
+     REQUEST(xReq);
+ 
+     if (!LocalClient(client))
+ 	return RushErrorBase + XF86RushClientNotLocal;
+ 
+     switch (stuff->data)
+     {
+     case X_XF86RushQueryVersion:
+ 	return ProcRushQueryVersion(client);
+     case X_XF86RushLockPixmap:
+         return ProcXF86RushLockPixmap(client);
+     case X_XF86RushUnlockPixmap:
+         return ProcXF86RushUnlockPixmap(client);
+     case X_XF86RushUnlockAllPixmaps:
+         return ProcXF86RushUnlockAllPixmaps(client);
+     default:
+ 	return BadRequest;
+     }
+ }
+ 
+ SProcXF86RushDispatch (client)
+     register ClientPtr	client;
+ {
+     REQUEST(xReq);
+ 
+     return RushErrorBase + XF86RushClientNotLocal;
+ }
+ 
diff -c -N -r xc.old/programs/Xserver/hw/xfree86/LinkKit/Imakefile ./hw/xfree86/LinkKit/Imakefile
*** xc.old/programs/Xserver/hw/xfree86/LinkKit/Imakefile	Sun Jan 12 02:41:28 1997
--- xc/programs/Xserver/hw/xfree86/LinkKit/Imakefile	Sun Apr  4 18:13:41 1999
***************
*** 73,78 ****
--- 73,79 ----
  	LimitBoolean("BuildXF86VidModeExt", NO, BuildXF86VidModeExt) >> $@
  	LimitBoolean("BuildXF86MiscExt", NO, BuildXF86MiscExt) >> $@
  	LimitBoolean("BuildXF86DGA", NO, BuildXF86DGA) >> $@
+ 	LimitBoolean("BuildXF86RushExt", NO, BuildXF86RushExt) >> $@
  	LimitBoolean("BuildDPMSExt", BuildDPMSExt, BuildDPMSExt) >> $@
  
  clean::
diff -c -N -r xc.old/programs/Xserver/hw/xfree86/common/xf86Cursor.c ./hw/xfree86/common/xf86Cursor.c
*** xc.old/programs/Xserver/hw/xfree86/common/xf86Cursor.c	Sat Oct 31 12:13:18 1998
--- xc/programs/Xserver/hw/xfree86/common/xf86Cursor.c	Sun Apr  4 18:13:41 1999
***************
*** 138,143 ****
--- 138,150 ----
    Bool          frameChanged = FALSE;
    ScrnInfoPtr   pScr = XF86SCRNINFO(pScreen);
  
+ #ifdef XFreeXDGA
+   /*
+    * Since we're in DGA mode we need to trash this scroll request
+    */
+    if (pScr->directMode&XF86DGADirectGraphics)
+    return;
+ #endif
    /*
     * check wether (x,y) belongs to the visual part of the screen
     * if not, change the base of the displayed frame accoring
diff -c -N -r xc.old/programs/Xserver/hw/xfree86/vga256/drivers/apm/apm_cursor.c ./hw/xfree86/vga256/drivers/apm/apm_cursor.c
*** xc.old/programs/Xserver/hw/xfree86/vga256/drivers/apm/apm_cursor.c	Sun Jan 18 02:35:30 1998
--- xc/programs/Xserver/hw/xfree86/vga256/drivers/apm/apm_cursor.c	Sun Apr  4 18:13:42 1999
***************
*** 23,29 ****
  #include "apm.h"
  
  static void  ApmShowCursor(void);
! static void  ApmHideCursor(void);
  static Bool  ApmRealizeCursor(ScreenPtr pScr, CursorPtr pCurs);
  static Bool  ApmUnrealizeCursor(ScreenPtr pScr, CursorPtr pCurs);
  static void  ApmLoadCursorToCard(ScreenPtr pScr, CursorPtr pCurs, int x, int y);
--- 23,29 ----
  #include "apm.h"
  
  static void  ApmShowCursor(void);
! void  ApmHideCursor(void);
  static Bool  ApmRealizeCursor(ScreenPtr pScr, CursorPtr pCurs);
  static Bool  ApmUnrealizeCursor(ScreenPtr pScr, CursorPtr pCurs);
  static void  ApmLoadCursorToCard(ScreenPtr pScr, CursorPtr pCurs, int x, int y);
***************
*** 108,114 ****
   * This is also a local function, it's not called from outside.
   */
  
! static void 
  ApmHideCursor(void) 
  {
    ApmCheckMMIO_Init();
--- 108,114 ----
   * This is also a local function, it's not called from outside.
   */
  
! void 
  ApmHideCursor(void) 
  {
    ApmCheckMMIO_Init();
diff -c -N -r xc.old/programs/Xserver/hw/xfree86/vga256/drivers/apm/apm_driver.c ./hw/xfree86/vga256/drivers/apm/apm_driver.c
*** xc.old/programs/Xserver/hw/xfree86/vga256/drivers/apm/apm_driver.c	Sun Feb 15 16:42:15 1998
--- xc/programs/Xserver/hw/xfree86/vga256/drivers/apm/apm_driver.c	Sun Apr  4 18:13:42 1999
***************
*** 610,616 ****
--- 610,624 ----
  
  #ifdef XFreeXDGA
    if (vga256InfoRec.directMode&XF86DGADirectGraphics && !enter)
+   {
+     if (vgaHWCursor.Initialized == TRUE)
+     {
+       extern void ApmHideCursor(void);
+       ApmHideCursor();
+     }
      return;
+   }
+ 
  #endif
  
    if (enter)
***************
*** 965,970 ****
--- 973,985 ----
     */
    modinx(vgaIOBase + 4, 0x1c, 0x0f, (Base & 0x0f0000) >> 16);
  
+ #ifdef XFreeXDGA
+         if (vga256InfoRec.directMode & XF86DGADirectGraphics) {
+                 /* Wait until vertical retrace is in progress. */
+                 while (inb(vgaIOBase + 0xA) & 0x08);             
+                 while (!(inb(vgaIOBase + 0xA) & 0x08));             
+         }
+ #endif   
  }
  
  /*
diff -c -N -r xc.old/programs/Xserver/hw/xfree86/xaa/xf86cparea.c ./hw/xfree86/xaa/xf86cparea.c
*** xc.old/programs/Xserver/hw/xfree86/xaa/xf86cparea.c	Mon Nov 18 05:22:11 1996
--- xc/programs/Xserver/hw/xfree86/xaa/xf86cparea.c	Tue Apr  6 23:51:36 1999
***************
*** 85,90 ****
--- 85,92 ----
  #include	"xf86xaa.h"
  #include	"xf86local.h"
  
+ #include	"xf86Priv.h"
+ #include	"xf86pcache.h"
  
  RegionPtr
  xf86CopyArea(pSrcDrawable, pDstDrawable,
***************
*** 96,105 ****
      int width, height;
      int dstx, dsty;
  {
!     if (pSrcDrawable->type == DRAWABLE_WINDOW
!     && pDstDrawable->type == DRAWABLE_WINDOW) {
          return (*xf86GCInfoRec.cfbBitBltDispatch)(
!             pSrcDrawable, pDstDrawable,
              pGC, srcx, srcy, width, height, dstx, dsty,
              xf86DoBitBlt, 0L);
      }
--- 98,110 ----
      int width, height;
      int dstx, dsty;
  {
!     if ((pDstDrawable->type == DRAWABLE_WINDOW) &&
! 	((pSrcDrawable->type == DRAWABLE_WINDOW) ||
! 	((xf86AccelInfoRec.Flags & PIXMAP_CACHE) &&
! 	 (pSrcDrawable->type == DRAWABLE_PIXMAP) &&
! 	 xf86CacheIsLocked((PixmapPtr)pSrcDrawable)))) {
          return (*xf86GCInfoRec.cfbBitBltDispatch)(
! 	    pSrcDrawable, pDstDrawable,
              pGC, srcx, srcy, width, height, dstx, dsty,
              xf86DoBitBlt, 0L);
      }
***************
*** 132,137 ****
--- 137,154 ----
      int xdir;			/* 1 = left right, -1 = right left/ */
      int ydir;			/* 1 = top down, -1 = bottom up */
      int careful;
+     extern CacheInfoPtr xf86CacheInfo;
+     int i, slot;
+ 
+     /* Handle locked pixmaps just like screen to screen blits */
+     if (pSrc->type==DRAWABLE_PIXMAP) {
+       slot=((xf86PixPrivPtr)((PixmapPtr)pSrc)->devPrivates[xf86PixmapIndex].ptr)->slot;
+       pptTmp=pptSrc;
+       for (i=0; i<REGION_NUM_RECTS(prgnDst); i++, pptTmp++) {
+ 	pptTmp->x+=xf86CacheInfo[slot].x;
+ 	pptTmp->y+=xf86CacheInfo[slot].y;
+       }
+     }
  
      /* XXX we have to err on the side of safety when both are windows,
       * because we don't know if IncludeInferiors is being used.
diff -c -N -r xc.old/programs/Xserver/hw/xfree86/xaa/xf86pcache.c ./hw/xfree86/xaa/xf86pcache.c
*** xc.old/programs/Xserver/hw/xfree86/xaa/xf86pcache.c	Sun Feb  8 07:36:25 1998
--- xc/programs/Xserver/hw/xfree86/xaa/xf86pcache.c	Tue Apr 13 12:21:33 1999
***************
*** 127,144 ****
  
  CacheInfoPtr xf86CacheInfo = NULL;
  static int MaxSlot;
  static int MaxWidth;
  static int MaxHeight;
  static unsigned int pixmap_cache_clock = 1;
  static int FirstWideSlot;
  static int MaxWideSlotHeight;
  
  void xf86InitPixmapCacheSlots()
  {
      ScrnInfoPtr infoRec;
      int memoryStart, memoryEnd;
!     int width_in_bytes, cache_start_y, i;
!     int height_left, standard_slots, wide_slots, wide_slot_width;
  
      infoRec = xf86AccelInfoRec.ServerInfoRec;
      memoryStart = xf86AccelInfoRec.PixmapCacheMemoryStart;
--- 127,147 ----
  
  CacheInfoPtr xf86CacheInfo = NULL;
  static int MaxSlot;
+ static int MaxBigSlot;
  static int MaxWidth;
  static int MaxHeight;
  static unsigned int pixmap_cache_clock = 1;
  static int FirstWideSlot;
+ static int FirstBigSlot;
  static int MaxWideSlotHeight;
+ static int cache_start_y;
  
  void xf86InitPixmapCacheSlots()
  {
      ScrnInfoPtr infoRec;
      int memoryStart, memoryEnd;
!     int width_in_bytes, i;
!     int height_left, standard_slots, wide_slots, wide_slot_width, big_slots;
  
      infoRec = xf86AccelInfoRec.ServerInfoRec;
      memoryStart = xf86AccelInfoRec.PixmapCacheMemoryStart;
***************
*** 228,236 ****
          }
      }
  
      MaxSlot = standard_slots + wide_slots - 1;
!     xf86CacheInfo = (CacheInfoPtr)xcalloc(MaxSlot + 1, sizeof(CacheInfo));
      FirstWideSlot = standard_slots;
  
      ErrorF("%s %s: XAA: Using %d %dx%d ",
          XCONFIG_PROBED, infoRec->name, standard_slots, MaxWidth, MaxHeight);
--- 231,243 ----
          }
      }
  
+     /* Arbitrarily say you can have 10 big slots */
+     big_slots = 10;
      MaxSlot = standard_slots + wide_slots - 1;
!     MaxBigSlot = MaxSlot + big_slots;
!     xf86CacheInfo = (CacheInfoPtr)xcalloc(MaxBigSlot + 1, sizeof(CacheInfo));
      FirstWideSlot = standard_slots;
+     FirstBigSlot = standard_slots + wide_slots;
  
      ErrorF("%s %s: XAA: Using %d %dx%d ",
          XCONFIG_PROBED, infoRec->name, standard_slots, MaxWidth, MaxHeight);
***************
*** 255,261 ****
          xf86CacheInfo[i + standard_slots].cache_height = min(32, height_left);
      }
  
!     for (i = 0; i <= MaxSlot; i++) {
          xf86CacheInfo[i].id = -1;
          xf86CacheInfo[i].lru = pixmap_cache_clock;
          xf86CacheInfo[i].fg_color = 0;
--- 262,268 ----
          xf86CacheInfo[i + standard_slots].cache_height = min(32, height_left);
      }
  
!     for (i = 0; i <= MaxBigSlot; i++) {
          xf86CacheInfo[i].id = -1;
          xf86CacheInfo[i].lru = pixmap_cache_clock;
          xf86CacheInfo[i].fg_color = 0;
***************
*** 315,321 ****
  #ifdef PIXPRIV
      devPriv = (xf86PixPrivPtr)(pix->devPrivates[xf86PixmapIndex].ptr);
  
!     if (devPriv->slot == MaxSlot + 1)
          /*
           * Special value indicates that this pattern was found to be
           * non-cachable.
--- 322,328 ----
  #ifdef PIXPRIV
      devPriv = (xf86PixPrivPtr)(pix->devPrivates[xf86PixmapIndex].ptr);
  
!     if (devPriv->slot == MaxBigSlot + 1)
          /*
           * Special value indicates that this pattern was found to be
           * non-cachable.
***************
*** 344,350 ****
               * pattern, but can't, and ScreenToScreencopy doesn't have
               * the required support for transparency.
               */
!             devPriv->slot = MaxSlot + 1;
              return 0;
          }
          devPriv->slot = slot;
--- 351,357 ----
               * pattern, but can't, and ScreenToScreencopy doesn't have
               * the required support for transparency.
               */
!             devPriv->slot = MaxBigSlot + 1;
              return 0;
          }
          devPriv->slot = slot;
***************
*** 893,898 ****
--- 900,906 ----
      pci->flags = 0;
      pci->lru = pixmap_cache_clock;
      pci->id = pix->drawable.serialNumber;
+     pci->locked = FALSE;
  
      reducible_status = TILE_UNKNOWN;
  
***************
*** 1303,1305 ****
--- 1311,1483 ----
     return (pix->drawable.width <= MaxWidth &&
         pix->drawable.height <= MaxHeight);
  }
+ 
+ /* Rush extension support */
+ 
+ int testOverlap(pcipix)
+      CacheInfoPtr pcipix;
+ {
+   int slot;
+   CacheInfoPtr pcitest;
+ 
+   for (slot=FirstBigSlot; slot<=MaxBigSlot; slot++) {
+     if (xf86CacheInfo[slot].id>0) {
+       pcitest=&xf86CacheInfo[slot];
+       if (!((pcipix->x+pcipix->w<pcitest->x || 
+ 	   pcipix->x>pcitest->x+pcitest->w) &&
+ 	  (pcipix->y+pcipix->h<pcitest->y || 
+ 	   pcipix->y>pcitest->y+pcitest->w)))
+ 	return 1;
+     }
+   }
+   return 0;
+ }
+      
+ 
+ /*
+   Dividing up the extra memory among X and Glide is difficult.
+   We'll take what we're given and then try to stick up to big_slots
+   pixmaps within it. big_slots should be small to keep this efficient.
+   To fit the pixmap we'll try to put it next to and below each
+   existing pixmap. Then we'll check if it overlaps anything.
+ */
+ static int
+ findPosition(pci, pix)
+      CacheInfoPtr pci;
+      PixmapPtr pix;
+ {
+   int slot, bestx, besty;
+ 
+   bestx=-2;
+   for (slot=FirstBigSlot; slot<=MaxBigSlot; slot++) {
+     if (xf86CacheInfo[slot].id>0) {
+       if (bestx==-2) bestx==-1;
+       /* Check for fit to right */
+       pci->x=xf86CacheInfo[slot].x+xf86CacheInfo[slot].w;
+       pci->y=xf86CacheInfo[slot].y;
+       if (bestx<0 || (bestx+besty>pci->x+pci->y)) {
+ 	if (!testOverlap(pci, &xf86CacheInfo[slot])) {
+ 	  bestx=pci->x;
+ 	  besty=pci->y;
+ 	}
+       }
+       /* Check for fit below */
+       pci->x=xf86CacheInfo[slot].x;
+       pci->y=xf86CacheInfo[slot].y+xf86CacheInfo[slot].h;
+       if (bestx<0 || (bestx+besty>pci->x+pci->y)) {
+ 	if (!testOverlap(pci, &xf86CacheInfo[slot])) {
+ 	  bestx=pci->x;
+ 	  besty=pci->y;
+ 	}
+       }
+     }
+   }
+   if (bestx==-2) { /* Nothing in the list yet */
+     bestx=0;
+     besty=cache_start_y+MaxHeight;
+   }
+   if (bestx==-1) { /* Doesn't fit */
+     return 0;
+   }
+   pci->x=bestx;
+   pci->y=besty;
+ }
+ 
+ void *
+ xf86LockPixmap(pix)
+      PixmapPtr pix;
+ {
+   xf86PixPrivPtr devPriv =
+     (xf86PixPrivPtr)(pix->devPrivates[xf86PixmapIndex].ptr);
+   int slot, size;
+   ScrnInfoPtr infoRec;
+   CacheInfoPtr pci;
+ 
+   switch (xf86AccelInfoRec.BitsPerPixel) {
+   case 8:
+     size=1;
+     break;
+   case 16:
+     size=2;
+     break;
+   case 24:
+     size=3;
+     break;
+   case 32:
+     size=4;
+     break;
+   case 1:
+   case 4:
+   default:
+     return 0;
+   }
+   for (slot=FirstBigSlot; slot<MaxBigSlot ; slot++) {
+     if (slot==-1) break;
+   }
+   if (slot==MaxBigSlot) return 0;
+   /* Assign the slot */
+   IncrementCacheLRU(slot);
+   devPriv->slot = slot;
+   /* Fill in the cache entry */
+   pci = &xf86CacheInfo[devPriv->slot];
+   pci->pix_w = pix->drawable.width;
+   pci->pix_h = pix->drawable.height;
+   pci->nx = 1;
+   pci->ny = 1;
+   pci->w = pci->pix_w;
+   pci->h = pci->pix_h;
+   pci->fg_color = 0;
+   pci->bg_color = 0;
+   pci->flags = 0;
+   pci->lru = pixmap_cache_clock;
+   pci->locked = TRUE;
+   /* Assign X & Y position */
+   if (!findPosition(pci, pix)) return 0;
+   pci->id = pix->drawable.serialNumber;
+   xf86AccelInfoRec.ImageWrite(pci->x, pci->y, pci->pix_w, pci->pix_h,
+ 			      pix->devPrivate.ptr, pix->devKind, GXcopy, 
+ 			      0xFFFFFFFF);
+   infoRec=xf86AccelInfoRec.ServerInfoRec;
+   return (void*)(infoRec->physBase +
+ 		 (xf86CacheInfo[slot].x +
+ 		  xf86CacheInfo[slot].y*infoRec->displayWidth) * size);
+ }
+ 
+ void
+ xf86UnlockPixmap(pix)
+      PixmapPtr pix;
+ {
+   xf86PixPrivPtr devPriv =
+     (xf86PixPrivPtr)(pix->devPrivates[xf86PixmapIndex].ptr);
+   if (devPriv->slot<0) return;
+   xf86CacheInfo[devPriv->slot].locked = FALSE;
+   xf86CacheInfo[devPriv->slot].id = -1;
+   devPriv->slot = 0;
+ }
+ 
+ void
+ xf86UnlockAllPixmaps()
+ {
+   int i;
+ 
+   for (i=FirstBigSlot; i<=MaxBigSlot; i++) {
+     if (xf86CacheInfo[i].id>0 && xf86CacheInfo[i].locked) {
+       xf86CacheInfo[i].locked = FALSE;
+       xf86CacheInfo[i].id = -1;
+     }
+   }
+ }
+ 
+ int
+ xf86CacheIsLocked(pix)
+      PixmapPtr pix;
+ {
+   xf86PixPrivPtr devPriv = 
+     (xf86PixPrivPtr)(pix->devPrivates[xf86PixmapIndex].ptr);
+   int slot;
+ 
+   slot=devPriv->slot;
+   if (slot<FirstBigSlot || slot>MaxBigSlot) return 0;
+   return xf86CacheInfo[slot].locked;
+ }
+ 
diff -c -N -r xc.old/programs/Xserver/hw/xfree86/xaa/xf86pcache.h ./hw/xfree86/xaa/xf86pcache.h
*** xc.old/programs/Xserver/hw/xfree86/xaa/xf86pcache.h	Fri Jan 17 22:57:28 1997
--- xc/programs/Xserver/hw/xfree86/xaa/xf86pcache.h	Sun Apr  4 18:13:42 1999
***************
*** 19,24 ****
--- 19,25 ----
      int pattern0;       /* if fixed pattern, pattern 0 register contents */
      int pattern1;       /* if fixed pattern, pattern 1 register contents */
      unsigned int lru;   /* lru counter */
+     Bool locked;
  } CacheInfo, *CacheInfoPtr;
  
  #ifdef PIXPRIV
***************
*** 43,45 ****
--- 44,47 ----
  void xf86InitPixmapCacheSlots();
  
  void xf86InvalidatePixmapCache();
+ 
diff -c -N -r xc.old/programs/Xserver/mi/Imakefile ./mi/Imakefile
*** xc.old/programs/Xserver/mi/Imakefile	Sat May  3 02:50:45 1997
--- xc/programs/Xserver/mi/Imakefile	Sun Apr  4 18:13:42 1999
***************
*** 32,38 ****
   * Make sure XINPUT, XF86VidTune, etc aren't defined for the miinitext.o 
   * used by Xnest, Xvfb 
   */
! EXT_DEFINES = ExtensionDefines -UXINPUT -UXF86VIDMODE -UXFreeXDGA -UXF86MISC
  #else
  EXT_DEFINES = ExtensionDefines
  #endif
--- 32,39 ----
   * Make sure XINPUT, XF86VidTune, etc aren't defined for the miinitext.o 
   * used by Xnest, Xvfb 
   */
! EXT_DEFINES = ExtensionDefines -UXINPUT -UXF86VIDMODE -UXFreeXDGA -UXF86MISC \
! 	-UXFreeXRUSH
  #else
  EXT_DEFINES = ExtensionDefines
  #endif
diff -c -N -r xc.old/programs/Xserver/mi/miinitext.c ./mi/miinitext.c
*** xc.old/programs/Xserver/mi/miinitext.c	Thu May 22 07:00:46 1997
--- xc/programs/Xserver/mi/miinitext.c	Sun Apr  4 18:13:42 1999
***************
*** 155,160 ****
--- 155,163 ----
  #ifdef XFreeXDGA
  extern void XFree86DGAExtensionInit(INITARGS);
  #endif
+ #ifdef XFreeXRUSH
+ extern void XFree86RushExtensionInit(INITARGS);
+ #endif
  #ifdef DPMSExtension
  extern void DPMSExtensionInit(INITARGS);
  #endif
***************
*** 264,269 ****
--- 267,275 ----
  #endif
  #if defined(XFreeXDGA) && !defined(PRINT_ONLY_SERVER)
      XFree86DGAExtensionInit();
+ #endif
+ #if defined(XFreeXRUSH) && !defined(PRINT_ONLY_SERVER)
+     XFree86RushExtensionInit();
  #endif
  #if defined(DPMSExtension) && !defined(PRINT_ONLY_SERVER)
      DPMSExtensionInit();
