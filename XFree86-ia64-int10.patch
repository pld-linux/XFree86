Index: XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/common/xf86Bus.c
===================================================================
RCS file: /cvs/xc/programs/Xserver/hw/xfree86/common/xf86Bus.c,v
retrieving revision 1.56
retrieving revision 1.57
diff -u -r1.56 -r1.57
--- XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/common/xf86Bus.c	2000/12/06 15:35:07	1.56
+++ XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/common/xf86Bus.c	2001/01/06 20:19:06	1.57
@@ -225,12 +225,13 @@
 
     switch (pEnt->busType) {
     case BUS_PCI:
-	return (primaryBus.type == BUS_PCI &&
-		pEnt->pciBusId.bus == primaryBus.id.pci.bus &&
+	return (pEnt->pciBusId.bus == primaryBus.id.pci.bus &&
 		pEnt->pciBusId.device == primaryBus.id.pci.device &&
 		pEnt->pciBusId.func == primaryBus.id.pci.func);
     case BUS_ISA:
-	return ( primaryBus.type == BUS_ISA );
+	return TRUE;
+    case BUS_SBUS:
+	return (pEnt->sbusBusId.fbNum == primaryBus.id.sbus.fbNum);
     default:
 	return FALSE;
     }
@@ -1395,7 +1396,7 @@
  * only deals with exclusive resources.
  */
 void
-RemoveOverlaps(resPtr target, resPtr list, Bool pow2Alignment)
+RemoveOverlaps(resPtr target, resPtr list, Bool pow2Alignment, Bool useEstimated)
 {
     resPtr pRes;
     memType size, newsize, adjust;
@@ -1406,6 +1407,8 @@
 		(target->res_type & ResPhysMask))
 	    && pRes->block_begin <= target->block_end
 	    && pRes->block_end >= target->block_begin) {
+	    /* Possibly ignore estimated resources */
+	    if (!useEstimated && (pRes->res_type & ResEstimated)) continue;
 	    /*
 	     * target should be a larger region than pRes.  If pRes fully
 	     * contains target, don't do anything.
@@ -2973,13 +2976,13 @@
         CheckGenericGA();
     if (primaryBus.type != BUS_NONE) {
 	char *bus;
-	char *loc = xnfcalloc(1,8);
+	char *loc = xnfcalloc(1,9);
 	if (loc == NULL) return;
 
 	switch (primaryBus.type) {
 	case BUS_PCI:
 	    bus = "PCI";
-	    sprintf(loc,"%2.2x:%2.2x:%1.1x",primaryBus.id.pci.bus,
+	    sprintf(loc," %2.2x:%2.2x:%1.1x",primaryBus.id.pci.bus,
 	    primaryBus.id.pci.device,primaryBus.id.pci.func);
 	    break;
 	case BUS_ISA:
@@ -2988,14 +2991,14 @@
 	    break;
 	case BUS_SBUS:
 	    bus = "SBUS";
-	    sprintf(loc,"%2.2x",primaryBus.id.sbus.fbNum);
+	    sprintf(loc," %2.2x",primaryBus.id.sbus.fbNum);
 	    break;
 	default:
 	    bus = "";
 	    loc[0] = '\0';
 	}
 	
-	xf86MsgVerb(X_INFO, 2, "Primary Device is: %s %s\n",bus,loc);
+	xf86MsgVerb(X_INFO, 2, "Primary Device is: %s%s\n",bus,loc);
 	xfree(loc);
     }
     
Index: XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/common/xf86Bus.h
===================================================================
RCS file: /cvs/xc/programs/Xserver/hw/xfree86/common/xf86Bus.h,v
retrieving revision 1.16
retrieving revision 1.17
diff -u -r1.16 -r1.17
--- XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/common/xf86Bus.h	2000/06/20 05:08:43	1.16
+++ XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/common/xf86Bus.h	2001/01/06 20:19:07	1.17
@@ -1,4 +1,4 @@
-/* $XFree86: xc/programs/Xserver/hw/xfree86/common/xf86Bus.h,v 1.16 2000/06/20 05:08:43 dawes Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/common/xf86Bus.h,v 1.17 2001/01/06 20:19:07 tsi Exp $ */
 /*
  * Copyright (c) 1997 by The XFree86 Project, Inc.
  */
@@ -124,7 +124,8 @@
 resPtr xf86ExtractTypeFromList(resPtr list, unsigned long type);
 resPtr findIntersect(resRange Range, resPtr list);
 resPtr xf86FindIntersect(resRange Range, resPtr list);
-void RemoveOverlaps(resPtr target, resPtr list, Bool pow2Alignment);
+void RemoveOverlaps(resPtr target, resPtr list, Bool pow2Alignment,
+		    Bool useEstimated);
 void xf86ConvertListToHost(int entityIndex, resPtr list);
 
 #endif /* _XF86_BUS_H */
Index: XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/common/xf86Config.c
===================================================================
RCS file: /cvs/xc/programs/Xserver/hw/xfree86/common/xf86Config.c,v
retrieving revision 3.236
retrieving revision 3.237
diff -u -r3.236 -r3.237
--- XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/common/xf86Config.c	2000/12/06 15:35:07	3.236
+++ XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/common/xf86Config.c	2001/01/06 20:19:07	3.237
@@ -1,4 +1,4 @@
-/* $XFree86: xc/programs/Xserver/hw/xfree86/common/xf86Config.c,v 3.236 2000/12/06 15:35:07 eich Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/common/xf86Config.c,v 3.237 2001/01/06 20:19:07 tsi Exp $ */
 
 
 /*
@@ -2060,6 +2060,7 @@
 			   X_INFO_STRING " informational,\n"
 	       "         " X_WARNING_STRING " warning, "
 			   X_ERROR_STRING " error, "
+			   X_NOT_IMPLEMENTED_STRING " not implemented, "
 			   X_UNKNOWN_STRING " unknown.\n");
 
     /*
Index: XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/common/xf86Configure.c
===================================================================
RCS file: /cvs/xc/programs/Xserver/hw/xfree86/common/xf86Configure.c,v
retrieving revision 3.49
retrieving revision 3.50
diff -u -r3.49 -r3.50
--- XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/common/xf86Configure.c	2000/12/12 18:23:50	3.49
+++ XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/common/xf86Configure.c	2001/01/06 20:19:07	3.50
@@ -1,4 +1,4 @@
-/* $XFree86: xc/programs/Xserver/hw/xfree86/common/xf86Configure.c,v 3.49 2000/12/12 18:23:50 tsi Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/common/xf86Configure.c,v 3.50 2001/01/06 20:19:07 tsi Exp $ */
 /*
  * Copyright 2000 by Alan Hourihane, Sychdyn, North Wales.
  *
@@ -213,7 +213,7 @@
 #	undef CardName
 
 	if (chipset < 0)
-	    chipset = (pVideo->vendor << 16) || pVideo->chipType;
+	    chipset = (pVideo->vendor << 16) | pVideo->chipType;
 	}
 	break;
     case BUS_ISA:
Index: XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/common/xf86Helper.c
===================================================================
RCS file: /cvs/xc/programs/Xserver/hw/xfree86/common/xf86Helper.c,v
retrieving revision 1.108
retrieving revision 1.109
diff -u -r1.108 -r1.109
--- XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/common/xf86Helper.c	2000/12/14 16:33:08	1.108
+++ XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/common/xf86Helper.c	2001/01/06 20:19:07	1.109
@@ -1,4 +1,4 @@
-/* $XFree86: xc/programs/Xserver/hw/xfree86/common/xf86Helper.c,v 1.108 2000/12/14 16:33:08 eich Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/common/xf86Helper.c,v 1.109 2001/01/06 20:19:07 tsi Exp $ */
 
 /*
  * Copyright (c) 1997-1998 by The XFree86 Project, Inc.
@@ -1217,6 +1217,9 @@
 	    break;
 	case X_INFO:
 	    s = X_INFO_STRING;
+	    break;
+	case X_NOT_IMPLEMENTED:
+	    s = X_NOT_IMPLEMENTED_STRING;
 	    break;
 	case X_NONE:
 	    s = NULL;
Index: XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/common/xf86Mode.c
===================================================================
RCS file: /cvs/xc/programs/Xserver/hw/xfree86/common/xf86Mode.c,v
retrieving revision 1.36
retrieving revision 1.37
diff -u -r1.36 -r1.37
--- XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/common/xf86Mode.c	2000/12/06 15:35:11	1.36
+++ XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/common/xf86Mode.c	2001/01/06 20:19:08	1.37
@@ -1,4 +1,4 @@
-/* $XFree86: xc/programs/Xserver/hw/xfree86/common/xf86Mode.c,v 1.36 2000/12/06 15:35:11 eich Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/common/xf86Mode.c,v 1.37 2001/01/06 20:19:08 tsi Exp $ */
 
 /*
  * Copyright (c) 1997,1998 by The XFree86 Project, Inc.
@@ -1305,16 +1305,16 @@
 	        q->status = MODE_OK;
 	    } else {
 		if (p->type & M_T_BUILTIN)
-		    xf86DrvMsg(scrp->scrnIndex, X_WARNING,
-			       "Built-in mode \"%s\" deleted (%s)\n", p->name,
-			       xf86ModeStatusToString(status));
+		    xf86DrvMsg(scrp->scrnIndex, X_INFO,
+			       "Not using built-in mode \"%s\" (%s)\n",
+			       p->name, xf86ModeStatusToString(status));
 		else if (p->type & M_T_DEFAULT)
-		    xf86DrvMsg(scrp->scrnIndex, X_WARNING,
-			       "Default mode \"%s\" deleted (%s)\n", p->name,
+		    xf86DrvMsg(scrp->scrnIndex, X_INFO,
+			       "Not using default mode \"%s\" (%s)\n", p->name,
 			       xf86ModeStatusToString(status));
 		else
-		    xf86DrvMsg(scrp->scrnIndex, X_WARNING,
-			       "Mode \"%s\" deleted (%s)\n", p->name,
+		    xf86DrvMsg(scrp->scrnIndex, X_INFO,
+			       "Not using mode \"%s\" (%s)\n", p->name,
 			       xf86ModeStatusToString(status));
 	    }
 	}
@@ -1401,16 +1401,16 @@
 	status = xf86LookupMode(scrp, p, clockRanges, strategy);
 	if (status != MODE_OK) {
 		if (p->type & M_T_BUILTIN)
-		    xf86DrvMsg(scrp->scrnIndex, X_WARNING,
-			       "Built-in mode \"%s\" deleted (%s)\n", p->name,
-			       xf86ModeStatusToString(status));
+		    xf86DrvMsg(scrp->scrnIndex, X_INFO,
+			       "Not using built-in mode \"%s\" (%s)\n",
+			       p->name, xf86ModeStatusToString(status));
 		else if (p->type & M_T_DEFAULT)
-		    xf86DrvMsg(scrp->scrnIndex, X_WARNING,
-			       "Default mode \"%s\" deleted (%s)\n", p->name,
+		    xf86DrvMsg(scrp->scrnIndex, X_INFO,
+			       "Not using default mode \"%s\" (%s)\n", p->name,
 			       xf86ModeStatusToString(status));
 		else
-		    xf86DrvMsg(scrp->scrnIndex, X_WARNING,
-			       "Mode \"%s\" deleted (%s)\n", p->name,
+		    xf86DrvMsg(scrp->scrnIndex, X_INFO,
+			       "Not using mode \"%s\" (%s)\n", p->name,
 			       xf86ModeStatusToString(status));
 	}
 	if (status == MODE_ERROR) {
@@ -1493,16 +1493,16 @@
 
 	   if (p->status != MODE_OK) {
 	        if (p->type & M_T_BUILTIN)
-		    xf86DrvMsg(scrp->scrnIndex, X_WARNING,
-			       "Built-in mode \"%s\" deleted (%s)\n", p->name,
-			       xf86ModeStatusToString(p->status));
+		    xf86DrvMsg(scrp->scrnIndex, X_INFO,
+			       "Not using built-in mode \"%s\" (%s)\n",
+			       p->name, xf86ModeStatusToString(p->status));
 		else if (p->type & M_T_DEFAULT)
-		    xf86DrvMsg(scrp->scrnIndex, X_WARNING,
-			       "Default mode \"%s\" deleted (%s)\n", p->name,
+		    xf86DrvMsg(scrp->scrnIndex, X_INFO,
+			       "Not using default mode \"%s\" (%s)\n", p->name,
 			       xf86ModeStatusToString(p->status));
 		else
-		    xf86DrvMsg(scrp->scrnIndex, X_WARNING,
-			       "Mode \"%s\" deleted (%s)\n", p->name,
+		    xf86DrvMsg(scrp->scrnIndex, X_INFO,
+			       "Not using mode \"%s\" (%s)\n", p->name,
 			       xf86ModeStatusToString(p->status));
 
 	        goto lookupNext;
@@ -1607,17 +1607,17 @@
 	if (p->status != MODE_OK) {
 #if 0
 	    if (p->type & M_T_BUILTIN)
-		xf86DrvMsg(scrp->scrnIndex, X_WARNING,
-			   "Built-in mode \"%s\" deleted (%s)\n", p->name,
+		xf86DrvMsg(scrp->scrnIndex, X_INFO,
+			   "Not using built-in mode \"%s\" (%s)\n", p->name,
 			   xf86ModeStatusToString(p->status));
 	    else if (p->type & M_T_DEFAULT)
-		    xf86DrvMsg(scrp->scrnIndex, X_WARNING,
-			       "Default mode \"%s\" deleted (%s)\n", p->name,
-			       xf86ModeStatusToString(p->status));
+		xf86DrvMsg(scrp->scrnIndex, X_INFO,
+			   "Not using default mode \"%s\" (%s)\n", p->name,
+			   xf86ModeStatusToString(p->status));
 	    else
-	      xf86DrvMsg(scrp->scrnIndex, X_WARNING,
-			 "Mode \"%s\" deleted (%s)\n", p->name,
-			 xf86ModeStatusToString(p->status));
+	        xf86DrvMsg(scrp->scrnIndex, X_INFO,
+			   "Not using mode \"%s\" (%s)\n", p->name,
+			   xf86ModeStatusToString(p->status));
 #endif
 	    xf86DeleteMode(&(scrp->modes), p);
 	}
Index: XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/common/xf86Privstr.h
===================================================================
RCS file: /cvs/xc/programs/Xserver/hw/xfree86/common/xf86Privstr.h,v
retrieving revision 1.21
retrieving revision 1.22
diff -u -r1.21 -r1.22
--- XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/common/xf86Privstr.h	2000/11/06 19:24:07	1.21
+++ XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/common/xf86Privstr.h	2001/01/06 20:19:08	1.22
@@ -1,4 +1,4 @@
-/* $XFree86: xc/programs/Xserver/hw/xfree86/common/xf86Privstr.h,v 1.21 2000/11/06 19:24:07 dawes Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/common/xf86Privstr.h,v 1.22 2001/01/06 20:19:08 tsi Exp $ */
 
 /*
  * Copyright (c) 1997,1998 by The XFree86 Project, Inc.
@@ -200,6 +200,9 @@
 #endif
 #ifndef X_INFO_STRING
 #define X_INFO_STRING		"(II)"
+#endif
+#ifndef X_NOT_IMPLEMENTED_STRING
+#define X_NOT_IMPLEMENTED_STRING	"(NI)"
 #endif
 
 #endif /* _XF86PRIVSTR_H */
Index: XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/common/xf86pciBus.c
===================================================================
RCS file: /cvs/xc/programs/Xserver/hw/xfree86/common/xf86pciBus.c,v
retrieving revision 3.28
retrieving revision 3.29
diff -u -r3.28 -r3.29
--- XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/common/xf86pciBus.c	2000/12/08 20:13:35	3.28
+++ XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/common/xf86pciBus.c	2001/01/06 20:19:08	3.29
@@ -175,11 +175,16 @@
 	    if ((PCISHAREDIOCLASSES(baseclass, subclass))
 		&& (pcrp->pci_command & PCI_CMD_IO_ENABLE) &&
 		(pcrp->pci_prog_if == 0)) {
-		/* assumption: primary bus is always VGA */
+		if (primaryBus.type == BUS_NONE) {
+		    /* assumption: primary bus is always VGA */
 	            primaryBus.type = BUS_PCI;
 	            primaryBus.id.pci.bus = pcrp->busnum;
 		    primaryBus.id.pci.device = pcrp->devnum;
 		    primaryBus.id.pci.func = pcrp->funcnum;
+		} else if (primaryBus.type < BUS_last) {
+		    xf86Msg(X_NOTICE, "More than one primary device found\n");
+		    primaryBus.type ^= (BusType)(-1);
+		}
 	    }
 	    
 	    for (j = 0; j < 6; j++) {
@@ -752,7 +757,7 @@
 	}
     }
     
-    RemoveOverlaps(target,bridgeRes,TRUE);
+    RemoveOverlaps(target, bridgeRes, TRUE, TRUE);
     if (range.rEnd > target->block_end) {
 	correctPciSize(range.rBegin,range.rEnd - range.rBegin,
 		       target->block_end - target->block_begin,
@@ -902,9 +907,9 @@
 	    if (ResIsEstimated(&pRes->val)) {
 		range = pRes->val;
 
-		RemoveOverlaps(pRes, *activeRes, TRUE);
-		if (xf86Info.estimateSizesAggressively > 0)
-		    RemoveOverlaps(pRes, *inactiveRes, TRUE);
+		RemoveOverlaps(pRes, *activeRes, TRUE, TRUE);
+		RemoveOverlaps(pRes, *inactiveRes, TRUE, 
+		    (xf86Info.estimateSizesAggressively > 0));
 		
 		if (range.rEnd > pRes->block_end) {
 		    correctPciSize(range.rBegin,range.rEnd - range.rBegin,
@@ -923,14 +928,16 @@
 	xf86PrintResList(3, *activeRes);
     }
 
-    if (*inactiveRes && (xf86Info.estimateSizesAggressively > 1)) {
+    if (*inactiveRes) {
 	/* Check for overlaps */
 	for (pRes = *inactiveRes; pRes; pRes = pRes->next) {
 	    if (ResIsEstimated(&pRes->val)) {
 		range = pRes->val;
 
-		RemoveOverlaps(pRes, *activeRes, TRUE);
-		RemoveOverlaps(pRes, *inactiveRes, TRUE);
+		RemoveOverlaps(pRes, *activeRes, TRUE,
+		    (xf86Info.estimateSizesAggressively > 1));
+		RemoveOverlaps(pRes, *inactiveRes, TRUE,
+		    (xf86Info.estimateSizesAggressively > 1));
 		
 		if (range.rEnd > pRes->block_end) {
 		    correctPciSize(range.rBegin,range.rEnd - range.rBegin,
@@ -946,7 +953,7 @@
 	    }
 	}
 	xf86MsgVerb(X_INFO, 3,
-	    "Ative PCI resource ranges after removing overlaps:\n");
+	    "Active PCI resource ranges after removing overlaps:\n");
 	xf86PrintResList(3, *inactiveRes);
     }
 }
@@ -968,7 +975,7 @@
      */
 
     for (tmp = *osRes; tmp; tmp = tmp->next) 
-	RemoveOverlaps(tmp, activeRes, FALSE);
+	RemoveOverlaps(tmp, activeRes, FALSE, TRUE);
 
     xf86MsgVerb(X_INFO, 3, "OS-reported resource ranges after removing"
 		" overlaps with PCI:\n");
@@ -976,7 +983,7 @@
 
     pciAvoidRes = xf86AddRangesToList(pciAvoidRes,PciAvoid,-1);
     for (tmp = pciAvoidRes; tmp; tmp = tmp->next) 
-	RemoveOverlaps(tmp, activeRes, FALSE);
+	RemoveOverlaps(tmp, activeRes, FALSE, TRUE);
     tmp = xf86DupResList(*osRes);
     pciAvoidRes = xf86JoinResLists(pciAvoidRes,tmp);
     
@@ -1424,40 +1431,54 @@
     if ((*num < 0) || (*num > 5) ||
 	!pvp->memBase[*num] || (pvp->size[*num] < biosSize)) {
 	*num = -1;
+    } else {
+	P_M_RANGE(range, TAG(pvp), pvp->memBase[*num], biosSize,
+	    ResExcMemBlock);
+	if (!xf86IsSubsetOf(range, m) || ChkConflict(&range, avoid, SETUP))
+	    *num = -1;
+    }
+
+    if (*num < 0) {
 	for (n = 0;  n <= 5;  n++) {
 	    if (pvp->memBase[n] && (pvp->size[n] >= biosSize)) {
-		*num = n;
-		break;
+		/* keep bios size ! */
+		P_M_RANGE(range, TAG(pvp), pvp->memBase[*num],
+		    biosSize, ResExcMemBlock);
+		if (xf86IsSubsetOf(range, m) &&
+		    !ChkConflict(&range, avoid, SETUP)) {
+			*num = n;
+			break;
+		}
 	    }
 	}
     }
 
-    if (*num >= 0) {
-	/* then try suggested memBase */
-	/* keep bios size ! */
-	P_M_RANGE(range,TAG(pvp),pvp->memBase[*num],biosSize,ResExcMemBlock);
-	if (xf86IsSubsetOf(range,m) && !ChkConflict(&range,avoid,SETUP)) {
-	    xf86FreeResList(avoid);
-	    xf86FreeResList(m);
-	    return pvp->memBase[*num];
-	}
-    }
+    /*
+     * Return a possible window.  Note that this doesn't deal with host bridges
+     * yet.  But the fix for that belongs elsewhere.
+     */
     while (m) {
 	range = xf86GetBlock(ResExcMemBlock,
-			     PCI_SIZE(ResMem,TAG(pvp),(1 << biosSize)),
+			     PCI_SIZE(ResMem, TAG(pvp), 1 << biosSize),
 			     m->block_begin, m->block_end,
-			     PCI_SIZE(ResMem,TAG(pvp),alignment), avoid);
-	if (range.type != ResEnd)
-	    break;
+			     PCI_SIZE(ResMem, TAG(pvp), alignment), avoid);
+	if (range.type != ResEnd) {
+	    xf86FreeResList(avoid);
+	    xf86FreeResList(m);
+	    return M2B(TAG(pvp), range.rBase);
+	}
 	m = m->next;
     }
-    
+
     xf86FreeResList(avoid);
     xf86FreeResList(m);
-    xf86MsgVerb(X_INFO,5,"GetVaildBIOSBase for %x:%x:%x: BIOSbase 0x%lx\n",
-		pvp->bus,pvp->device,pvp->func, 
-		(memType)M2B(TAG(pvp),range.rBase));
-    return M2B(TAG(pvp),range.rBase);
+
+    if (*num >= 0) {
+	/* then try suggested memBase */
+	return pvp->memBase[*num];
+    }
+    
+    return 0;
 }
 
 /*
Index: XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/common/xf86str.h
===================================================================
RCS file: /cvs/xc/programs/Xserver/hw/xfree86/common/xf86str.h,v
retrieving revision 1.74
retrieving revision 1.75
diff -u -r1.74 -r1.75
--- XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/common/xf86str.h	2000/12/13 02:44:59	1.74
+++ XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/common/xf86str.h	2001/01/06 20:19:08	1.75
@@ -1,4 +1,4 @@
-/* $XFree86: xc/programs/Xserver/hw/xfree86/common/xf86str.h,v 1.74 2000/12/13 02:44:59 tsi Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/common/xf86str.h,v 1.75 2001/01/06 20:19:08 tsi Exp $ */
 
 /*
  * Copyright (c) 1997-2000 by The XFree86 Project, Inc.
@@ -233,7 +233,8 @@
     BUS_NONE,
     BUS_ISA,
     BUS_PCI,
-    BUS_SBUS
+    BUS_SBUS,
+    BUS_last    /* Keep last */
 } BusType;
 
 typedef struct {
@@ -438,7 +439,8 @@
     X_ERROR,			/* Error message */
     X_WARNING,			/* Warning message */
     X_INFO,			/* Informational message */
-    X_NONE			/* No prefix */
+    X_NONE,			/* No prefix */
+    X_NOT_IMPLEMENTED		/* Not implemented */
 } MessageType;
 
 /* flags for depth 24 pixmap options */
Index: XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/drivers/ati/atioption.c
===================================================================
RCS file: /cvs/xc/programs/Xserver/hw/xfree86/drivers/ati/atioption.c,v
retrieving revision 1.13
retrieving revision 1.15
diff -u -r1.13 -r1.15
--- XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/drivers/ati/atioption.c	2000/11/02 16:55:28	1.13
+++ XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/drivers/ati/atioption.c	2001/01/06 20:58:06	1.15
@@ -1,6 +1,6 @@
-/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/ati/atioption.c,v 1.13 2000/11/02 16:55:28 tsi Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/ati/atioption.c,v 1.15 2001/01/06 20:58:06 tsi Exp $ */
 /*
- * Copyright 1999 through 2000 by Marc Aurele La France (TSI @ UQV), tsi@ualberta.ca
+ * Copyright 1999 through 2001 by Marc Aurele La France (TSI @ UQV), tsi@xfree86.org
  *
  * Permission to use, copy, modify, distribute, and sell this software and its
  * documentation for any purpose is hereby granted without fee, provided that
@@ -107,8 +107,8 @@
 OptionInfoPtr
 ATIAvailableOptions
 (
-    int ChipId,          /* Ignored */
-    int BusId            /* Ignored */
+    int ChipId,
+    int BusId
 )
 {
     OptionInfoPtr pOptions;
Index: XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/drivers/ati/atiprobe.c
===================================================================
RCS file: /cvs/xc/programs/Xserver/hw/xfree86/drivers/ati/atiprobe.c,v
retrieving revision 1.36
retrieving revision 1.38
diff -u -r1.36 -r1.38
--- XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/drivers/ati/atiprobe.c	2000/12/13 02:44:59	1.36
+++ XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/drivers/ati/atiprobe.c	2001/01/06 20:58:07	1.38
@@ -1,6 +1,6 @@
-/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/ati/atiprobe.c,v 1.36 2000/12/13 02:44:59 tsi Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/ati/atiprobe.c,v 1.38 2001/01/06 20:58:07 tsi Exp $ */
 /*
- * Copyright 1997 through 2000 by Marc Aurele La France (TSI @ UQV), tsi@ualberta.ca
+ * Copyright 1997 through 2001 by Marc Aurele La France (TSI @ UQV), tsi@xfree86.org
  *
  * Permission to use, copy, modify, distribute, and sell this software and its
  * documentation for any purpose is hereby granted without fee, provided that
@@ -2241,6 +2241,7 @@
 
             xf86LoaderReqSymLists(ATISymbols, NULL);
 
+#ifndef ELFDEBUG
             /* Workaround for possible loader bug */
 #           define ATIPreInit     \
                 (xf86PreInitProc*)    LoaderSymbol("ATIPreInit")
@@ -2258,6 +2259,7 @@
                 (xf86FreeScreenProc*) LoaderSymbol("ATIFreeScreen")
 #           define ATIValidMode   \
                 (xf86ValidModeProc*)  LoaderSymbol("ATIValidMode")
+#endif
 
 #endif
 
Index: XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/drivers/ati/atiregs.h
===================================================================
RCS file: /cvs/xc/programs/Xserver/hw/xfree86/drivers/ati/atiregs.h,v
retrieving revision 1.12
retrieving revision 1.14
diff -u -r1.12 -r1.14
--- XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/drivers/ati/atiregs.h	2000/08/22 21:54:31	1.12
+++ XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/drivers/ati/atiregs.h	2001/01/06 20:58:07	1.14
@@ -1,6 +1,6 @@
-/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/ati/atiregs.h,v 1.12 2000/08/22 21:54:31 tsi Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/ati/atiregs.h,v 1.14 2001/01/06 20:58:07 tsi Exp $ */
 /*
- * Copyright 1994 through 2000 by Marc Aurele La France (TSI @ UQV), tsi@ualberta.ca
+ * Copyright 1994 through 2001 by Marc Aurele La France (TSI @ UQV), tsi@xfree86.org
  *
  * Permission to use, copy, modify, distribute, and sell this software and its
  * documentation for any purpose is hereby granted without fee, provided that
@@ -62,7 +62,7 @@
 #define SparseIOTag(_IOSelect)	IOPortTag(_IOSelect, 0)
 #define BlockIOTag(_IOSelect)	IOPortTag(0, _IOSelect)
 
-/* MDA/CGA/EGA/VGA I/O ports */
+/* MDA/[M]CGA/EGA/VGA I/O ports */
 #define GENVS			0x0102u		/* Write (and Read on uC only) */
 
 #define R_GENLPS		0x03b9u		/* Read */
@@ -99,24 +99,24 @@
 #define MonochromeIOBase	0x03b0u
 #define ColourIOBase		0x03d0u
 
-/* Other EGA/CGA/VGA I/O ports */
-/*	?(_IOBase)		(_IOBase + 0x00u) */
-/*	?(_IOBase)		(_IOBase + 0x01u) */
-/*	?(_IOBase)		(_IOBase + 0x02u) */
-/*	?(_IOBase)		(_IOBase + 0x03u) */
-#define CRTX(_IOBase)		(_IOBase + 0x04u)
-#define CRTD(_IOBase)		(_IOBase + 0x05u)
-/*	?(_IOBase)		(_IOBase + 0x06u) */
-/*	?(_IOBase)		(_IOBase + 0x07u) */
-#define GENMC(_IOBase)		(_IOBase + 0x08u)
-/*	?(_IOBase)		(_IOBase + 0x09u) */	/* R_GENLPS/GENB */
-#define GENS1(_IOBase)		(_IOBase + 0x0au)	/* Read */
-#define GENFC(_IOBase)		(_IOBase + 0x0au)	/* Write */
-#define GENLPC(_IOBase)		(_IOBase + 0x0bu)
-/*	?(_IOBase)		(_IOBase + 0x0cu) */	/* /GENLPS */
-/*	?(_IOBase)		(_IOBase + 0x0du) */	/* /KCX */
-/*	?(_IOBase)		(_IOBase + 0x0eu) */	/* /KCD */
-/*	?(_IOBase)		(_IOBase + 0x0fu) */	/* GENHP/ */
+/* Other MDA/[M]CGA/EGA/VGA I/O ports */
+/*	?(_IOBase)		((_IOBase) + 0x00u) */	/* CRTX synonym */
+/*	?(_IOBase)		((_IOBase) + 0x01u) */	/* CRTD synonym */
+/*	?(_IOBase)		((_IOBase) + 0x02u) */	/* CRTX synonym */
+/*	?(_IOBase)		((_IOBase) + 0x03u) */	/* CRTD synonym */
+#define CRTX(_IOBase)		((_IOBase) + 0x04u)
+#define CRTD(_IOBase)		((_IOBase) + 0x05u)
+/*	?(_IOBase)		((_IOBase) + 0x06u) */
+/*	?(_IOBase)		((_IOBase) + 0x07u) */
+#define GENMC(_IOBase)		((_IOBase) + 0x08u)
+/*	?(_IOBase)		((_IOBase) + 0x09u) */	/* R_GENLPS/GENB */
+#define GENS1(_IOBase)		((_IOBase) + 0x0au)	/* Read */
+#define GENFC(_IOBase)		((_IOBase) + 0x0au)	/* Write */
+#define GENLPC(_IOBase)		((_IOBase) + 0x0bu)
+/*	?(_IOBase)		((_IOBase) + 0x0cu) */	/* /GENLPS */
+/*	?(_IOBase)		((_IOBase) + 0x0du) */	/* /KCX */
+/*	?(_IOBase)		((_IOBase) + 0x0eu) */	/* /KCD */
+/*	?(_IOBase)		((_IOBase) + 0x0fu) */	/* GENHP/ */
 
 /* 8514/A VESA approved register definitions */
 #define DISP_STAT		0x02e8u		/* Read */
Index: XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/drivers/ati/r128.h
===================================================================
RCS file: /cvs/xc/programs/Xserver/hw/xfree86/drivers/ati/r128.h,v
retrieving revision 1.8
retrieving revision 1.9
diff -u -r1.8 -r1.9
--- XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/drivers/ati/r128.h	2000/12/08 19:15:33	1.8
+++ XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/drivers/ati/r128.h	2001/01/06 20:19:10	1.9
@@ -1,4 +1,4 @@
-/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/ati/r128.h,v 1.8 2000/12/08 19:15:33 martin Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/ati/r128.h,v 1.9 2001/01/06 20:19:10 tsi Exp $ */
 /*
  * Copyright 1999, 2000 ATI Technologies Inc., Markham, Ontario,
  *                      Precision Insight, Inc., Cedar Park, Texas, and
@@ -193,7 +193,6 @@
     unsigned long     LinearAddr;   /* Frame buffer physical address         */
     unsigned long     MMIOAddr;     /* MMIO region physical address          */
     unsigned long     BIOSAddr;     /* BIOS physical address                 */
-    Bool              BIOSFromPCI;  /* BIOS is read from PCI space           */
 
     unsigned char     *MMIO;        /* Map of MMIO region                    */
     unsigned char     *FB;          /* Map of frame buffer                   */
Index: XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/drivers/ati/r128_driver.c
===================================================================
RCS file: /cvs/xc/programs/Xserver/hw/xfree86/drivers/ati/r128_driver.c,v
retrieving revision 1.15
retrieving revision 1.16
diff -u -r1.15 -r1.16
--- XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/drivers/ati/r128_driver.c	2000/12/22 12:13:15	1.15
+++ XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/drivers/ati/r128_driver.c	2001/01/06 20:19:10	1.16
@@ -503,17 +503,12 @@
 }
 
 /* Read the Video BIOS block and the FP registers (if applicable). */
-static Bool R128GetBIOSParameters(ScrnInfoPtr pScrn)
+static Bool R128GetBIOSParameters(ScrnInfoPtr pScrn, xf86Int10InfoPtr pInt10)
 {
     R128InfoPtr info = R128PTR(pScrn);
     int         i;
     int         FPHeader = 0;
 
-#define R128ReadBIOS(offset, buffer, length)                            \
-     (info->BIOSFromPCI ?                                               \
-      xf86ReadPciBIOS(offset, info->PciTag, 0, buffer, length) :        \
-      xf86ReadBIOS(info->BIOSAddr, offset, buffer, length))
-
 #define R128_BIOS8(v)  (info->VBIOS[v])
 #define R128_BIOS16(v) (info->VBIOS[v] | \
 			(info->VBIOS[(v) + 1] << 8))
@@ -528,16 +523,20 @@
 	return FALSE;
     }
 
-    info->BIOSFromPCI = TRUE;
-    R128ReadBIOS(0x0000, info->VBIOS, R128_VBIOS_SIZE);
-    if (info->VBIOS[0] != 0x55 || info->VBIOS[1] != 0xaa) {
-	xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
-		   "Video BIOS not detected in PCI space!\n");
-	xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
-		   "Attempting to read Video BIOS from legacy ISA space!\n");
-	info->BIOSFromPCI = FALSE;
-	info->BIOSAddr = 0x000c0000;
-	R128ReadBIOS(0x0000, info->VBIOS, R128_VBIOS_SIZE);
+    if (pInt10) {
+	info->BIOSAddr = pInt10->BIOSseg << 4;
+	(void)memcpy(info->VBIOS, xf86int10Addr(pInt10, info->BIOSAddr),
+		     R128_VBIOS_SIZE);
+    } else {
+	xf86ReadPciBIOS(0, info->PciTag, 0, info->VBIOS, R128_VBIOS_SIZE);
+	if (info->VBIOS[0] != 0x55 || info->VBIOS[1] != 0xaa) {
+	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
+		       "Video BIOS not detected in PCI space!\n");
+	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
+		       "Attempting to read Video BIOS from legacy ISA space!\n");
+	    info->BIOSAddr = 0x000c0000;
+	    xf86ReadBIOS(info->BIOSAddr, 0, info->VBIOS, R128_VBIOS_SIZE);
+	}
     }
     if (info->VBIOS[0] != 0x55 || info->VBIOS[1] != 0xaa) {
 	info->BIOSAddr = 0x00000000;
@@ -1010,7 +1009,7 @@
     return TRUE;
 }
 
-static Bool R128PreInitDDC(ScrnInfoPtr pScrn)
+static Bool R128PreInitDDC(ScrnInfoPtr pScrn, xf86Int10InfoPtr pInt10)
 {
     R128InfoPtr   info = R128PTR(pScrn);
     vbeInfoPtr pVbe;
@@ -1026,7 +1025,7 @@
 #ifdef XFree86LOADER
 	xf86LoaderReqSymLists(vbeSymbols,NULL);
 #endif
-	pVbe = VBEInit(NULL,info->pEnt->index);
+	pVbe = VBEInit(pInt10, info->pEnt->index);
 	if (!pVbe) return FALSE;
 
 	xf86SetDDCproperties(pScrn,xf86PrintEDID(vbeDoEDID(pVbe,NULL)));
@@ -1155,15 +1154,13 @@
     return TRUE;
 }
 
-static Bool R128PreInitInt10(ScrnInfoPtr pScrn)
+static Bool R128PreInitInt10(ScrnInfoPtr pScrn, xf86Int10InfoPtr *ppInt10)
 {
     R128InfoPtr   info = R128PTR(pScrn);
 #if 1
     if (xf86LoadSubModule(pScrn, "int10")) {
-	xf86Int10InfoPtr pInt;
 	xf86DrvMsg(pScrn->scrnIndex,X_INFO,"initializing int10\n");
-	pInt = xf86InitInt10(info->pEnt->index);
-	xf86FreeInt10(pInt);
+	*ppInt10 = xf86InitInt10(info->pEnt->index);
     }
 #endif
     return TRUE;
@@ -1296,7 +1293,8 @@
 /* R128PreInit is called once at server startup. */
 Bool R128PreInit(ScrnInfoPtr pScrn, int flags)
 {
-    R128InfoPtr   info;
+    R128InfoPtr      info;
+    xf86Int10InfoPtr pInt10 = NULL;
 
     R128TRACE(("R128PreInit\n"));
 
@@ -1403,26 +1401,26 @@
     }
 
     if (!info->FBDev)
-	if (!R128PreInitInt10(pScrn))  goto fail;
+	if (!R128PreInitInt10(pScrn, &pInt10))  goto fail;
 
-    if (!R128PreInitConfig(pScrn))     goto fail;
+    if (!R128PreInitConfig(pScrn))              goto fail;
 
-    if (!R128GetBIOSParameters(pScrn)) goto fail;
+    if (!R128GetBIOSParameters(pScrn, pInt10))  goto fail;
 
-    if (!R128GetPLLParameters(pScrn))  goto fail;
+    if (!R128GetPLLParameters(pScrn))           goto fail;
 
-    if (!R128PreInitDDC(pScrn))        goto fail;
+    if (!R128PreInitDDC(pScrn, pInt10))         goto fail;
 
-    if (!R128PreInitGamma(pScrn))      goto fail;
+    if (!R128PreInitGamma(pScrn))               goto fail;
 
-    if (!R128PreInitModes(pScrn))      goto fail;
+    if (!R128PreInitModes(pScrn))               goto fail;
 
-    if (!R128PreInitCursor(pScrn))     goto fail;
+    if (!R128PreInitCursor(pScrn))              goto fail;
 
-    if (!R128PreInitAccel(pScrn))      goto fail;
+    if (!R128PreInitAccel(pScrn))               goto fail;
 
 #ifdef XF86DRI
-    if (!R128PreInitDRI(pScrn))        goto fail;
+    if (!R128PreInitDRI(pScrn))                 goto fail;
 #endif
 
 				/* Free the video bios (if applicable) */
@@ -1431,6 +1429,10 @@
 	info->VBIOS = NULL;
     }
 
+				/* Free int10 info */
+    if (pInt10)
+	xf86FreeInt10(pInt10);
+
     return TRUE;
 
   fail:
@@ -1441,6 +1443,10 @@
 	xfree(info->VBIOS);
 	info->VBIOS = NULL;
     }
+
+				/* Free int10 info */
+    if (pInt10)
+	xf86FreeInt10(pInt10);
 
     vgaHWFreeHWRec(pScrn);
     R128FreeRec(pScrn);
Index: XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/drivers/ati/r128_probe.c
===================================================================
RCS file: /cvs/xc/programs/Xserver/hw/xfree86/drivers/ati/r128_probe.c,v
retrieving revision 1.6
retrieving revision 1.7
diff -u -r1.6 -r1.7
--- XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/drivers/ati/r128_probe.c	2000/12/13 02:45:00	1.6
+++ XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/drivers/ati/r128_probe.c	2001/01/06 20:19:10	1.7
@@ -1,4 +1,4 @@
-/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/ati/r128_probe.c,v 1.6 2000/12/13 02:45:00 tsi Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/ati/r128_probe.c,v 1.7 2001/01/06 20:19:10 tsi Exp $ */
 /*
  * Copyright 1999, 2000 ATI Technologies Inc., Markham, Ontario,
  *                      Precision Insight, Inc., Cedar Park, Texas, and
@@ -86,6 +86,8 @@
      * Return options defined in the r128 submodule which will have been
      * loaded by this point.
      */
+    if ((chipid >> 16) == PCI_VENDOR_ATI)
+	chipid -= PCI_VENDOR_ATI << 16;
     for (i = 0; R128PciChipsets[i].PCIid > 0; i++) {
 	if (chipid == R128PciChipsets[i].PCIid)
 	    return R128Options;
@@ -159,7 +161,7 @@
 	pEnt = xf86GetEntityInfo(usedChips[i]);
 
 	if (pEnt->active) {
-	    ScrnInfoPtr pScrn    = xf86AllocateScreen(drv, 0);
+	    ScrnInfoPtr pScrn = xf86AllocateScreen(drv, 0);
 
 #ifdef XFree86LOADER
 	    if (!xf86LoadSubModule(pScrn, "r128")) {
@@ -171,6 +173,7 @@
 
 	    xf86LoaderReqSymLists(R128Symbols, NULL);
 
+#ifndef ELFDEBUG
 	    /* Workaround for possible loader bug */
 #	    define R128PreInit     \
 		(xf86PreInitProc*)    LoaderSymbol("R128PreInit")
@@ -188,6 +191,7 @@
 		(xf86FreeScreenProc*) LoaderSymbol("R128FreeScreen")
 #	    define R128ValidMode   \
 		(xf86ValidModeProc*)  LoaderSymbol("R128ValidMode")
+#endif
 
 #endif
 
Index: XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/drivers/ati/radeon.h
===================================================================
RCS file: /cvs/xc/programs/Xserver/hw/xfree86/drivers/ati/radeon.h,v
retrieving revision 1.8
retrieving revision 1.9
diff -u -r1.8 -r1.9
--- XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/drivers/ati/radeon.h	2000/12/08 14:41:16	1.8
+++ XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/drivers/ati/radeon.h	2001/01/06 20:19:10	1.9
@@ -1,4 +1,4 @@
-/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/ati/radeon.h,v 1.8 2000/12/08 14:41:16 alanh Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/ati/radeon.h,v 1.9 2001/01/06 20:19:10 tsi Exp $ */
 /*
  * Copyright 2000 ATI Technologies Inc., Markham, Ontario, and
  *                VA Linux Systems Inc., Fremont, California.
@@ -197,7 +197,6 @@
     unsigned long     LinearAddr; /* Frame buffer physical address           */
     unsigned long     MMIOAddr;   /* MMIO region physical address            */
     unsigned long     BIOSAddr;   /* BIOS physical address                   */
-    Bool              BIOSFromPCI; /* BIOS is read from PCI space            */
 
     unsigned char     *MMIO;      /* Map of MMIO region                      */
     unsigned char     *FB;        /* Map of frame buffer                     */
Index: XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/drivers/ati/radeon_driver.c
===================================================================
RCS file: /cvs/xc/programs/Xserver/hw/xfree86/drivers/ati/radeon_driver.c,v
retrieving revision 1.9
retrieving revision 1.10
diff -u -r1.9 -r1.10
--- XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/drivers/ati/radeon_driver.c	2000/12/22 12:13:15	1.9
+++ XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/drivers/ati/radeon_driver.c	2001/01/06 20:19:10	1.10
@@ -496,7 +496,7 @@
 }
 
 /* Read the Video BIOS block and the FP registers (if applicable). */
-static Bool RADEONGetBIOSParameters(ScrnInfoPtr pScrn)
+static Bool RADEONGetBIOSParameters(ScrnInfoPtr pScrn, xf86Int10InfoPtr pInt10)
 {
     RADEONInfoPtr info     = RADEONPTR(pScrn);
 #ifdef ENABLE_FLAT_PANEL
@@ -523,16 +523,20 @@
 	return FALSE;
     }
 
-    info->BIOSFromPCI = TRUE;
-    RADEONReadBIOS(0x0000, info->VBIOS, RADEON_VBIOS_SIZE);
-    if (info->VBIOS[0] != 0x55 || info->VBIOS[1] != 0xaa) {
-	xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
-		   "Video BIOS not detected in PCI space!\n");
-	xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
-		   "Attempting to read Video BIOS from legacy ISA space!\n");
-	info->BIOSFromPCI = FALSE;
-	info->BIOSAddr = 0x000c0000;
-	RADEONReadBIOS(0x0000, info->VBIOS, RADEON_VBIOS_SIZE);
+    if (pInt10) {
+	info->BIOSAddr = pInt10->BIOSseg << 4;
+	(void)memcpy(info->VBIOS, xf86int10Addr(pInt10, info->BIOSAddr),
+		     RADEON_VBIOS_SIZE);
+    } else {
+	xf86ReadPciBIOS(0, info->PciTag, 0, info->VBIOS, RADEON_VBIOS_SIZE);
+	if (info->VBIOS[0] != 0x55 || info->VBIOS[1] != 0xaa) {
+	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
+		       "Video BIOS not detected in PCI space!\n");
+	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
+		       "Attempting to read Video BIOS from legacy ISA space!\n");
+	    info->BIOSAddr = 0x000c0000;
+	    xf86ReadBIOS(info->BIOSAddr, 0, info->VBIOS, RADEON_VBIOS_SIZE);
+	}
     }
     if (info->VBIOS[0] != 0x55 || info->VBIOS[1] != 0xaa) {
 	info->BIOSAddr = 0x00000000;
@@ -953,7 +957,7 @@
     return TRUE;
 }
 
-static Bool RADEONPreInitDDC(ScrnInfoPtr pScrn)
+static Bool RADEONPreInitDDC(ScrnInfoPtr pScrn, xf86Int10InfoPtr pInt10)
 {
     RADEONInfoPtr info = RADEONPTR(pScrn);
     vbeInfoPtr pVbe;
@@ -961,7 +965,7 @@
     if (!xf86LoadSubModule(pScrn, "ddc")) return FALSE;
     xf86LoaderReqSymLists(ddcSymbols, NULL);
     if (xf86LoadSubModule(pScrn, "vbe")) {
-	pVbe = VBEInit(NULL,info->pEnt->index);
+	pVbe = VBEInit(pInt10, info->pEnt->index);
 	if (!pVbe) return FALSE;
 
 	xf86SetDDCproperties(pScrn,xf86PrintEDID(vbeDoEDID(pVbe,NULL)));
@@ -1088,15 +1092,13 @@
     return TRUE;
 }
 
-static Bool RADEONPreInitInt10(ScrnInfoPtr pScrn)
+static Bool RADEONPreInitInt10(ScrnInfoPtr pScrn, xf86Int10InfoPtr *ppInt10)
 {
     RADEONInfoPtr   info = RADEONPTR(pScrn);
 #if 1
     if (xf86LoadSubModule(pScrn, "int10")) {
-	xf86Int10InfoPtr pInt;
 	xf86DrvMsg(pScrn->scrnIndex,X_INFO,"initializing int10\n");
-	pInt = xf86InitInt10(info->pEnt->index);
-	xf86FreeInt10(pInt);
+	*ppInt10 = xf86InitInt10(info->pEnt->index);
     }
 #endif
     return TRUE;
@@ -1237,7 +1239,8 @@
 /* RADEONPreInit is called once at server startup. */
 Bool RADEONPreInit(ScrnInfoPtr pScrn, int flags)
 {
-    RADEONInfoPtr   info;
+    RADEONInfoPtr    info;
+    xf86Int10InfoPtr pInt10 = NULL;
 
 #ifdef XFree86LOADER
     /*
@@ -1331,26 +1334,26 @@
     }
 
     if (!info->FBDev)
-	if (!RADEONPreInitInt10(pScrn))  goto fail;
+	if (!RADEONPreInitInt10(pScrn, &pInt10)) goto fail;
 
-    if (!RADEONPreInitConfig(pScrn))     goto fail;
+    if (!RADEONPreInitConfig(pScrn))             goto fail;
 
-    if (!RADEONGetBIOSParameters(pScrn)) goto fail;
+    if (!RADEONGetBIOSParameters(pScrn, pInt10)) goto fail;
 
-    if (!RADEONGetPLLParameters(pScrn))  goto fail;
+    if (!RADEONGetPLLParameters(pScrn))          goto fail;
 
-    if (!RADEONPreInitDDC(pScrn))        goto fail;
+    if (!RADEONPreInitDDC(pScrn, pInt10))        goto fail;
 
-    if (!RADEONPreInitGamma(pScrn))      goto fail;
+    if (!RADEONPreInitGamma(pScrn))              goto fail;
 
-    if (!RADEONPreInitModes(pScrn))      goto fail;
+    if (!RADEONPreInitModes(pScrn))              goto fail;
 
-    if (!RADEONPreInitCursor(pScrn))     goto fail;
+    if (!RADEONPreInitCursor(pScrn))             goto fail;
 
-    if (!RADEONPreInitAccel(pScrn))      goto fail;
+    if (!RADEONPreInitAccel(pScrn))              goto fail;
 
 #ifdef XF86DRI
-    if (!RADEONPreInitDRI(pScrn))        goto fail;
+    if (!RADEONPreInitDRI(pScrn))                goto fail;
 #endif
 
 				/* Free the video bios (if applicable) */
@@ -1359,6 +1362,10 @@
 	info->VBIOS = NULL;
     }
 
+				/* Free int10 info */
+    if (pInt10)
+	xf86FreeInt10(pInt10);
+
     return TRUE;
 
   fail:
@@ -1369,6 +1376,10 @@
 	xfree(info->VBIOS);
 	info->VBIOS = NULL;
     }
+
+				/* Free int10 info */
+    if (pInt10)
+	xf86FreeInt10(pInt10);
 
     vgaHWFreeHWRec(pScrn);
     RADEONFreeRec(pScrn);
Index: XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/drivers/ati/radeon_misc.c
===================================================================
RCS file: /cvs/xc/programs/Xserver/hw/xfree86/drivers/ati/radeon_misc.c,v
retrieving revision 1.2
retrieving revision 1.3
diff -u -r1.2 -r1.3
--- XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/drivers/ati/radeon_misc.c	2000/11/18 19:37:12	1.2
+++ XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/drivers/ati/radeon_misc.c	2001/01/06 20:58:08	1.3
@@ -1,6 +1,6 @@
-/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/ati/radeon_misc.c,v 1.2 2000/11/18 19:37:12 tsi Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/ati/radeon_misc.c,v 1.3 2001/01/06 20:58:08 tsi Exp $ */
 /*
- * Copyright 2000 by Marc Aurele La France (TSI @ UQV), tsi@ualberta.ca
+ * Copyright 2000 through 2001 by Marc Aurele La France (TSI @ UQV), tsi@xfree86.org
  *
  * Permission to use, copy, modify, distribute, and sell this software and its
  * documentation for any purpose is hereby granted without fee, provided that
Index: XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/drivers/ati/radeon_probe.c
===================================================================
RCS file: /cvs/xc/programs/Xserver/hw/xfree86/drivers/ati/radeon_probe.c,v
retrieving revision 1.5
retrieving revision 1.6
diff -u -r1.5 -r1.6
--- XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/drivers/ati/radeon_probe.c	2000/12/13 02:45:00	1.5
+++ XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/drivers/ati/radeon_probe.c	2001/01/06 20:19:11	1.6
@@ -1,4 +1,4 @@
-/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/ati/radeon_probe.c,v 1.5 2000/12/13 02:45:00 tsi Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/ati/radeon_probe.c,v 1.6 2001/01/06 20:19:11 tsi Exp $ */
 /*
  * Copyright 2000 ATI Technologies Inc., Markham, Ontario, and
  *                VA Linux Systems Inc., Fremont, California.
@@ -73,6 +73,8 @@
      * Return options defined in the radeon submodule which will have been
      * loaded by this point.
      */
+    if ((chipid >> 16) == PCI_VENDOR_ATI)
+	chipid -= PCI_VENDOR_ATI << 16;
     for (i = 0; RADEONPciChipsets[i].PCIid > 0; i++) {
 	if (chipid == RADEONPciChipsets[i].PCIid)
 	    return RADEONOptions;
@@ -146,7 +148,7 @@
 	pEnt = xf86GetEntityInfo(usedChips[i]);
 
 	if (pEnt->active) {
-	    ScrnInfoPtr pScrn    = xf86AllocateScreen(drv, 0);
+	    ScrnInfoPtr pScrn = xf86AllocateScreen(drv, 0);
 
 #ifdef XFree86LOADER
 	    if (!xf86LoadSubModule(pScrn, "radeon")) {
@@ -158,6 +160,7 @@
 
 	    xf86LoaderReqSymLists(RADEONSymbols, NULL);
 
+#ifndef ELFDEBUG
 	    /* Workaround for possible loader bug */
 #	    define RADEONPreInit     \
 		(xf86PreInitProc*)    LoaderSymbol("RADEONPreInit")
@@ -175,6 +178,7 @@
 		(xf86FreeScreenProc*) LoaderSymbol("RADEONFreeScreen")
 #	    define RADEONValidMode   \
 		(xf86ValidModeProc*)  LoaderSymbol("RADEONValidMode")
+#endif
 
 #endif
 
Index: XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/etc/pcitweak.c
===================================================================
RCS file: /cvs/xc/programs/Xserver/hw/xfree86/etc/pcitweak.c,v
retrieving revision 1.14
retrieving revision 1.15
diff -u -r1.14 -r1.15
--- XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/etc/pcitweak.c	2000/08/10 17:40:34	1.14
+++ XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/etc/pcitweak.c	2001/01/06 20:19:12	1.15
@@ -5,7 +5,7 @@
  *
  * Author: David Dawes <dawes@xfree86.org>
  */
-/* $XFree86: xc/programs/Xserver/hw/xfree86/etc/pcitweak.c,v 1.14 2000/08/10 17:40:34 dawes Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/etc/pcitweak.c,v 1.15 2001/01/06 20:19:12 tsi Exp $ */
 
 #include "X.h"
 #include "os.h"
@@ -31,6 +31,8 @@
 extern char *optarg;
 extern int optind, opterr;
 #endif
+
+pciVideoPtr *xf86PciVideoInfo = NULL;
 
 static void usage(void);
 static Bool parsePciBusString(const char *id, int *bus, int *device, int *func);
Index: XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/etc/scanpci.c
===================================================================
RCS file: /cvs/xc/programs/Xserver/hw/xfree86/etc/scanpci.c,v
retrieving revision 3.80
retrieving revision 3.81
diff -u -r3.80 -r3.81
--- XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/etc/scanpci.c	2000/06/20 19:38:04	3.80
+++ XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/etc/scanpci.c	2001/01/06 20:19:12	3.81
@@ -21,7 +21,7 @@
  * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  *
  */
-/* $XFree86: xc/programs/Xserver/hw/xfree86/etc/scanpci.c,v 3.80 2000/06/20 19:38:04 eich Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/etc/scanpci.c,v 3.81 2001/01/06 20:19:12 tsi Exp $ */
 
 #include "X.h"
 #include "os.h"
@@ -47,6 +47,8 @@
 extern char *optarg;
 extern int optind, opterr;
 #endif
+
+pciVideoPtr *xf86PciVideoInfo = NULL;
 
 void usage(void);
 void identify_card(pciConfigPtr pcr, int verbose);
Index: XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/int10/generic.c
===================================================================
RCS file: /cvs/xc/programs/Xserver/hw/xfree86/int10/generic.c,v
retrieving revision 1.13
retrieving revision 1.14
diff -u -r1.13 -r1.14
--- XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/int10/generic.c	2000/11/21 23:10:38	1.13
+++ XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/int10/generic.c	2001/01/06 20:19:13	1.14
@@ -1,11 +1,10 @@
-/* $XFree86: xc/programs/Xserver/hw/xfree86/int10/generic.c,v 1.13 2000/11/21 23:10:38 tsi Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/int10/generic.c,v 1.14 2001/01/06 20:19:13 tsi Exp $ */
 /*
  *                   XFree86 int10 module
  *   execute BIOS int 10h calls in x86 real mode environment
  *                 Copyright 1999 Egbert Eich
  */
 #include "xf86.h"
-#include "xf86str.h"
 #include "xf86_OSproc.h"
 #include "xf86_ansic.h"
 #include "xf86Pci.h"
@@ -61,20 +60,19 @@
     void* base = 0;
     void* vbiosMem = 0;
     legacyVGARec vga;
-    
+
     screen = (xf86FindScreenForEntity(entityIndex))->scrnIndex;
-    
+
     if (int10skip(xf86Screens[screen],entityIndex))
 	return NULL;
 
-    pInt = (xf86Int10InfoPtr)xnfcalloc(1,sizeof(xf86Int10InfoRec));
+    pInt = (xf86Int10InfoPtr)xnfcalloc(1, sizeof(xf86Int10InfoRec));
     pInt->entityIndex = entityIndex;
     if (!xf86Int10ExecSetup(pInt))
 	goto error0;
     pInt->mem = &genericMem;
-    pInt->private = (pointer)xnfcalloc(1,sizeof(genericInt10Priv));
-    INTPriv(pInt)->alloc = 
-	(pointer)xnfcalloc(1,ALLOC_ENTRIES(getpagesize()));
+    pInt->private = (pointer)xnfcalloc(1, sizeof(genericInt10Priv));
+    INTPriv(pInt)->alloc = (pointer)xnfcalloc(1, ALLOC_ENTRIES(getpagesize()));
     pInt->scrnIndex = screen;
     base = INTPriv(pInt)->base = xnfalloc(SYS_BIOS);
 
@@ -85,11 +83,11 @@
     MapVRam(pInt);
 #ifdef _PC
     if (!sysMem)
-	sysMem = xf86MapVidMem(screen,VIDMEM_FRAMEBUFFER,SYS_BIOS,BIOS_SIZE);
+	sysMem = xf86MapVidMem(screen, VIDMEM_FRAMEBUFFER, SYS_BIOS, BIOS_SIZE);
     INTPriv(pInt)->sysMem = sysMem;
-    
-    if (xf86ReadBIOS(0,0,(unsigned char *)base,LOW_PAGE_SIZE) < 0) {
-	xf86DrvMsg(screen,X_ERROR,"Cannot read int vect\n");
+
+    if (xf86ReadBIOS(0, 0, base, LOW_PAGE_SIZE) < 0) {
+	xf86DrvMsg(screen, X_ERROR, "Cannot read int vect\n");
 	goto error1;
     }
 
@@ -106,74 +104,79 @@
 		"Unable to retrieve all of segment 0x%06X.\n", cs);
 
     if (xf86IsEntityPrimary(entityIndex)) {
-	cs = MEM_RW(pInt,((0x10<<2)+2));
+	cs = MEM_RW(pInt, (0x10 << 2) + 2);
 
 	vbiosMem = (unsigned char *)base + (cs << 4);
 	if (!int10_check_bios(screen, cs, vbiosMem)) {
-	    cs = MEM_RW(pInt,((0x42<<2)+2));
+	    cs = MEM_RW(pInt, (0x42 << 2) + 2);
 	    vbiosMem = (unsigned char *)base + (cs << 4);
 	    if (!int10_check_bios(screen, cs, vbiosMem)) {
 		cs = V_BIOS >> 4;
 		vbiosMem = (unsigned char *)base + (cs << 4);
 		if (!int10_check_bios(screen, cs, vbiosMem)) {
-		    xf86DrvMsg(screen,X_ERROR,"No V_BIOS found\n");
+		    xf86DrvMsg(screen, X_ERROR, "No V_BIOS found\n");
 		    goto error1;
 		}
 	    }
 	}
-	xf86DrvMsg(screen,X_INFO,"Primary V_BIOS segment is: 0x%x\n",cs);
-	
+	xf86DrvMsg(screen, X_INFO, "Primary V_BIOS segment is: 0x%x\n", cs);
+
 	set_return_trap(pInt);
 	pInt->BIOSseg = cs;
     } else {
-        reset_int_vect(pInt);
+	reset_int_vect(pInt);
 	set_return_trap(pInt);
 	vbiosMem = (unsigned char *)base + V_BIOS;
-	if (!mapPciRom(pInt,(unsigned char *)(vbiosMem))) {
-	    xf86DrvMsg(screen,X_ERROR,"Cannot read V_BIOS (3)\n");
+	if (!mapPciRom(pInt, vbiosMem)) {
+	    xf86DrvMsg(screen, X_ERROR, "Cannot read V_BIOS (3)\n");
 	    goto error1;
 	}
 	pInt->BIOSseg = V_BIOS >> 4;
 	pInt->num = 0xe6;
-	LockLegacyVGA(screen, &vga); 
+	LockLegacyVGA(screen, &vga);
 	xf86ExecX86int10(pInt);
 	UnlockLegacyVGA(screen, &vga);
     }
 #else
     if (!sysMem) {
 	sysMem = xnfalloc(BIOS_SIZE);
-	setup_system_bios((memType)sysMem);
+	setup_system_bios(sysMem);
     }
     INTPriv(pInt)->sysMem = sysMem;
     setup_int_vect(pInt);
     set_return_trap(pInt);
-    vbiosMem = (unsigned char *)base + V_BIOS;
-    {
-        EntityInfoPtr pEnt = xf86GetEntityInfo(pInt->entityIndex);
-	switch (pEnt->location.type) {
-	case BUS_PCI:
-	    if (!mapPciRom(pInt,(unsigned char *)(vbiosMem))) {
-	      xf86DrvMsg(screen,X_ERROR,"Cannot read V_BIOS (4)\n");
-	      goto error1;
-	    }
-	    break;
-	case BUS_ISA:  
-	    (void)memset(vbiosMem, 0, V_BIOS_SIZE);
-	    if (xf86ReadBIOS(V_BIOS, 0, vbiosMem, V_BIOS_SIZE) < V_BIOS_SIZE)
-		xf86DrvMsg(screen, X_WARNING,
-		    "Unable to retrieve all of segment 0x0C0000.\n");
-	    if (!int10_check_bios(screen, V_BIOS >> 4, vbiosMem)) {
-	        xf86DrvMsg(screen,X_ERROR,"Cannot read V_BIOS (5)\n");
-		goto error1;
-	    }
-	    break;
-	default:
+
+    /*
+     * Retrieve two segments:  one at V_BIOS, the other 64kB beyond the first.
+     * This'll catch any BIOS that might have been initialised before server
+     * entry.
+     */
+    vbiosMem = (char *)base + V_BIOS;
+    (void)memset(vbiosMem, 0, 2 * V_BIOS_SIZE);
+    if (xf86ReadBIOS(V_BIOS, 0, vbiosMem, V_BIOS_SIZE) < V_BIOS_SIZE)
+	xf86DrvMsg(screen, X_WARNING,
+	    "Unable to retrieve all of segment 0x0C0000.\n");
+    else if (((unsigned char *)vbiosMem)[2] > 0x80)
+    if (xf86ReadBIOS(V_BIOS + V_BIOS_SIZE, 0,
+	    (unsigned char *)vbiosMem + V_BIOS_SIZE, V_BIOS_SIZE) < V_BIOS_SIZE)
+	xf86DrvMsg(screen, X_WARNING,
+	    "Unable to retrieve all of segment 0x0D0000.\n");
+
+    /*
+     * If this adapter is the primary, use its post-init BIOS (if we can find
+     * it).
+     */
+    if (!xf86IsEntityPrimary(entityIndex) ||
+	!int10_check_bios(screen, V_BIOS >> 4, vbiosMem)) {
+	if (!mapPciRom(pInt, vbiosMem)) {
+	    xf86DrvMsg(screen, X_ERROR, "Cannot read V_BIOS (4)\n");
 	    goto error1;
 	}
     }
+
     pInt->BIOSseg = V_BIOS >> 4;
     pInt->num = 0xe6;
-    LockLegacyVGA(screen, &vga);	   
+    LockLegacyVGA(screen, &vga);
     xf86ExecX86int10(pInt);
     UnlockLegacyVGA(screen, &vga);
 #endif
@@ -197,17 +200,17 @@
     int pagesize = getpagesize();
     int size = ((VRAM_SIZE + pagesize - 1)/pagesize) * pagesize;
 
-    INTPriv(pInt)->vRam = xf86MapVidMem(screen,VIDMEM_MMIO,V_RAM,size);
+    INTPriv(pInt)->vRam = xf86MapVidMem(screen, VIDMEM_MMIO, V_RAM, size);
 }
 
-static void 
+static void
 UnmapVRam(xf86Int10InfoPtr pInt)
 {
     int screen = pInt->scrnIndex;
     int pagesize = getpagesize();
     int size = ((VRAM_SIZE + pagesize - 1)/pagesize) * pagesize;
 
-    xf86UnMapVidMem(screen,INTPriv(pInt)->vRam,size);
+    xf86UnMapVidMem(screen, INTPriv(pInt)->vRam, size);
 }
 
 void
@@ -221,7 +224,7 @@
 {
     if (!pInt)
       return;
-    if (Int10Current == pInt) 
+    if (Int10Current == pInt)
 	Int10Current = NULL;
     xfree(INTPriv(pInt)->base);
     UnmapVRam(pInt);
@@ -231,83 +234,79 @@
 }
 
 void *
-xf86Int10AllocPages(xf86Int10InfoPtr pInt,int num, int *off)
+xf86Int10AllocPages(xf86Int10InfoPtr pInt, int num, int *off)
 {
     int pagesize = getpagesize();
     int num_pages = ALLOC_ENTRIES(pagesize);
     int i,j;
 
-    for (i=0;i<num_pages - num;i++) {
+    for (i = 0; i < (num_pages - num); i++) {
 	if (INTPriv(pInt)->alloc[i] == 0) {
-	    for (j=i;j < num + i;j++)
+	    for (j = i; j < (num + i); j++)
 		if (INTPriv(pInt)->alloc[j] != 0)
 		    break;
-	    if (j == num + i)
+	    if (j == (num + i))
 		break;
-	    else
-		i = i + num;
+	    i += num;
 	}
     }
-    if (i == num_pages - num)
+    if (i == (num_pages - num))
 	return NULL;
-    
-    for (j = i; j < i + num; j++)
+
+    for (j = i; j < (i + num); j++)
 	INTPriv(pInt)->alloc[j] = 1;
 
     *off = (i + 1) * pagesize;
-    
-    return (void *)
-	((char*)INTPriv(pInt)->base + (i + 1) * pagesize);
+
+    return (char *)INTPriv(pInt)->base + *off;
 }
 
 void
 xf86Int10FreePages(xf86Int10InfoPtr pInt, void *pbase, int num)
 {
     int pagesize = getpagesize();
-    int first = ((unsigned long)pbase
-		 - (unsigned long)INTPriv(pInt)->base)
-	/ pagesize - 1;
+    int first = (((char *)pbase - (char *)INTPriv(pInt)->base) / pagesize) - 1;
     int i;
 
-    for (i = first; i < first + num; i++)
+    for (i = first; i < (first + num); i++)
 	INTPriv(pInt)->alloc[i] = 0;
 }
 
 #define OFF(addr) ((addr) & 0xffff)
 #define SYS(addr) ((addr) >= SYS_BIOS)
 #define V_ADDR(addr) \
-          (SYS(addr) ? ((char*)INTPriv(pInt)->sysMem) + (addr - SYS_BIOS) \
-           : ((char*)(INTPriv(pInt)->base) + addr))
+	  (SYS(addr) ? ((char*)INTPriv(pInt)->sysMem) + (addr - SYS_BIOS) \
+	   : ((char*)(INTPriv(pInt)->base) + addr))
 #define VRAM_ADDR(addr) (addr - V_RAM)
 #define VRAM_BASE (INTPriv(pInt)->vRam)
 
 #define VRAM(addr) ((addr >= V_RAM) && (addr < (V_RAM + VRAM_SIZE)))
 #define V_ADDR_RB(addr) \
-        (VRAM(addr)) ? MMIO_IN8((CARD8*)VRAM_BASE,VRAM_ADDR(addr)) \
-           : *(CARD8*) V_ADDR(addr)
+	(VRAM(addr)) ? MMIO_IN8((CARD8*)VRAM_BASE,VRAM_ADDR(addr)) \
+	   : *(CARD8*) V_ADDR(addr)
 #define V_ADDR_RW(addr) \
-        (VRAM(addr)) ? MMIO_IN16((CARD16*)VRAM_BASE,VRAM_ADDR(addr)) \
-           : ldw_u((pointer)V_ADDR(addr))
+	(VRAM(addr)) ? MMIO_IN16((CARD16*)VRAM_BASE,VRAM_ADDR(addr)) \
+	   : ldw_u((pointer)V_ADDR(addr))
 #define V_ADDR_RL(addr) \
-        (VRAM(addr)) ? MMIO_IN32((CARD32*)VRAM_BASE,VRAM_ADDR(addr)) \
-           : ldl_u((pointer)V_ADDR(addr))
+	(VRAM(addr)) ? MMIO_IN32((CARD32*)VRAM_BASE,VRAM_ADDR(addr)) \
+	   : ldl_u((pointer)V_ADDR(addr))
 
 #define V_ADDR_WB(addr,val) \
-        if(VRAM(addr)) \
-            MMIO_OUT8((CARD8*)VRAM_BASE,VRAM_ADDR(addr),val); \
-        else \
-            *(CARD8*) V_ADDR(addr) = val;
+	if(VRAM(addr)) \
+	    MMIO_OUT8((CARD8*)VRAM_BASE,VRAM_ADDR(addr),val); \
+	else \
+	    *(CARD8*) V_ADDR(addr) = val;
 #define V_ADDR_WW(addr,val) \
-        if(VRAM(addr)) \
-            MMIO_OUT16((CARD16*)VRAM_BASE,VRAM_ADDR(addr),val); \
-        else \
-            stw_u((val),(pointer)(V_ADDR(addr)));
+	if(VRAM(addr)) \
+	    MMIO_OUT16((CARD16*)VRAM_BASE,VRAM_ADDR(addr),val); \
+	else \
+	    stw_u((val),(pointer)(V_ADDR(addr)));
 
 #define V_ADDR_WL(addr,val) \
-        if (VRAM(addr)) \
-            MMIO_OUT32((CARD32*)VRAM_BASE,VRAM_ADDR(addr),val); \
-        else \
-            stl_u(val,(pointer)(V_ADDR(addr)));
+	if (VRAM(addr)) \
+	    MMIO_OUT32((CARD32*)VRAM_BASE,VRAM_ADDR(addr),val); \
+	else \
+	    stl_u(val,(pointer)(V_ADDR(addr)));
 
 static CARD8
 read_b(xf86Int10InfoPtr pInt, int addr)
@@ -318,37 +317,24 @@
 static CARD16
 read_w(xf86Int10InfoPtr pInt, int addr)
 {
-#if X_BYTE_ORDER == X_BIG_ENDIAN
-    return ((V_ADDR_RB(addr))
-	    || ((V_ADDR_RB(addr + 1)) << 8));
-#else
-    if (OFF(addr + 1) > 0) {
+#if X_BYTE_ORDER == X_LITTLE_ENDIAN
+    if (OFF(addr + 1) > 0)
 	return V_ADDR_RW(addr);
-    } else
-	return ((V_ADDR_RB(addr + 1))
-		|| ((V_ADDR_RB(addr)) << 8));
-
 #endif
+    return V_ADDR_RB(addr) | (V_ADDR_RB(addr + 1) << 8);
 }
 
 static CARD32
 read_l(xf86Int10InfoPtr pInt, int addr)
 {
-#if X_BYTE_ORDER == X_BIG_ENDIAN
-    return ((V_ADDR_RB(addr))
-	    || ((V_ADDR_RB(addr + 1)) << 8)
-	    || ((V_ADDR_RB(addr + 2)) << 16)
-	    || ((V_ADDR_RB(addr + 3)) << 24));
-#else
-    if (OFF(addr + 3)  > 2) {
+#if X_BYTE_ORDER == X_LITTLE_ENDIAN
+    if (OFF(addr + 3) > 2)
 	return V_ADDR_RL(addr);
-    } else {
-	return ((V_ADDR_RB(addr + 3))
-		|| ((V_ADDR_RB(addr + 2)) << 8)
-		|| ((V_ADDR_RB(addr + 1)) << 16)
-		|| ((V_ADDR_RB(addr)) << 24));
-    }
 #endif
+    return V_ADDR_RB(addr) |
+	   (V_ADDR_RB(addr + 1) << 8) |
+	   (V_ADDR_RB(addr + 2) << 16) |
+	   (V_ADDR_RB(addr + 3) << 24);
 }
 
 static void
@@ -360,49 +346,29 @@
 static void
 write_w(xf86Int10InfoPtr pInt, int addr, CARD16 val)
 {
-#if X_BYTE_ORDER == X_BIG_ENDIAN
-    V_ADDR_WB(addr,val);
-    V_ADDR_WB(addr + 1,val >> 8);
-#else
-    if (OFF(addr + 1) > 0) {
-	V_ADDR_WW(addr,val);
-    } else {
-	V_ADDR_WB(addr + 1,val);
-	V_ADDR_WB(addr,val >> 8);
-    }
+#if X_BYTE_ORDER == X_LITTLE_ENDIAN
+    if (OFF(addr + 1) > 0)
+	V_ADDR_WW(addr, val);
 #endif
+    V_ADDR_WB(addr, val);
+    V_ADDR_WB(addr + 1, val >> 8);
 }
 
 static void
 write_l(xf86Int10InfoPtr pInt, int addr, CARD32 val)
 {
-#if X_BYTE_ORDER == X_BIG_ENDIAN
-    V_ADDR_WB(addr,val);
+#if X_BYTE_ORDER == X_LITTLE_ENDIAN
+    if (OFF(addr + 3) > 2)
+	V_ADDR_WL(addr, val);
+#endif
+    V_ADDR_WB(addr, val);
     V_ADDR_WB(addr + 1, val >> 8);
     V_ADDR_WB(addr + 2, val >> 16);
     V_ADDR_WB(addr + 3, val >> 24);
-#else
-    if (OFF(addr + 3) > 2) {
-	V_ADDR_WL(addr,val);
-    } else {
-	V_ADDR_WB(addr + 3, val);
-	V_ADDR_WB(addr + 2, val >> 8);
-	V_ADDR_WB(addr + 1, val >> 16);
-	V_ADDR_WB(addr, val >> 24);
-    }
-#endif
 }
 
 pointer
 xf86int10Addr(xf86Int10InfoPtr pInt, CARD32 addr)
 {
-    return (pointer) V_ADDR(addr);
+    return V_ADDR(addr);
 }
-
-
-
-
-
-
-
-
Index: XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/int10/helper_exec.c
===================================================================
RCS file: /cvs/xc/programs/Xserver/hw/xfree86/int10/helper_exec.c,v
retrieving revision 1.11
retrieving revision 1.12
diff -u -r1.11 -r1.12
--- XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/int10/helper_exec.c	2000/12/06 15:35:26	1.11
+++ XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/int10/helper_exec.c	2001/01/06 20:19:13	1.12
@@ -1,12 +1,12 @@
-/* $XFree86: xc/programs/Xserver/hw/xfree86/int10/helper_exec.c,v 1.11 2000/12/06 15:35:26 eich Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/int10/helper_exec.c,v 1.12 2001/01/06 20:19:13 tsi Exp $ */
 /*
  *                   XFree86 int10 module
  *   execute BIOS int 10h calls in x86 real mode environment
  *                 Copyright 1999 Egbert Eich
  *
- *   Part of this is based on code taken form DOSEMU
+ *   Part of this is based on code taken from DOSEMU
  *   (C) Copyright 1992, ..., 1999 the "DOSEMU-Development-Team"
- */   
+ */
 
 /*
  * To debug port accesses define PRINT_PORT.
@@ -15,7 +15,6 @@
  * on PIO.
  */
 #include "xf86.h"
-#include "xf86str.h"
 #include "xf86_OSproc.h"
 #include "xf86_ansic.h"
 #include "compiler.h"
@@ -44,17 +43,15 @@
     X86_EDX = (CARD32) pInt->dx;
     X86_ESI = (CARD32) pInt->si;
     X86_EDI = (CARD32) pInt->di;
-    X86_ES  = (CARD32) pInt->es;
     X86_EBP = (CARD32) pInt->bp;
-    X86_EIP = 0;
-    X86_CS = 0x60;               /* address of 'hlt' */               
-    X86_ESP = 0x100;
-    X86_SS = 0x30;               /* This is the standard pc bios stack */
-    X86_DS = 0x40;               /* standard pc ds */  
+    X86_ESP = 0x1000; X86_SS = pInt->stackseg >> 4;
+    X86_EIP = 0x0600; X86_CS = 0x0;	/* address of 'hlt' */
+    X86_DS = 0x40;			/* standard pc ds */
+    X86_ES = pInt->es;
     X86_FS = 0;
     X86_GS = 0;
-    X86_EFLAGS = (X86_IF_MASK | X86_IOPL_MASK);
-   
+    X86_EFLAGS = X86_IF_MASK | X86_IOPL_MASK;
+
     return xf86BlockSIGIO();
 }
 
@@ -68,188 +65,23 @@
     pInt->dx = (CARD16) X86_EDX;
     pInt->si = (CARD16) X86_ESI;
     pInt->di = (CARD16) X86_EDI;
+    pInt->es = (CARD16) X86_ES;
     pInt->bp = (CARD16) X86_EBP;
     pInt->flags = (CARD16) X86_FLAGS;
 }
 
-#define SEG_ADR(type, seg, reg)  type((seg << 4) \
-				      + (X86_##reg))
-#define SEG_EADR(type, seg, reg)  type((seg << 4) \
-				      + (X86_E##reg))
-#ifndef _X86EMU
-/* get the linear address */
-#define LIN_PREF_SI  ((pref_seg << 4) + X86_SI)
-#define LWECX	    (prefix66 ^ prefix67 ? X86_ECX : X86_CX)
-#define LWECX_ZERO  {if (prefix66 ^ prefix67) X86_ECX = 0; else X86_CX = 0;}
-#define DF (1 << 10)
-
-
-/* vm86 fault handling */
-Bool
-vm86_GP_fault(xf86Int10InfoPtr pInt)
-{
-    unsigned char *csp, *lina;
-    CARD32 org_eip;
-    int pref_seg;
-    int done,is_rep,prefix66,prefix67;
-
-
-    csp = lina = SEG_ADR((unsigned char *), X86_CS, IP);
-
-    is_rep = 0;
-    prefix66 = prefix67 = 0;
-    pref_seg = -1;
-
-    /* eat up prefixes */
-    done = 0;
-    do {
-	switch (MEM_RB(pInt,(int)csp++)) {
-	case 0x66:      /* operand prefix */  prefix66=1; break;
-	case 0x67:      /* address prefix */  prefix67=1; break;
-	case 0x2e:      /* CS */              pref_seg=X86_CS; break;
-	case 0x3e:      /* DS */              pref_seg=X86_DS; break;
-	case 0x26:      /* ES */              pref_seg=X86_ES; break;
-	case 0x36:      /* SS */              pref_seg=X86_SS; break;
-	case 0x65:      /* GS */              pref_seg=X86_GS; break;
-	case 0x64:      /* FS */              pref_seg=X86_FS; break;
-	case 0xf2:      /* repnz */
-	case 0xf3:      /* rep */             is_rep=1; break;
-	default: done=1;
-	}
-    } while (!done);
-    csp--;   /* oops one too many */
-    org_eip = X86_EIP;
-    X86_IP += (csp - lina);
-
-    switch (MEM_RB(pInt,(int)csp)) {
-    case 0x6c:                    /* insb */
-	/* NOTE: ES can't be overwritten; prefixes 66,67 should use esi,edi,ecx
-	 * but is anyone using extended regs in real mode? */
-	/* WARNING: no test for DI wrapping! */
-	X86_EDI += port_rep_inb(pInt,X86_DX,SEG_EADR((CARD32),X86_ES,DI),
-				X86_FLAGS & DF, (is_rep? LWECX:1));
-	if (is_rep) LWECX_ZERO;
-	X86_IP++;
-	break;
-
-    case 0x6d:			/* (rep) insw / insd */
-	/* NOTE: ES can't be overwritten */
-	/* WARNING: no test for _DI wrapping! */
-	if (prefix66) {
-	    X86_DI += port_rep_inl(pInt,X86_DX,SEG_ADR((CARD32),X86_ES,DI),
-				   X86_EFLAGS & DF, (is_rep? LWECX:1));
-	}
-	else {
-	    X86_DI += port_rep_inw(pInt,X86_DX,SEG_ADR((CARD32),X86_ES,DI),
-				   X86_FLAGS & DF, (is_rep? LWECX:1));
-	}
-	if (is_rep) LWECX_ZERO;
-	X86_IP++;
-	break;
-
-    case 0x6e:			/* (rep) outsb */
-	if (pref_seg < 0) pref_seg = X86_DS;
-	/* WARNING: no test for _SI wrapping! */
-	X86_SI += port_rep_outb(pInt,X86_DX,(CARD32)LIN_PREF_SI, X86_FLAGS&DF,
-			    (is_rep? LWECX:1));
-	if (is_rep) LWECX_ZERO;
-	X86_IP++;
-	break;
-
-    case 0x6f:			/* (rep) outsw / outsd */
-	if (pref_seg < 0) pref_seg = X86_DS;
-	/* WARNING: no test for _SI wrapping! */
-	if (prefix66) {
-	    X86_SI += port_rep_outl(pInt,X86_DX,(CARD32)LIN_PREF_SI,
-				    X86_EFLAGS&DF, (is_rep? LWECX:1));
-	}
-	else {
-	    X86_SI += port_rep_outw(pInt,X86_DX,(CARD32)LIN_PREF_SI,
-				    X86_FLAGS & DF, (is_rep? LWECX:1));
-	} 
-	if (is_rep) LWECX_ZERO;
-	X86_IP++;
-	break;
-
-    case 0xe5:			/* inw xx, inl xx */
-	if (prefix66) X86_EAX = p_inl((int) MEM_RB(pInt,(int)(csp+1)));
-	else X86_AX = p_inw((int) (int)(csp[1]));  
-	X86_IP += 2;
-	break;
-    case 0xe4:			/* inb xx */
-	X86_AX &= ~(CARD32)0xff;
-	X86_AL |= p_inb((int) MEM_RB(pInt,(int)(csp+1)));
-	X86_IP += 2;
-	break;
-    case 0xed:			/* inw dx, inl dx */
-	if (prefix66) X86_EAX = p_inl(X86_EDX); 
-	else X86_AX = p_inw(X86_DX);
-	X86_IP += 1;
-	break;
-    case 0xec:			/* inb dx */
-	X86_AX &= ~(CARD32)0xff;
-	X86_AL |= p_inb(X86_DX);
-	X86_IP += 1;
-	break;
-
-    case 0xe7:			/* outw xx */
-	if (prefix66) p_outl((int)MEM_RB(pInt,(int)(csp+1)), X86_EAX);
-	else p_outw((int)MEM_RB(pInt,(int)(csp+1)), X86_AX);
-	X86_IP += 2;
-	break;
-    case 0xe6:			/* outb xx */
-	p_outb((int) MEM_RB(pInt,(int)(csp+1)), X86_AL);
-	X86_IP += 2;
-	break;
-    case 0xef:			/* outw dx */
-	if (prefix66) p_outl(X86_DX, X86_EAX);
-	else p_outw(X86_DX, X86_AX);
-	X86_IP += 1;
-	break;
-    case 0xee:			/* outb dx */
-	p_outb(X86_DX, X86_AL);
-	X86_IP += 1;
-	break;
-
-    case 0xf4:
-#ifdef DEBUG
-	ErrorF("hlt at %p\n", lina);
-#endif
-	return FALSE;
-
-    case 0x0f: 
-	xf86DrvMsg(pInt->scrnIndex,
-		X_ERROR,"CPU 0x0f Trap at eip=0x%lx\n",X86_EIP);
-	goto op0ferr; 
-	break;
-
-    case 0xf0:			/* lock */
-    default:
-	xf86DrvMsg(pInt->scrnIndex,X_ERROR,"unknown reason for exception\n");
-	dump_registers(pInt);
-	stack_trace(pInt);
-
-    op0ferr:
-	dump_code(pInt);
-	xf86DrvMsg(pInt->scrnIndex,X_ERROR,"cannot continue\n");
-	return FALSE;
-    }				/* end of switch() */
-    return TRUE;
-}
-#endif
-
 /* general software interrupt handler */
 CARD32
 getIntVect(xf86Int10InfoPtr pInt,int num)
 {
-    return (MEM_RW(pInt,(num << 2)) + (MEM_RW(pInt,((num << 2) + 2)) << 4));
+    return MEM_RW(pInt, num << 2) + (MEM_RW(pInt, (num << 2) + 2) << 4);
 }
 
 void
 pushw(xf86Int10InfoPtr pInt, CARD16 val)
 {
     X86_ESP -= 2;
-    MEM_WW(pInt,((CARD32) X86_SS << 4) + X86_SP,val);
+    MEM_WW(pInt, ((CARD32) X86_SS << 4) + X86_SP, val);
 }
 
 int
@@ -258,11 +90,11 @@
     CARD32 eflags;
 #ifndef _PC
     /* check if bios vector is initialized */
-    if (MEM_RW(pInt,(num<<2)+2) == (SYS_BIOS >> 4)) { /* SYS_BIOS_SEG ?*/
+    if (MEM_RW(pInt, (num << 2) + 2) == (SYS_BIOS >> 4)) { /* SYS_BIOS_SEG ?*/
 #ifdef PRINT_INT
-        ErrorF("card BIOS not loaded\n");
+	ErrorF("card BIOS not loaded\n");
 #endif
-        return 0;
+	return 0;
     }
 #endif
 #ifdef PRINT_INT
@@ -275,11 +107,11 @@
 #endif
     pushw(pInt, eflags);
     pushw(pInt, X86_CS);
-    pushw(pInt, (CARD16)X86_EIP);
-    X86_CS = MEM_RW(pInt,((num << 2) + 2));
-    X86_EIP = (X86_EIP & 0xFFFF0000) | MEM_RW(pInt,(num << 2));
+    pushw(pInt, X86_IP);
+    X86_CS = MEM_RW(pInt, (num << 2) + 2);
+    X86_IP = MEM_RW(pInt,  num << 2);
 #ifdef PRINT_INT
-    ErrorF("0x%x:%lx\n",X86_CS,X86_EIP);
+    ErrorF("0x%x:%lx\n", X86_CS, X86_EIP);
 #endif
     return 1;
 }
@@ -291,52 +123,50 @@
     int i;
     CARD32 lina = SEG_ADR((CARD32), X86_CS, IP);
 
-    ErrorF("code at 0x%8.8lx: ",lina);
-    for (i=0; i<0x10; i++) 
-	ErrorF("%2.2x ",MEM_RB(pInt,lina + i));
-    ErrorF("\n                    ");
-    for (; i<0x20; i++) 
-	ErrorF("%2.2x ",MEM_RB(pInt,lina + i));
-    ErrorF("\n");
+    xf86DrvMsgVerb(pInt->scrnIndex, X_INFO, 3, "code at 0x%8.8lx:\n", lina);
+    for (i=0; i<0x10; i++)
+	xf86ErrorFVerb(3, " %2.2x", MEM_RB(pInt, lina + i));
+    xf86ErrorFVerb(3, "\n");
+    for (; i<0x20; i++)
+	xf86ErrorFVerb(3, " %2.2x", MEM_RB(pInt, lina + i));
+    xf86ErrorFVerb(3, "\n");
 }
 
-#define PRINT(x) ErrorF(#x":%4.4x ",x)
-#define PRINT_FLAGS(x) ErrorF(#x":%8.8x ",x)
 void
 dump_registers(xf86Int10InfoPtr pInt)
 {
-    PRINT(X86_AX);
-    PRINT(X86_BX);
-    PRINT(X86_CX);
-    PRINT(X86_DX);
-    ErrorF("\n");
-    PRINT(X86_IP);
-    PRINT(X86_SI);
-    PRINT(X86_DI);
-    PRINT(X86_BP);
-    PRINT(X86_SP);
-    ErrorF("\n");
-    PRINT(X86_CS);
-    PRINT(X86_SS);
-    PRINT(X86_ES);
-    PRINT(X86_DS);
-    PRINT(X86_FS);
-    PRINT(X86_GS);
-    ErrorF("\n");
-    PRINT_FLAGS(X86_EFLAGS);
-    ErrorF("\n");
+    xf86DrvMsgVerb(pInt->scrnIndex, X_INFO, 3,
+	"EAX=0x%8.8x, EBX=0x%8.8x, ECX=0x%8.8x, EDX=0x%8.8x\n",
+	X86_EAX, X86_EBX, X86_ECX, X86_EDX);
+    xf86DrvMsgVerb(pInt->scrnIndex, X_INFO, 3,
+	"ESP=0x%8.8x, EBP=0x%8.8x, ESI=0x%8.8x, EDI=0x%8.8x\n",
+	X86_ESP, X86_EBP, X86_ESI, X86_EDI);
+    xf86DrvMsgVerb(pInt->scrnIndex, X_INFO, 3,
+	"CS=0x%4.4x, SS=0x%4.4x,"
+	" DS=0x%4.4x, ES=0x%4.4x, FS=0x%4.4x, GS=0x%4.4x\n",
+	X86_CS, X86_SS, X86_DS, X86_ES, X86_FS, X86_GS);
+    xf86DrvMsgVerb(pInt->scrnIndex, X_INFO, 3,
+	"EIP=0x%8.8x, EFLAGS=0x%8.8x\n", X86_EIP, X86_EFLAGS);
 }
 
 void
 stack_trace(xf86Int10InfoPtr pInt)
 {
-    int i;
-    CARD32 stack = SEG_ADR((CARD32), X86_SS, SP);    
-
-    ErrorF("stack at 0x%8.8lx:\n",stack);
-    for (i=0; i < 0x10; i++) 
-	ErrorF("%2.2x ",MEM_RB(pInt,stack + i));
-    ErrorF("\n");
+    int i = 0;
+    CARD32 stack = SEG_ADR((CARD32), X86_SS, SP);
+    CARD32 tail  = (CARD32)((X86_SS << 4) + 0x1000);
+
+    if (stack >= tail) return;
+
+    xf86MsgVerb(X_INFO, 3, "stack at 0x%8.8lx:\n", stack);
+    for (; stack < tail; stack++) {
+	xf86ErrorFVerb(3, " %2.2x", MEM_RB(pInt, stack));
+	i = (i + 1) % 0x10;
+	if (!i)
+	    xf86ErrorFVerb(3, "\n");
+    }
+    if (i)
+	xf86ErrorFVerb(3, "\n");
 }
 
 int
@@ -347,13 +177,13 @@
     CARD32 dst = base;
 #ifdef PRINT_PORT
     ErrorF(" rep_insb(%#x) %d bytes at %p %s\n",
-	     port, count, base, d_f?"up":"down");
+	     port, count, base, d_f ? "up" : "down");
 #endif
     while (count--) {
-	MEM_WB(pInt,dst,inb(port));
+	MEM_WB(pInt, dst, x_inb(port));
 	dst += inc;
     }
-    return (dst-base);
+    return dst - base;
 }
 
 int
@@ -362,15 +192,15 @@
 {
     register int inc = d_f ? -2 : 2;
     CARD32 dst = base;
-#ifdef PRINT_PORT    
+#ifdef PRINT_PORT
     ErrorF(" rep_insw(%#x) %d bytes at %p %s\n",
-	     port, count, base, d_f?"up":"down");
+	     port, count, base, d_f ? "up" : "down");
 #endif
     while (count--) {
-	MEM_WW(pInt,dst,inw(port));
+	MEM_WW(pInt, dst, x_inw(port));
 	dst += inc;
     }
-    return (dst-base);
+    return dst - base;
 }
 
 int
@@ -379,15 +209,15 @@
 {
     register int inc = d_f ? -4 : 4;
     CARD32 dst = base;
-#ifdef PRINT_PORT    
+#ifdef PRINT_PORT
     ErrorF(" rep_insl(%#x) %d bytes at %p %s\n",
-	     port, count, base, d_f?"up":"down");
+	     port, count, base, d_f ? "up" : "down");
 #endif
     while (count--) {
-	MEM_WL(pInt,dst,inl(port));
+	MEM_WL(pInt, dst, x_inl(port));
 	dst += inc;
     }
-    return (dst-base);
+    return dst - base;
 }
 
 int
@@ -396,15 +226,15 @@
 {
     register int inc = d_f ? -1 : 1;
     CARD32 dst = base;
-#ifdef PRINT_PORT    
+#ifdef PRINT_PORT
     ErrorF(" rep_outb(%#x) %d bytes at %p %s\n",
-	     port, count, base, d_f?"up":"down");
+	     port, count, base, d_f ? "up" : "down");
 #endif
     while (count--) {
-	outb(port,MEM_RB(pInt,dst));
+	x_outb(port, MEM_RB(pInt, dst));
 	dst += inc;
     }
-    return (dst-base);
+    return dst - base;
 }
 
 int
@@ -413,15 +243,15 @@
 {
     register int inc = d_f ? -2 : 2;
     CARD32 dst = base;
-#ifdef PRINT_PORT    
+#ifdef PRINT_PORT
     ErrorF(" rep_outw(%#x) %d bytes at %p %s\n",
-	     port, count, base, d_f?"up":"down");
+	     port, count, base, d_f ? "up" : "down");
 #endif
     while (count--) {
-	outw(port,MEM_RW(pInt,dst));
+	x_outw(port, MEM_RW(pInt, dst));
 	dst += inc;
     }
-    return (dst-base);
+    return dst - base;
 }
 
 int
@@ -430,27 +260,36 @@
 {
     register int inc = d_f ? -4 : 4;
     CARD32 dst = base;
-#ifdef PRINT_PORT    
+#ifdef PRINT_PORT
     ErrorF(" rep_outl(%#x) %d bytes at %p %s\n",
-	     port, count, base, d_f?"up":"down");
+	     port, count, base, d_f ? "up" : "down");
 #endif
     while (count--) {
-	outl(port,MEM_RL(pInt,dst));
+	x_outl(port, MEM_RL(pInt, dst));
 	dst += inc;
     }
-    return (dst-base);
+    return dst - base;
 }
 
-#if defined(PRINT_PORT) || (!defined(_PC) && !defined(_PC_IO))
 CARD8
 x_inb(CARD16 port)
 {
     CARD8 val;
 
-    val = inb(port);
-#ifdef PRINT_PORT    
-    ErrorF(" inb(%#x) = %2.2x\n",port,val);
+    if (port >= 0x0100) {	/* Don't interfere with mainboard */
+	val = inb(port);
+#ifdef PRINT_PORT
+	ErrorF(" inb(%#x) = %2.2x\n", port, val);
 #endif
+    } else {
+	val = 0;
+	xf86DrvMsgVerb(Int10Current->scrnIndex, X_NOT_IMPLEMENTED, 2,
+	    "inb 0x%4.4x\n", port);
+	if (xf86GetVerbosity() > 3) {
+	    dump_registers(Int10Current);
+	    stack_trace(Int10Current);
+	}
+    }
     return val;
 }
 
@@ -460,8 +299,8 @@
     CARD16 val;
 
     val = inw(port);
-#ifdef PRINT_PORT    
-    ErrorF(" inw(%#x) = %4.4x\n",port,val);
+#ifdef PRINT_PORT
+    ErrorF(" inw(%#x) = %4.4x\n", port, val);
 #endif
     return val;
 }
@@ -469,19 +308,29 @@
 void
 x_outb(CARD16 port, CARD8 val)
 {
-#ifdef PRINT_PORT    
-    ErrorF(" outb(%#x, %2.2x)\n",port,val);
+    if (port >= 0x0100) {		/* Don't interfere with mainboard */
+#ifdef PRINT_PORT
+	ErrorF(" outb(%#x, %2.2x)\n", port, val);
 #endif
-    outb(port,val);
+	outb(port, val);
+    } else {
+	xf86DrvMsgVerb(Int10Current->scrnIndex, X_NOT_IMPLEMENTED, 2,
+	    "outb 0x%4.4x,0x%2.2x\n", port, val);
+	if (xf86GetVerbosity() > 3) {
+	    dump_registers(Int10Current);
+	    stack_trace(Int10Current);
+	}
+    }
 }
 
 void
 x_outw(CARD16 port, CARD16 val)
 {
-#ifdef PRINT_PORT    
-    ErrorF(" outw(%#x, %4.4x)\n",port,val);
+#ifdef PRINT_PORT
+    ErrorF(" outw(%#x, %4.4x)\n", port, val);
 #endif
-    outw(port,val);
+
+    outw(port, val);
 }
 
 CARD32
@@ -489,13 +338,13 @@
 {
     CARD32 val;
 
-#if !defined  (_PC) && !defined (_PC_PCI)
-    if (!pciCfg1in(port,&val))
+#if !defined(_PC) && !defined(_PC_PCI)
+    if (!pciCfg1in(port, &val))
 #endif
     val = inl(port);
 
 #ifdef PRINT_PORT
-    ErrorF(" inl(%#x) = %8.8x\n",port,val);
+    ErrorF(" inl(%#x) = %8.8x\n", port, val);
 #endif
     return val;
 }
@@ -504,52 +353,52 @@
 x_outl(CARD16 port, CARD32 val)
 {
 #ifdef PRINT_PORT
-    ErrorF(" outl(%#x, %8.8x)\n",port,val);
+    ErrorF(" outl(%#x, %8.8x)\n", port, val);
 #endif
-#if !defined  (_PC) && !defined (_PC_PCI)
-            if (!pciCfg1out(port,val))
+
+#if !defined(_PC) && !defined(_PC_PCI)
+    if (!pciCfg1out(port, val))
 #endif
-	    outl(port,val);
+    outl(port, val);
 }
-#endif
 
 CARD8
 Mem_rb(int addr)
 {
-    return Int10Current->mem->rb(Int10Current,addr);
+    return (*Int10Current->mem->rb)(Int10Current, addr);
 }
 
 CARD16
 Mem_rw(int addr)
 {
-    return Int10Current->mem->rw(Int10Current,addr);
+    return (*Int10Current->mem->rw)(Int10Current, addr);
 }
 
 CARD32
 Mem_rl(int addr)
 {
-    return Int10Current->mem->rl(Int10Current,addr);
+    return (*Int10Current->mem->rl)(Int10Current, addr);
 }
 
 void
-Mem_wb(int addr,CARD8 val)
+Mem_wb(int addr, CARD8 val)
 {
-    Int10Current->mem->wb(Int10Current,addr,val);
+    (*Int10Current->mem->wb)(Int10Current, addr, val);
 }
 
 void
-Mem_ww(int addr,CARD16 val)
+Mem_ww(int addr, CARD16 val)
 {
-    Int10Current->mem->ww(Int10Current,addr,val);
+    (*Int10Current->mem->ww)(Int10Current, addr, val);
 }
 
 void
-Mem_wl(int addr,CARD32 val)
+Mem_wl(int addr, CARD32 val)
 {
-    Int10Current->mem->wl(Int10Current,addr,val);
+    (*Int10Current->mem->wl)(Int10Current, addr, val);
 }
 
-#if !defined  (_PC) && !defined (_PC_PCI)
+#if !defined(_PC) && !defined(_PC_PCI)
 static CARD32 PciCfg1Addr = 0;
 
 #define TAG(Cfg1Addr) (Cfg1Addr & 0xffff00)
@@ -562,7 +411,7 @@
 	*val = PciCfg1Addr;
 	return 1;
     }
-    else if (addr == 0xCFC) {
+    if (addr == 0xCFC) {
 	*val = pciReadLong(TAG(PciCfg1Addr), OFFSET(PciCfg1Addr));
 	return 1;
     }
@@ -576,7 +425,7 @@
 	PciCfg1Addr = val;
 	return 1;
     }
-    else if (addr == 0xCFC) {
+    if (addr == 0xCFC) {
 	pciWriteLong(TAG(PciCfg1Addr), OFFSET(PciCfg1Addr),val);
 	return 1;
     }
@@ -603,7 +452,7 @@
  * disable registers before we call the BIOS initialization and
  * restore the original values afterwards. In beween we hold our
  * breath. To get to a (possibly exising) ISA card need to disable
- * our current PCI card. 
+ * our current PCI card.
  */
 /*
  * This is just for booting: we just want to catch pure
@@ -615,25 +464,25 @@
 void
 LockLegacyVGA(int screenIndex,legacyVGAPtr vga)
 {
-    xf86SetCurrentAccess(FALSE,xf86Screens[screenIndex]);
+    xf86SetCurrentAccess(FALSE, xf86Screens[screenIndex]);
     vga->save_msr = inb(0x3CC);
     vga->save_vse = inb(0x3C3);
     vga->save_46e8 = inb(0x46e8);
     vga->save_pos102 = inb(0x102);
-    outb(0x3C2,~(CARD8)0x03 & vga->save_msr);
-    outb(0x3C3,~(CARD8)0x01 & vga->save_vse);
+    outb(0x3C2, ~(CARD8)0x03 & vga->save_msr);
+    outb(0x3C3, ~(CARD8)0x01 & vga->save_vse);
     outb(0x46e8, ~(CARD8)0x08 & vga->save_46e8);
     outb(0x102, ~(CARD8)0x01 & vga->save_pos102);
-    xf86SetCurrentAccess(TRUE,xf86Screens[screenIndex]);
+    xf86SetCurrentAccess(TRUE, xf86Screens[screenIndex]);
 }
 
 void
 UnlockLegacyVGA(int screenIndex, legacyVGAPtr vga)
 {
-    xf86SetCurrentAccess(FALSE,xf86Screens[screenIndex]);
+    xf86SetCurrentAccess(FALSE, xf86Screens[screenIndex]);
     outb(0x102, vga->save_pos102);
     outb(0x46e8, vga->save_46e8);
     outb(0x3C3, vga->save_vse);
     outb(0x3C2, vga->save_msr);
-    xf86SetCurrentAccess(TRUE,xf86Screens[screenIndex]);
+    xf86SetCurrentAccess(TRUE, xf86Screens[screenIndex]);
 }
Index: XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/int10/helper_mem.c
===================================================================
RCS file: /cvs/xc/programs/Xserver/hw/xfree86/int10/helper_mem.c,v
retrieving revision 1.14
retrieving revision 1.15
diff -u -r1.14 -r1.15
--- XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/int10/helper_mem.c	2000/12/02 15:31:01	1.14
+++ XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/int10/helper_mem.c	2001/01/06 20:19:13	1.15
@@ -1,11 +1,10 @@
-/* $XFree86: xc/programs/Xserver/hw/xfree86/int10/helper_mem.c,v 1.14 2000/12/02 15:31:01 tsi Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/int10/helper_mem.c,v 1.15 2001/01/06 20:19:13 tsi Exp $ */
 /*
  *                   XFree86 int10 module
  *   execute BIOS int 10h calls in x86 real mode environment
  *                 Copyright 1999 Egbert Eich
  */
 #include "xf86.h"
-#include "xf86str.h"
 #include "xf86_OSproc.h"
 #include "xf86_ansic.h"
 #include "compiler.h"
@@ -21,14 +20,14 @@
 } INT10Opts;
 
 static OptionInfoRec INT10Options[] = {
-    {OPT_NOINT10,       "NoINT10",      OPTV_BOOLEAN,   {0},    FALSE },
-    { -1,		NULL,		OPTV_NONE,	{0},	FALSE },
+    {OPT_NOINT10, "NoINT10", OPTV_BOOLEAN, {0}, FALSE},
+    { -1,         NULL,      OPTV_NONE,    {0}, FALSE},
 };
 
 #define nINT10Options (sizeof(INT10Options) / sizeof(INT10Options[0]))
 
 #ifdef DEBUG
-void 
+void
 dprint(unsigned long start, unsigned long size)
 {
     int i,j;
@@ -37,7 +36,7 @@
     for (j = 0; j < (size >> 4); j++) {
 	char *d = c;
 	ErrorF("\n0x%lx:  ",(unsigned long)c);
-	for (i = 0; i<16; i++) 
+	for (i = 0; i<16; i++)
 	    ErrorF("%2.2x ",(unsigned char) (*(c++)));
 	c = d;
 	for (i = 0; i<16; i++) {
@@ -49,8 +48,8 @@
     ErrorF("\n");
 }
 #endif
-
 
+#ifndef _PC
 /*
  * here we are really paranoid about faking a "real"
  * BIOS. Most of this information was pulled from
@@ -59,66 +58,64 @@
 void
 setup_int_vect(xf86Int10InfoPtr pInt)
 {
-    const CARD16 cs = (SYS_BIOS >> 4);
-    const CARD16 ip = 0x0;
     int i;
-    
+
     /* let the int vects point to the SYS_BIOS seg */
-    for (i=0; i<0x80; i++) {
-	MEM_WW(pInt,(i<<2),ip);
-	MEM_WW(pInt,((i<<2)+2),cs);
+    for (i = 0; i < 0x80; i++) {
+	MEM_WW(pInt, i << 2, 0);
+	MEM_WW(pInt, (i << 2) + 2, SYS_BIOS >> 4);
     }
-    /* video interrupts default location */
-    MEM_WW(pInt,(0x42<<2),0xf065);
-    MEM_WW(pInt,(0x10<<2),0xf065);
-    MEM_WW(pInt,(0x6D<<2),0xf065);
-    /* video param table default location (int 1d) */
-    MEM_WW(pInt,(0x1d<<2),0xf0A4);
+
+    reset_int_vect(pInt);
     /* font tables default location (int 1F) */
-    MEM_WW(pInt,(0x1f<<2),0xfa6e);
+    MEM_WW(pInt,0x1f<<2,0xfa6e);
 
-    /* int 11 default location */
-    MEM_WW(pInt,(0x11<<2),0xf84d);
-    /* int 12 default location */
-    MEM_WW(pInt,(0x12<<2),0xf841);
-    /* int 15 default location */
-    MEM_WW(pInt,(0x15<<2),0xf859);
-    /* int 1A default location */
-    MEM_WW(pInt,(0x1a<<2),0xff6e);
-    /* int 05 default location */
-    MEM_WW(pInt,(0x05<<2),0xff54);
-    /* int 08 default location */
-    MEM_WW(pInt,(0x08<<2),0xfea5);
-    /* int 13 default location (fdd) */
-    MEM_WW(pInt,(0x13<<2),0xec59);
-    /* int 0E default location */
-    MEM_WW(pInt,(0x0e<<2),0xef57);
-    /* int 17 default location */
-    MEM_WW(pInt,(0x17<<2),0xefd2);
+    /* int 11 default location (Get Equipment Configuration) */
+    MEM_WW(pInt, 0x11 << 2, 0xf84d);
+    /* int 12 default location (Get Conventional Memory Size) */
+    MEM_WW(pInt, 0x12 << 2, 0xf841);
+    /* int 15 default location (I/O System Extensions) */
+    MEM_WW(pInt, 0x15 << 2, 0xf859);
+    /* int 1A default location (RTC, PCI and others) */
+    MEM_WW(pInt, 0x1a << 2, 0xff6e);
+    /* int 05 default location (Bound Exceeded) */
+    MEM_WW(pInt, 0x05 << 2, 0xff54);
+    /* int 08 default location (Double Fault) */
+    MEM_WW(pInt, 0x08 << 2, 0xfea5);
+    /* int 13 default location (Disk) */
+    MEM_WW(pInt, 0x13 << 2, 0xec59);
+    /* int 0E default location (Page Fault) */
+    MEM_WW(pInt, 0x0e << 2, 0xef57);
+    /* int 17 default location (Parallel Port) */
+    MEM_WW(pInt, 0x17 << 2, 0xefd2);
     /* fdd table default location (int 1e) */
-    MEM_WW(pInt,(0x1e<<2),0xefc7);
+    MEM_WW(pInt, 0x1e << 2, 0xefc7);
+
+    /* Set Equipment flag to VGA */
+    i = MEM_RB(pInt, 0x0410) & 0xCF;
+    MEM_WB(pInt, 0x0410, i);
+    /* XXX Perhaps setup more of the BDA here.  See also int42(0x00). */
 }
+#endif
 
 int
 setup_system_bios(memType base_addr)
 {
-    char *date = "06/01/99";
-    char *eisa_ident = "PCI/ISA";
-    CARD16 *base = (CARD16*) base_addr;
-    
+    char *base = (char *) base_addr;
+
     /*
      * we trap the "industry standard entry points" to the BIOS
      * and all other locations by filling them with "hlt"
      * TODO: implement hlt-handler for these
      */
-    memset((void *)(base),0xf4,0x10000);
+    memset(base, 0xf4, 0x10000);
 
     /* set bios date */
-    strcpy((((char *)base) + 0xFFF5),date);
+    strcpy(base + 0x0FFF5, "06/11/99");
     /* set up eisa ident string */
-    strcpy((((char *)base) + 0xFFD9),eisa_ident);
+    strcpy(base + 0x0FFD9, "PCI_ISA");
     /* write system model id for IBM-AT */
-    *(((unsigned char *)base) + 0xFFFE) = 0xfc;
+    *((unsigned char *)(base + 0x0FFFE)) = 0xfc;
 
     return 1;
 }
@@ -126,23 +123,65 @@
 void
 reset_int_vect(xf86Int10InfoPtr pInt)
 {
-    MEM_WW(pInt,(0x10<<2),0xf065);    
-    MEM_WW(pInt,((0x10<<2)+2),(SYS_BIOS >> 4));
-    MEM_WW(pInt,(0x42<<2),0xf065);
-    MEM_WW(pInt,((0x42<<2)+2),(SYS_BIOS >> 4));
-    MEM_WW(pInt,(0x6D<<2),0xf065);
-    MEM_WW(pInt,((0x6D<<2)+2),(SYS_BIOS >> 4));
- }
+    /*
+     * This table is normally located at 0xF000:0xF0A4.  However, int 0x42,
+     * function 0 (Mode Set) expects it (or a copy) somewhere in the bottom
+     * 64kB.  Note that because this data doesn't survive POST, int 0x42 should
+     * only be used during EGA/VGA BIOS initialisation.
+     */
+    static const CARD8 VideoParms[] = {
+	/* Timing for modes 0x00 & 0x01 */
+	0x38, 0x28, 0x2d, 0x0a, 0x1f, 0x06, 0x19, 0x1c,
+	0x02, 0x07, 0x06, 0x07, 0x00, 0x00, 0x00, 0x00,
+	/* Timing for modes 0x02 & 0x03 */
+	0x71, 0x50, 0x5a, 0x0a, 0x1f, 0x06, 0x19, 0x1c,
+	0x02, 0x07, 0x06, 0x07, 0x00, 0x00, 0x00, 0x00,
+	/* Timing for modes 0x04, 0x05 & 0x06 */
+	0x38, 0x28, 0x2d, 0x0a, 0x7f, 0x06, 0x64, 0x70,
+	0x02, 0x01, 0x06, 0x07, 0x00, 0x00, 0x00, 0x00,
+	/* Timing for mode 0x07 */
+	0x61, 0x50, 0x52, 0x0f, 0x19, 0x06, 0x19, 0x19,
+	0x02, 0x0d, 0x0b, 0x0c, 0x00, 0x00, 0x00, 0x00,
+	/* Display page lengths in little endian order */
+	0x00, 0x08, /* Modes 0x00 and 0x01 */
+	0x00, 0x10, /* Modes 0x02 and 0x03 */
+	0x00, 0x40, /* Modes 0x04 and 0x05 */
+	0x00, 0x40, /* Modes 0x06 and 0x07 */
+	/* Number of columns for each mode */
+	40, 40, 80, 80, 40, 40, 80, 80,
+	/* CGA Mode register value for each mode */
+	0x2c, 0x28, 0x2d, 0x29, 0x2a, 0x2e, 0x1e, 0x29,
+	/* Padding */
+	0x00, 0x00, 0x00, 0x00
+	};
+    int i;
+
+    for (i = 0; i < sizeof(VideoParms); i++)
+	MEM_WB(pInt, i + (0x1000 - sizeof(VideoParms)), VideoParms[i]);
+    MEM_WW(pInt,  0x1d << 2, 0x1000 - sizeof(VideoParms));
+    MEM_WW(pInt, (0x1d << 2) + 2, 0);
+
+    MEM_WW(pInt,  0x10 << 2, 0xf065);
+    MEM_WW(pInt, (0x10 << 2) + 2, SYS_BIOS >> 4);
+    MEM_WW(pInt,  0x42 << 2, 0xf065);
+    MEM_WW(pInt, (0x42 << 2) + 2, SYS_BIOS >> 4);
+    MEM_WW(pInt,  0x6D << 2, 0xf065);
+    MEM_WW(pInt, (0x6D << 2) + 2, SYS_BIOS >> 4);
+}
 
 void
 set_return_trap(xf86Int10InfoPtr pInt)
-{   
+{
     /*
-     * here we also set the exit condition:
-     * we return when we encounter 'hlt' (^=0xf4) this
-     * will be located at address 0x600 in x86 memory.
+     * Here we set the exit condition:  We return when we encounter
+     * 'hlt' (=0xf4), which we locate at address 0x600 in x86 memory.
      */
-    MEM_WB(pInt,0x600,0xf4);
+    MEM_WB(pInt, 0x0600, 0xf4);
+
+    /*
+     * Allocate a segment for the stack
+     */
+    xf86Int10AllocPages(pInt, 1, &pInt->stackseg);
 }
 
 Bool
@@ -150,7 +189,7 @@
 {
     Bool noint10 = FALSE;
     EntityInfoPtr pEnt = xf86GetEntityInfo(entityIndex);
-    
+
     if (pEnt->device && pEnt->device->options) {
 	OptionInfoRec options[nINT10Options];
 
@@ -170,12 +209,12 @@
     int size;
 
     if ((codeSeg & 0x1f) ||	/* Not 512-byte aligned otherwise */
-        ((codeSeg << 4) < V_BIOS) ||
+	((codeSeg << 4) < V_BIOS) ||
 	((codeSeg << 4) >= SYS_SIZE))
-        return FALSE;
+	return FALSE;
 
     if (xf86IsPc98())
-        return FALSE;
+	return FALSE;
 
     if ((*vbiosMem != 0x55) || (*(vbiosMem+1) != 0xAA) || !*(vbiosMem+2))
 	return FALSE;
Index: XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/int10/pci.c
===================================================================
RCS file: /cvs/xc/programs/Xserver/hw/xfree86/int10/pci.c,v
retrieving revision 1.5
retrieving revision 1.6
diff -u -r1.5 -r1.6
--- XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/int10/pci.c	2000/12/02 15:31:01	1.5
+++ XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/int10/pci.c	2001/01/06 20:19:13	1.6
@@ -1,4 +1,4 @@
-/* $XFree86: xc/programs/Xserver/hw/xfree86/int10/pci.c,v 1.5 2000/12/02 15:31:01 tsi Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/int10/pci.c,v 1.6 2001/01/06 20:19:13 tsi Exp $ */
 
 /*
  *                   XFree86 int10 module
@@ -7,7 +7,6 @@
  */
 #include "xf86Pci.h"
 #include "xf86.h"
-#include "xf86str.h"
 #include "xf86_ansic.h"
 #define _INT10_PRIVATE
 #include "xf86int10.h"
@@ -18,7 +17,7 @@
     PCITAG tag;
     unsigned long offset = 0;
     unsigned char *mem, *ptr;
-    int length, rlength, blength;
+    int length;
 
     pciVideoPtr pvp = xf86GetPciInfoForEntity(pInt->entityIndex);
 
@@ -30,25 +29,18 @@
     }
 
     tag = pciTag(pvp->bus,pvp->device,pvp->func);
-    rlength = blength = 1 << pvp->biosSize;
+    length = 1 << pvp->biosSize;
 
-    /* Read in entire PCI ROM in 64kB chunks */
-    mem = ptr = xnfcalloc(blength, 1);
-    while ((length = rlength) > 0) {
-	if (length > 0x10000) length = 0x10000;
-	if (xf86ReadPciBIOS(offset, tag, -1, ptr, length) < length) {
-	    xfree(mem);
+    /* Read in entire PCI ROM */
+    mem = ptr = xnfcalloc(length, 1);
+    if (xf86ReadPciBIOS(offset, tag, -1, ptr, length) < length) {
+	xfree(mem);
 #ifdef DEBUG
-	    ErrorF("mapPciRom: cannot read BIOS\n");
+	ErrorF("mapPciRom: cannot read BIOS\n");
 #endif
-	    return 0;
-	}
-	offset += length;
-	rlength -= length;
-	ptr += length;
+	return 0;
     }
 
-    ptr = mem;
     while ((ptr[0] == 0x55) && (ptr[1] == 0xAA)) {
 	unsigned short data_off = ptr[0x18] | (ptr[0x19] << 8);
 	unsigned char *data = ptr + data_off;
@@ -63,10 +55,10 @@
 #ifdef PRINT_PCI
 	ErrorF("data segment in BIOS: 0x%x, type: 0x%x\n", data_off, type);
 #endif
-	if (type) {     /* not PC-AT image: find next one */
+	if (type) {	/* not PC-AT image: find next one */
 	    unsigned int image_length;
 	    unsigned char indicator = data[0x15];
-	    if (indicator & 0x80) /* last image */
+	    if (indicator & 0x80)	/* last image */
 		break;
 	    image_length = (data[0x10] | (data[0x11] << 8)) << 9;
 #ifdef PRINT_PCI
Index: XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/int10/xf86int10.c
===================================================================
RCS file: /cvs/xc/programs/Xserver/hw/xfree86/int10/xf86int10.c,v
retrieving revision 1.5
retrieving revision 1.6
diff -u -r1.5 -r1.6
--- XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/int10/xf86int10.c	2000/04/04 19:25:18	1.5
+++ XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/int10/xf86int10.c	2001/01/06 20:19:13	1.6
@@ -1,4 +1,4 @@
-/* $XFree86: xc/programs/Xserver/hw/xfree86/int10/xf86int10.c,v 1.5 2000/04/04 19:25:18 dawes Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/int10/xf86int10.c,v 1.6 2001/01/06 20:19:13 tsi Exp $ */
 /*
  *                   XFree86 int10 module
  *   execute BIOS int 10h calls in x86 real mode environment
@@ -6,7 +6,6 @@
  */
 
 #include "xf86.h"
-#include "xf86str.h"
 #include "xf86_ansic.h"
 #include "compiler.h"
 #include "xf86Pci.h"
@@ -14,10 +13,14 @@
 #include "xf86int10.h"
 #include "int10Defines.h"
 
+#define REG pInt
+
 xf86Int10InfoPtr Int10Current = NULL;
 
 static int int1A_handler(xf86Int10InfoPtr pInt);
+#ifndef _PC
 static int int42_handler(xf86Int10InfoPtr pInt);
+#endif
 static int intE6_handler(xf86Int10InfoPtr pInt);
 static PCITAG findPci(unsigned short bx);
 static CARD32 pciSlotBX(pciVideoPtr pvp);
@@ -26,88 +29,557 @@
 int_handler(xf86Int10InfoPtr pInt)
 {
     int num = pInt->num;
+    int ret = 0;
 
     switch (num) {
+#ifndef _PC
     case 0x10:
     case 0x42:
-	if (!(int42_handler(pInt)))
-	    goto bios_handler;
-	else return 1;
+    case 0x6D:
+	if (getIntVect(pInt, num) == I_S_DEFAULT_INT_VECT)
+	    ret = int42_handler(pInt);
+	break;
+#endif
     case 0x1A:
-	if(!(int1A_handler(pInt)))
-	    goto bios_handler;
-	else return 1;
+	ret = int1A_handler(pInt);
+	break;
     case 0xe6:
-	if (!(intE6_handler(pInt)))
-	    goto bios_handler;
-	else return 1;
+	ret = intE6_handler(pInt);
+	break;
     default:
-	goto bios_handler;
+	break;
     }
- bios_handler:
-    return run_bios_int(num,pInt);
+
+    if (!ret)
+	ret = run_bios_int(num, pInt);
+
+    if (!ret) {
+	xf86DrvMsg(pInt->scrnIndex, X_ERROR,
+	    "Halting on int 0x%2.2x!\n", num);
+	dump_registers(pInt);
+	stack_trace(pInt);
+    }
+
+    return ret;
 }
 
+#ifndef _PC
 /*
- * The system-BIOS provides int10 ax=1200 and ax=1201 functions
- * before the video bios is installed. The int10_handler below
- * provides these functions, too. However there have been cases
- * in which disabling generic video has caused problems. Therefore
- * it has been disabled by default. To reenable it do:
- * #define DO_GENERIC_INT10
+ * This is derived from a number of PC system BIOS'es.  The intent here is to
+ * provide very primitive video support, before an EGA/VGA BIOS installs its
+ * own interrupt vector.  Here, "Ignored" calls should remain so.  "Not
+ * Implemented" denotes functionality that can be implemented should the need
+ * arise.  What are "Not Implemented" throughout are video memory accesses.
+ * Also, very little input validity checking is done here.
  */
 static int
 int42_handler(xf86Int10InfoPtr pInt)
 {
-#define REG pInt
-#ifdef DO_GENERIC_INT10
-    unsigned char c;
-#endif
-    int num = pInt->num;
-#ifdef PRINT_INT
-    ErrorF("int 0x%x: ax:0x%x bx:0x%x cx:0x%x dx:0x%x\n",num,
-	   X86_EAX,X86_EBX,X86_ECX,X86_EDX);
-#endif
-    /*
-     * video bios has modified these -
-     * leave it to the video bios to do this
-     */
+    switch (X86_AH) {
+    case 0x00:
+	/* Set Video Mode                                     */
+	/* Enter:  AL = video mode number                     */
+	/* Leave:  Nothing                                    */
+	/* Implemented (except for clearing the screen)       */
+	{                                         /* Localise */
+	    int i;
+	    CARD16 ioport, int1d, regvals, tmp;
+	    CARD8 mode, cgamode, cgacolour;
+
+	    /*
+	     * Ignore all mode numbers but 0x00-0x13.  Some systems also ignore
+	     * 0x0B and 0x0C, but don't do that here.
+	     */
+	    if (X86_AL > 0x13)
+		break;
+
+	    /*
+	     * You didn't think that was really the mode set, did you?  There
+	     * are only so many slots in the video parameter table...
+	     */
+	    mode = X86_AL;
+	    ioport = 0x03D4;
+	    switch (MEM_RB(pInt, 0x0410) & 0x30) {
+	    case 0x30:                  /* MDA */
+		mode = 0x07;            /* Force mode to 0x07 */
+		ioport = 0x03B4;
+		break;
+	    case 0x10:                  /* CGA 40x25 */
+		if (mode >= 0x07)
+		    mode = 0x01;
+		break;
+	    case 0x20:                  /* CGA 80x25 (MCGA?) */
+		if (mode >= 0x07)
+		    mode = 0x03;
+		break;
+	    case 0x00:                  /* EGA/VGA */
+		if (mode >= 0x07)       /* Don't try MDA timings */
+		    mode = 0x01;        /* !?!?! */
+		break;
+	    }
+
+	    /* Locate data in video parameter table */
+	    int1d = MEM_RW(pInt, 0x1d << 2);
+	    regvals = ((mode >> 1) << 4) + int1d;
+	    cgacolour = 0x30;
+	    if (mode == 0x06) {
+		regvals -= 0x10;
+		cgacolour = 0x3F;
+	    }
+
+	    /** Update BIOS Data Area **/
+
+	    /* Video mode */
+	    MEM_WB(pInt, 0x0449, mode);
+
+	    /* Columns */
+	    tmp = MEM_RB(pInt, mode + int1d + 0x48);
+	    MEM_WW(pInt, 0x044A, tmp);
+
+	    /* Page length */
+	    tmp = MEM_RW(pInt, (mode & 0x06) + int1d + 0x40);
+	    MEM_WW(pInt, 0x044C, tmp);
+
+	    /* Start Address */
+	    MEM_WW(pInt, 0x044E, 0);
+
+	    /* Cursor positions, one for each display page */
+	    for (i = 0x0450; i < 0x0460; i += 2)
+		MEM_WW(pInt, i, 0);
+
+	    /* Cursor start & end scanlines */
+	    tmp = MEM_RB(pInt, regvals + 0x0B);
+	    MEM_WB(pInt, 0x0460, tmp);
+	    tmp = MEM_RB(pInt, regvals + 0x0A);
+	    MEM_WB(pInt, 0x0461, tmp);
+
+	    /* Current display page number */
+	    MEM_WB(pInt, 0x0462, 0);
+
+	    /* CRTC I/O address */
+	    MEM_WW(pInt, 0x0463, ioport);
+
+	    /* CGA Mode register value */
+	    cgamode = MEM_RB(pInt, mode + int1d + 0x50);
+	    MEM_WB(pInt, 0x0465, cgamode);
+
+	    /* CGA Colour register value */
+	    MEM_WB(pInt, 0x0466, cgacolour);
+
+	    /* Rows */
+	    MEM_WB(pInt, 0x0484, (25 - 1));
+
+	    /* Programme the mode */
+	    outb(ioport + 4, cgamode & 0x37);   /* Turn off screen */
+	    for (i = 0; i < 0x10; i++) {
+		tmp = MEM_RB(pInt, regvals + i);
+		outb(ioport, i);
+		outb(ioport + 1, tmp);
+	    }
+	    outb(ioport + 5, cgacolour);        /* Select colour mode */
+	    outb(ioport + 4, cgamode);          /* Turn on screen */
+	}
+	break;
+
+    case 0x01:
+	/* Set Cursor Type                                    */
+	/* Enter:  CH = starting line for cursor              */
+	/*         CL = ending line for cursor                */
+	/* Leave:  Nothing                                    */
+	/* Implemented                                        */
+	{                                         /* Localise */
+	    CARD16 ioport = MEM_RW(pInt, 0x0463);
+
+	    MEM_WB(pInt, 0x0460, X86_CL);
+	    MEM_WB(pInt, 0x0461, X86_CH);
+
+	    outb(ioport, 0x0A);
+	    outb(ioport + 1, X86_CH);
+	    outb(ioport, 0x0B);
+	    outb(ioport + 1, X86_CL);
+	}
+	break;
+
+    case 0x02:
+	/* Set Cursor Position                                */
+	/* Enter:  BH = display page number                   */
+	/*         DH = row                                   */
+	/*         DL = column                                */
+	/* Leave:  Nothing                                    */
+	/* Implemented                                        */
+	{                                         /* Localise */
+	    CARD16 offset, ioport;
+
+	    MEM_WB(pInt, (X86_BH << 1) + 0x0450, X86_DL);
+	    MEM_WB(pInt, (X86_BH << 1) + 0x0451, X86_DH);
+
+	    if (X86_BH != MEM_RB(pInt, 0x0462))
+		break;
+
+	    offset = (X86_DH * MEM_RW(pInt, 0x044A)) + X86_DL;
+	    offset += MEM_RW(pInt, 0x044E) << 1;
+
+	    ioport = MEM_RW(pInt, 0x0463);
+	    outb(ioport, 0x0E);
+	    outb(ioport + 1, offset >> 8);
+	    outb(ioport, 0x0F);
+	    outb(ioport + 1, offset & 0xFF);
+	}
+	break;
+
+    case 0x03:
+	/* Get Cursor Position                                */
+	/* Enter:  BH = display page number                   */
+	/* Leave:  CH = starting line for cursor              */
+	/*         CL = ending line for cursor                */
+	/*         DH = row                                   */
+	/*         DL = column                                */
+	/* Implemented                                        */
+	{                                         /* Localise */
+	    X86_CL = MEM_RB(pInt, 0x0460);
+	    X86_CH = MEM_RB(pInt, 0x0461);
+	    X86_DL = MEM_RB(pInt, (X86_BH << 1) + 0x0450);
+	    X86_DH = MEM_RB(pInt, (X86_BH << 1) + 0x0451);
+	}
+	break;
+
+    case 0x04:
+	/* Get Light Pen Position                             */
+	/* Enter:  Nothing                                    */
+	/* Leave:  AH = 0x01 (down/triggered) or 0x00 (not)   */
+	/*         BX = pixel column                          */
+	/*         CX = pixel row                             */
+	/*         DH = character row                         */
+	/*         DL = character column                      */
+	/* Not Implemented                                    */
+	{                                         /* Localise */
+	    xf86DrvMsgVerb(pInt->scrnIndex, X_NOT_IMPLEMENTED, 2,
+		"int 0x%2.2x(AH=0x04) -- Get Light Pen Position\n", pInt->num);
+	    if (xf86GetVerbosity() > 3) {
+		dump_registers(pInt);
+		stack_trace(pInt);
+	    }
+	    X86_AH = X86_BX = X86_CX = X86_DX = 0;
+	}
+	break;
+
+    case 0x05:
+	/* Set Display Page                                   */
+	/* Enter:  AL = display page number                   */
+	/* Leave:  Nothing                                    */
+	/* Implemented                                        */
+	{                                         /* Localise */
+	    CARD16 start, ioport = MEM_RW(pInt, 0x0463);
+	    CARD8 x, y;
+
+	    /* Calculate new start address */
+	    MEM_WB(pInt, 0x0462, X86_AL);
+	    start = X86_AL * MEM_RW(pInt, 0x044C);
+	    MEM_WW(pInt, 0x044E, start);
+	    start <<= 1;
+
+	    /* Update start address */
+	    outb(ioport, 0x0C);
+	    outb(ioport + 1, start >> 8);
+	    outb(ioport, 0x0D);
+	    outb(ioport + 1, start & 0xFF);
+
+	    /* Switch cursor position */
+	    y = MEM_RB(pInt, (X86_AL << 1) + 0x0450);
+	    x = MEM_RB(pInt, (X86_AL << 1) + 0x0451);
+	    start += (y * MEM_RW(pInt, 0x044A)) + x;
+
+	    /* Update cursor position */
+	    outb(ioport, 0x0E);
+	    outb(ioport + 1, start >> 8);
+	    outb(ioport, 0x0F);
+	    outb(ioport + 1, start & 0xFF);
+	}
+	break;
+
+    case 0x06:
+	/* Initialise or Scroll Window Up                     */
+	/* Enter:  AL = lines to scroll up                    */
+	/*         BH = attribute for blank                   */
+	/*         CH = upper y of window                     */
+	/*         CL = left x of window                      */
+	/*         DH = lower y of window                     */
+	/*         DL = right x of window                     */
+	/* Leave:  Nothing                                    */
+	/* Not Implemented                                    */
+	{                                         /* Localise */
+	    xf86DrvMsgVerb(pInt->scrnIndex, X_NOT_IMPLEMENTED, 2,
+		"int 0x%2.2x(AH=0x06) -- Initialise or Scroll Window Up\n",
+		pInt->num);
+	    xf86DrvMsgVerb(pInt->scrnIndex, X_NOT_IMPLEMENTED, 3,
+		" AL=0x%2.2x, BH=0x%2.2x,"
+		" CH=0x%2.2x, CL=0x%2.2x, DH=0x%2.2x, DL=0x%2.2x\n",
+		X86_AL, X86_BH, X86_CH, X86_CL, X86_DH, X86_DL);
+	    if (xf86GetVerbosity() > 3) {
+		dump_registers(pInt);
+		stack_trace(pInt);
+	    }
+	}
+	break;
+
+    case 0x07:
+	/* Initialise or Scroll Window Down                   */
+	/* Enter:  AL = lines to scroll down                  */
+	/*         BH = attribute for blank                   */
+	/*         CH = upper y of window                     */
+	/*         CL = left x of window                      */
+	/*         DH = lower y of window                     */
+	/*         DL = right x of window                     */
+	/* Leave:  Nothing                                    */
+	/* Not Implemented                                    */
+	{                                         /* Localise */
+	    xf86DrvMsgVerb(pInt->scrnIndex, X_NOT_IMPLEMENTED, 2,
+		"int 0x%2.2x(AH=0x07) -- Initialise or Scroll Window Down\n",
+		pInt->num);
+	    xf86DrvMsgVerb(pInt->scrnIndex, X_NOT_IMPLEMENTED, 3,
+		" AL=0x%2.2x, BH=0x%2.2x,"
+		" CH=0x%2.2x, CL=0x%2.2x, DH=0x%2.2x, DL=0x%2.2x\n",
+		X86_AL, X86_BH, X86_CH, X86_CL, X86_DH, X86_DL);
+	    if (xf86GetVerbosity() > 3) {
+		dump_registers(pInt);
+		stack_trace(pInt);
+	    }
+	}
+	break;
+
+    case 0x08:
+	/* Read Character and Attribute at Cursor             */
+	/* Enter:  BH = display page number                   */
+	/* Leave:  AH = attribute                             */
+	/*         AL = character                             */
+	/* Not Implemented                                    */
+	{                                         /* Localise */
+	    xf86DrvMsgVerb(pInt->scrnIndex, X_NOT_IMPLEMENTED, 2,
+		"int 0x%2.2x(AH=0x08) -- Read Character and Attribute at"
+		" Cursor\n", pInt->num);
+	    xf86DrvMsgVerb(pInt->scrnIndex, X_NOT_IMPLEMENTED, 3,
+		"BH=0x%2.2x\n", X86_BH);
+	    if (xf86GetVerbosity() > 3) {
+		dump_registers(pInt);
+		stack_trace(pInt);
+	    }
+	    X86_AX = 0;
+	}
+	break;
+
+    case 0x09:
+	/* Write Character and Attribute at Cursor            */
+	/* Enter:  AL = character                             */
+	/*         BH = display page number                   */
+	/*         BL = attribute (text) or colour (graphics) */
+	/*         CX = replication count                     */
+	/* Leave:  Nothing                                    */
+	/* Not Implemented                                    */
+	{                                         /* Localise */
+	    xf86DrvMsgVerb(pInt->scrnIndex, X_NOT_IMPLEMENTED, 2,
+		"int 0x%2.2x(AH=0x09) -- Write Character and Attribute at"
+		" Cursor\n", pInt->num);
+	    xf86DrvMsgVerb(pInt->scrnIndex, X_NOT_IMPLEMENTED, 3,
+		"AL=0x%2.2x, BH=0x%2.2x, BL=0x%2.2x, CX=0x%4.4x\n",
+		X86_AL, X86_BH, X86_BL, X86_CX);
+	    if (xf86GetVerbosity() > 3) {
+		dump_registers(pInt);
+		stack_trace(pInt);
+	    }
+	}
+	break;
+
+    case 0x0a:
+	/* Write Character at Cursor                          */
+	/* Enter:  AL = character                             */
+	/*         BH = display page number                   */
+	/*         BL = colour                                */
+	/*         CX = replication count                     */
+	/* Leave:  Nothing                                    */
+	/* Not Implemented                                    */
+	{                                         /* Localise */
+	    xf86DrvMsgVerb(pInt->scrnIndex, X_NOT_IMPLEMENTED, 2,
+		"int 0x%2.2x(AH=0x0A) -- Write Character at Cursor\n",
+		pInt->num);
+	    xf86DrvMsgVerb(pInt->scrnIndex, X_NOT_IMPLEMENTED, 3,
+		"AL=0x%2.2x, BH=0x%2.2x, BL=0x%2.2x, CX=0x%4.4x\n",
+		X86_AL, X86_BH, X86_BL, X86_CX);
+	    if (xf86GetVerbosity() > 3) {
+		dump_registers(pInt);
+		stack_trace(pInt);
+	    }
+	}
+	break;
+
+    case 0x0b:
+	/* Set Palette, Background or Border                  */
+	/* Enter:  BH = 0x00 or 0x01                          */
+	/*         BL = colour or palette (respectively)      */
+	/* Leave:  Nothing                                    */
+	/* Implemented                                        */
+	{                                         /* Localise */
+	    CARD16 ioport = MEM_RW(pInt, 0x0463) + 5;
+	    CARD8 cgacolour = MEM_RB(pInt, 0x0466);
+
+	    if (X86_BH) {
+		cgacolour &= 0xDF;
+		cgacolour |= (X86_BL & 0x01) << 5;
+	    } else {
+		cgacolour &= 0xE0;
+		cgacolour |= X86_BL & 0x1F;
+	    }
+
+	    MEM_WB(pInt, 0x0466, cgacolour);
+	    outb(ioport, cgacolour);
+	}
+	break;
+
+    case 0x0c:
+	/* Write Graphics Pixel                               */
+	/* Enter:  AL = pixel value                           */
+	/*         BH = display page number                   */
+	/*         CX = column                                */
+	/*         DX = row                                   */
+	/* Leave:  Nothing                                    */
+	/* Not Implemented                                    */
+	{                                         /* Localise */
+	    xf86DrvMsgVerb(pInt->scrnIndex, X_NOT_IMPLEMENTED, 2,
+		"int 0x%2.2x(AH=0x0C) -- Write Graphics Pixel\n", pInt->num);
+	    xf86DrvMsgVerb(pInt->scrnIndex, X_NOT_IMPLEMENTED, 3,
+		"AL=0x%2.2x, BH=0x%2.2x, CX=0x%4.4x, DX=0x%4.4x\n",
+		X86_AL, X86_BH, X86_CX, X86_DX);
+	    if (xf86GetVerbosity() > 3) {
+		dump_registers(pInt);
+		stack_trace(pInt);
+	    }
+	}
+	break;
+
+    case 0x0d:
+	/* Read Graphics Pixel                                */
+	/* Enter:  BH = display page number                   */
+	/*         CX = column                                */
+	/*         DX = row                                   */
+	/* Leave:  AL = pixel value                           */
+	/* Not Implemented                                    */
+	{                                         /* Localise */
+	    xf86DrvMsgVerb(pInt->scrnIndex, X_NOT_IMPLEMENTED, 2,
+		"int 0x%2.2x(AH=0x0D) -- Read Graphics Pixel\n", pInt->num);
+	    xf86DrvMsgVerb(pInt->scrnIndex, X_NOT_IMPLEMENTED, 3,
+		"BH=0x%2.2x, CX=0x%4.4x, DX=0x%4.4x\n",
+		X86_BH, X86_CX, X86_DX);
+	    if (xf86GetVerbosity() > 3) {
+		dump_registers(pInt);
+		stack_trace(pInt);
+	    }
+	    X86_AL = 0;
+	}
+	break;
+
+    case 0x0e:
+	/* Write Character in Teletype Mode                   */
+	/* Enter:  AL = character                             */
+	/*         BH = display page number                   */
+	/*         BL = foreground colour                     */
+	/* Leave:  Nothing                                    */
+	/* Not Implemented                                    */
+	/* WARNING:  Emulation of BEL characters will require */
+	/*           emulation of RTC and PC speaker I/O.     */
+	/*           Also, this recurses through int 0x10     */
+	/*           which might or might not have been       */
+	/*           installed yet.                           */
+	{                                         /* Localise */
+	    xf86DrvMsgVerb(pInt->scrnIndex, X_NOT_IMPLEMENTED, 2,
+		"int 0x%2.2x(AH=0x0E) -- Write Character in Teletype Mode\n",
+		pInt->num);
+	    xf86DrvMsgVerb(pInt->scrnIndex, X_NOT_IMPLEMENTED, 3,
+		"AL=0x%2.2x, BH=0x%2.2x, BL=0x%2.2x\n",
+		X86_AL, X86_BH, X86_BL);
+	    if (xf86GetVerbosity() > 3) {
+		dump_registers(pInt);
+		stack_trace(pInt);
+	    }
+	}
+	break;
+
+    case 0x0f:
+	/* Get Video Mode                                     */
+	/* Enter:  Nothing                                    */
+	/* Leave:  AH = number of columns                     */
+	/*         AL = video mode number                     */
+	/*         BH = display page number                   */
+	/* Implemented                                        */
+	{                                         /* Localise */
+	    X86_AH = MEM_RW(pInt, 0x044A);
+	    X86_AL = MEM_RB(pInt, 0x0449);
+	    X86_BH = MEM_RB(pInt, 0x0462);
+	}
+	break;
 
-    if (getIntVect(pInt,num) != I_S_DEFAULT_INT_VECT) {
-	return 0;
-    }
-    
-    if ((X86_EBX & 0xff) == 0x32) {
-	switch (X86_EAX & 0xFFFF) {
-	case 0x1200:
-#ifdef PRINT_INT
-	    ErrorF("enabling video\n");
-#endif
-#ifdef DO_GENERIC_INT10
-	    c = inb(0x3cc);
-	    c |= 0x02;
-	    outb(0x3c2,c);
-#endif
-	    return 1;
-	case 0x1201:
-#ifdef PRINT_INT
-	    ErrorF("disabling video\n");
-#endif
-#ifdef DO_GENERIC_INT10
-	    c = inb(0x3cc);
-	    c &= ~0x02;
-	    outb(0x3c2,c);
-#endif
-	    return 1;
-	default:
-	    break;
+    case 0x10:
+	/* Colour Control (subfunction in AL)                 */
+	/* Enter:  Various                                    */
+	/* Leave:  Various                                    */
+	/* Ignored                                            */
+	break;
+
+    case 0x11:
+	/* Font Control (subfunction in AL)                   */
+	/* Enter:  Various                                    */
+	/* Leave:  Various                                    */
+	/* Ignored                                            */
+	break;
+
+    case 0x12:
+	/* Miscellaneous (subfunction in BL)                  */
+	/* Enter:  Various                                    */
+	/* Leave:  Various                                    */
+	/* Ignored.  Previous code here optionally allowed    */
+	/* the enabling and disabling of VGA, but no system   */
+	/* BIOS I've come across actually implements it.      */
+	break;
+
+    case 0x13:
+	/* Write String in Teletype Mode                      */
+	/* Enter:  AL = write mode                            */
+	/*         BL = attribute (if (AL & 0x02) == 0)       */
+	/*         CX = string length                         */
+	/*         DH = row                                   */
+	/*         DL = column                                */
+	/*         ES:BP = string segment:offset              */
+	/* Leave:  Nothing                                    */
+	/* Not Implemented                                    */
+	/* WARNING:  Emulation of BEL characters will require */
+	/*           emulation of RTC and PC speaker I/O.     */
+	/*           Also, this recurses through int 0x10     */
+	/*           which might or might not have been       */
+	/*           installed yet.                           */
+	{                                         /* Localise */
+	    xf86DrvMsgVerb(pInt->scrnIndex, X_NOT_IMPLEMENTED, 2,
+		"int 0x%2.2x(AH=0x13) -- Write String in Teletype Mode\n",
+		pInt->num);
+	    xf86DrvMsgVerb(pInt->scrnIndex, X_NOT_IMPLEMENTED, 3,
+		"AL=0x%2.2x, BL=0x%2.2x, CX=0x%4.4x,"
+		" DH=0x%2.2x, DL=0x%2.2x, ES:BP=0x%4.4x:0x%4.4x\n",
+		X86_AL, X86_BL, X86_CX, X86_DH, X86_DL, X86_ES, X86_BP);
+	    if (xf86GetVerbosity() > 3) {
+		dump_registers(pInt);
+		stack_trace(pInt);
+	    }
 	}
+	break;
+
+    default:
+	/* Various extensions */
+	/* Enter:  Various                                    */
+	/* Leave:  Various                                    */
+	/* Ignored */
+	break;
     }
-    if (num == 0x42)
-	return 1;
-    else
-	return 0;
+
+    return 1;
 }
+#endif
 
 #define SUCCESSFUL              0x00
 #define DEVICE_NOT_FOUND        0x86
@@ -118,164 +590,159 @@
 {
     PCITAG tag;
     pciVideoPtr pvp;
-    
-    if (! (pvp = xf86GetPciInfoForEntity(pInt->entityIndex)))
+
+    if (!(pvp = xf86GetPciInfoForEntity(pInt->entityIndex)))
 	return 0; /* oops */
 
 #ifdef PRINT_INT
     ErrorF("int 0x1a: ax=0x%x bx=0x%x cx=0x%x dx=0x%x di=0x%x es=0x%x\n",
-	    X86_EAX,X86_EBX,X86_ECX,X86_EDX,X86_EDI,X86_ESI);
+	    X86_EAX, X86_EBX, X86_ECX, X86_EDX, X86_EDI, X86_ESI);
 #endif
-    switch (X86_EAX & 0xFFFF) {
+    switch (X86_AX) {
     case 0xb101:
-	X86_EAX  &= 0xFF00;   /* no config space/special cycle support */
+	X86_EAX &= 0xFF00;   /* no config space/special cycle support */
 	X86_EDX = 0x20494350; /* " ICP" */
-	X86_EBX  = 0x0210;    /* Version 2.10 */
-	X86_ECX  &= 0xFF00;
+	X86_EBX = 0x0210;    /* Version 2.10 */
+	X86_ECX &= 0xFF00;
 	X86_ECX |= (pciNumBuses & 0xFF);   /* Max bus number in system */
 	X86_EFLAGS &= ~((unsigned long)0x01); /* clear carry flag */
 #ifdef PRINT_INT
 	ErrorF("ax=0x%x dx=0x%x bx=0x%x cx=0x%x flags=0x%x\n",
-		 X86_EAX,X86_EDX,X86_EBX,X86_ECX,X86_EFLAGS);
+		 X86_EAX, X86_EDX, X86_EBX, X86_ECX, X86_EFLAGS);
 #endif
 	return 1;
     case 0xb102:
-	if ((X86_EDX & 0xFFFF) == pvp->vendor &&
-	    (X86_ECX & 0xFFFF) ==pvp->chipType &&
-	    X86_ESI == 0) {
-	    X86_EAX = (X86_EAX & 0x00FF) | (SUCCESSFUL << 8);
+	if (X86_DX == pvp->vendor && X86_CX == pvp->chipType && X86_ESI == 0) {
+	    X86_EAX = X86_AL | (SUCCESSFUL << 8);
 	    X86_EFLAGS &= ~((unsigned long)0x01); /* clear carry flag */
-	    X86_EBX = pciSlotBX(pvp); 
+	    X86_EBX = pciSlotBX(pvp);
 	}
 #ifdef SHOW_ALL_DEVICES
-	else if ((pvp = xf86FindPciDeviceVendor(X86_EDX,X86_ECX,X86_ESI,pvp))
-		 != NULL) {
-	    X86_EAX = (X86_EAX & 0x00FF) | (SUCCESSFUL << 8);
+	else
+	if ((pvp = xf86FindPciDeviceVendor(X86_EDX, X86_ECX, X86_ESI, pvp))) {
+	    X86_EAX = X86_AL | (SUCCESSFUL << 8);
 	    X86_EFLAGS &= ~((unsigned long)0x01); /* clear carry flag */
 	    X86_EBX = pciSlotBX(pvp);
 	}
 #endif
 	else {
-	    X86_EAX = (X86_EAX & 0x00FF) | (DEVICE_NOT_FOUND << 8);
+	    X86_EAX = X86_AL | (DEVICE_NOT_FOUND << 8);
 	    X86_EFLAGS |= ((unsigned long)0x01); /* set carry flag */
 	}
 #ifdef PRINT_INT
-	ErrorF("ax=0x%x bx=0x%x flags=0x%x\n",
-		 X86_EAX,X86_EBX,X86_EFLAGS);
+	ErrorF("ax=0x%x bx=0x%x flags=0x%x\n", X86_EAX, X86_EBX, X86_EFLAGS);
 #endif
 	return 1;
     case 0xb103:
-	if ((X86_ECX & 0xFF) == pvp->interface &&
-	    ((X86_ECX & 0xFF00) >> 8) == pvp->subclass &&
+	if (X86_CL == pvp->interface &&
+	    X86_CH == pvp->subclass &&
 	    ((X86_ECX & 0xFFFF0000) >> 16) == pvp->class) {
-	    X86_EAX = (X86_EAX & 0x00FF) | (SUCCESSFUL << 8);
+	    X86_EAX = X86_AL | (SUCCESSFUL << 8);
 	    X86_EBX = pciSlotBX(pvp);
 	    X86_EFLAGS &= ~((unsigned long)0x01); /* clear carry flag */
 	}
 #ifdef SHOW_ALL_DEVICES
-	else if ((pvp = xf86FindPciClass(X86_ECX & 0xFF,
-					 (X86_ECX & 0xff00) >> 8,
+	else if ((pvp = xf86FindPciClass(X86_CL, X86_CH,
 					 (X86_ECX & 0xffff0000) >> 16,
-					 X86_ESI,pvp))!= NULL) {
-	    X86_EAX = (X86_EAX & 0x00FF) | (SUCCESSFUL << 8);
+					 X86_ESI, pvp))) {
+	    X86_EAX = X86_AL | (SUCCESSFUL << 8);
 	    X86_EFLAGS &= ~((unsigned long)0x01); /* clear carry flag */
 	    X86_EBX = pciSlotBX(pvp);
 	}
 #endif
 	else {
-	    X86_EAX = (X86_EAX & 0x00FF) | (DEVICE_NOT_FOUND << 8);
+	    X86_EAX = X86_AL | (DEVICE_NOT_FOUND << 8);
 	    X86_EFLAGS |= ((unsigned long)0x01); /* set carry flag */
 	}
 #ifdef PRINT_INT
-	ErrorF("ax=0x%x flags=0x%x\n",X86_EAX,X86_EFLAGS);
+	ErrorF("ax=0x%x flags=0x%x\n", X86_EAX, X86_EFLAGS);
 #endif
 	return 1;
     case 0xb108:
 	if ((tag = findPci(X86_EBX))) {
-	    X86_ECX &= 0xFFFFFF00;
-	    X86_ECX |= pciReadByte(tag,X86_EDI); 
-	    X86_EAX = (X86_EAX & 0x00FF) | (SUCCESSFUL << 8);
+	    X86_CL = pciReadByte(tag, X86_EDI);
+	    X86_EAX = X86_AL | (SUCCESSFUL << 8);
 	    X86_EFLAGS &= ~((unsigned long)0x01); /* clear carry flag */
 	} else {
-	    X86_EAX = (X86_EAX & 0x00FF) | (BAD_REGISTER_NUMBER << 8);
+	    X86_EAX = X86_AL | (BAD_REGISTER_NUMBER << 8);
 	    X86_EFLAGS |= ((unsigned long)0x01); /* set carry flag */
 	}
 #ifdef PRINT_INT
-	ErrorF("ax=0x%x cx=0x%x flags=0x%x\n",
-		 X86_EAX,X86_ECX,X86_EFLAGS);
+	ErrorF("ax=0x%x cx=0x%x flags=0x%x\n", X86_EAX, X86_ECX, X86_EFLAGS);
 #endif
 	return 1;
     case 0xb109:
 	if ((tag = findPci(X86_EBX))) {
-	    X86_ECX &= 0xFFFF0000;
-	    X86_ECX |= pciReadWord(tag,X86_EDI);
-	    X86_EAX = (X86_EAX & 0x00FF) | (SUCCESSFUL << 8);
+	    X86_CX = pciReadWord(tag, X86_EDI);
+	    X86_EAX = X86_AL | (SUCCESSFUL << 8);
 	    X86_EFLAGS &= ~((unsigned long)0x01); /* clear carry flag */
 	} else {
-	    X86_EAX = (X86_EAX & 0x00FF) | (BAD_REGISTER_NUMBER << 8);
+	    X86_EAX = X86_AL | (BAD_REGISTER_NUMBER << 8);
 	    X86_EFLAGS |= ((unsigned long)0x01); /* set carry flag */
 	}
 #ifdef PRINT_INT
-	ErrorF("ax=0x%x cx=0x%x flags=0x%x\n",
-		 X86_EAX,X86_ECX,X86_EFLAGS);
+	ErrorF("ax=0x%x cx=0x%x flags=0x%x\n", X86_EAX, X86_ECX, X86_EFLAGS);
 #endif
 	return 1;
     case 0xb10a:
 	if ((tag = findPci(X86_EBX))) {
-	    X86_ECX &= 0;
-	    X86_ECX |= pciReadLong(tag, X86_EDI);
-	    X86_EAX = (X86_EAX & 0x00FF) | (SUCCESSFUL << 8);
+	    X86_ECX = pciReadLong(tag, X86_EDI);
+	    X86_EAX = X86_AL | (SUCCESSFUL << 8);
 	    X86_EFLAGS &= ~((unsigned long)0x01); /* clear carry flag */
 	} else {
-	    X86_EAX = (X86_EAX & 0x00FF) | (BAD_REGISTER_NUMBER << 8);
+	    X86_EAX = X86_AL | (BAD_REGISTER_NUMBER << 8);
 	    X86_EFLAGS |= ((unsigned long)0x01); /* set carry flag */
 	}
 #ifdef PRINT_INT
-	ErrorF("ax=0x%x cx=0x%x flags=0x%x\n",
-		 X86_EAX,X86_ECX,X86_EFLAGS);
+	ErrorF("ax=0x%x cx=0x%x flags=0x%x\n", X86_EAX, X86_ECX, X86_EFLAGS);
 #endif
 	return 1;
     case 0xb10b:
 	if ((tag = findPci(X86_EBX))) {
-	    pciWriteByte(tag,X86_EDI,(CARD8)X86_ECX);
-	    X86_EAX = (X86_EAX & 0x00FF) | (SUCCESSFUL << 8);
+	    pciWriteByte(tag, X86_EDI, X86_CL);
+	    X86_EAX = X86_AL | (SUCCESSFUL << 8);
 	    X86_EFLAGS &= ~((unsigned long)0x01); /* clear carry flag */
 	} else {
-	    X86_EAX = (X86_EAX & 0x00FF) | (BAD_REGISTER_NUMBER << 8);
+	    X86_EAX = X86_AL | (BAD_REGISTER_NUMBER << 8);
 	    X86_EFLAGS |= ((unsigned long)0x01); /* set carry flag */
 	}
 #ifdef PRINT_INT
-	ErrorF("ax=0x%x flags=0x%x\n", X86_EAX,X86_EFLAGS);
+	ErrorF("ax=0x%x flags=0x%x\n", X86_EAX, X86_EFLAGS);
 #endif
 	return 1;
     case 0xb10c:
 	if ((tag = findPci(X86_EBX))) {
-	    pciWriteWord(tag,X86_EDI,(CARD16)X86_ECX);
-	    X86_EAX = (X86_EAX & 0x00FF) | (SUCCESSFUL << 8);
+	    pciWriteWord(tag, X86_EDI, X86_CX);
+	    X86_EAX = X86_AL | (SUCCESSFUL << 8);
 	    X86_EFLAGS &= ~((unsigned long)0x01); /* clear carry flag */
 	} else {
-	    X86_EAX = (X86_EAX & 0x00FF) | (BAD_REGISTER_NUMBER << 8);
+	    X86_EAX = X86_AL | (BAD_REGISTER_NUMBER << 8);
 	    X86_EFLAGS |= ((unsigned long)0x01); /* set carry flag */
 	}
 #ifdef PRINT_INT
-	ErrorF("ax=0x%x flags=0x%x\n", X86_EAX,X86_EFLAGS);
+	ErrorF("ax=0x%x flags=0x%x\n", X86_EAX, X86_EFLAGS);
 #endif
 	return 1;
     case 0xb10d:
 	if ((tag = findPci(X86_EBX))) {
-	    pciWriteLong(tag,X86_EDI,(CARD32)X86_ECX);
-	    X86_EAX = (X86_EAX & 0x00FF) | (SUCCESSFUL << 8);
+	    pciWriteLong(tag, X86_EDI, X86_ECX);
+	    X86_EAX = X86_AL | (SUCCESSFUL << 8);
 	    X86_EFLAGS &= ~((unsigned long)0x01); /* clear carry flag */
 	} else {
-	    X86_EAX = (X86_EAX & 0x00FF) | (BAD_REGISTER_NUMBER << 8);
+	    X86_EAX = X86_AL | (BAD_REGISTER_NUMBER << 8);
 	    X86_EFLAGS |= ((unsigned long)0x01); /* set carry flag */
 	}
 #ifdef PRINT_INT
-	ErrorF("ax=0x%x flags=0x%x\n", X86_EAX,X86_EFLAGS);
+	ErrorF("ax=0x%x flags=0x%x\n", X86_EAX, X86_EFLAGS);
 #endif
 	return 1;
     default:
-	return 0;
+	xf86DrvMsgVerb(pInt->scrnIndex, X_NOT_IMPLEMENTED, 2,
+	    "int 0x1a subfunction\n");
+	dump_registers(pInt);
+	if (xf86GetVerbosity() > 3)
+	    stack_trace(pInt);
+	return 1;
     }
 }
 
@@ -285,15 +752,15 @@
     int bus = (bx >> 8) & 0xFF;
     int dev = (bx >> 3) & 0x1F;
     int func = bx & 0x7;
-    if (xf86IsPciDevPresent(bus,dev,func))
-	return pciTag(bus,dev,func);
+    if (xf86IsPciDevPresent(bus, dev, func))
+	return pciTag(bus, dev, func);
     return 0;
 }
 
 static CARD32
 pciSlotBX(pciVideoPtr pvp)
 {
-    return ((pvp->bus << 8) | (pvp->device << 3) | (pvp->func));
+    return (pvp->bus << 8) | (pvp->device << 3) | (pvp->func);
 }
 
 /*
@@ -304,12 +771,10 @@
 {
     pciVideoPtr pvp;
 
-    if ((pvp = xf86GetPciInfoForEntity(pInt->entityIndex))) {
-	X86_AX = (CARD16)(((pvp->bus) << 8)
-		      | (pvp->device << 3) | (pvp->func & 0x7));
-    }
-    pushw(pInt,X86_CS);
-    pushw(pInt,(CARD16)X86_EIP);
+    if ((pvp = xf86GetPciInfoForEntity(pInt->entityIndex)))
+	X86_AX = (pvp->bus << 8) | (pvp->device << 3) | (pvp->func & 0x7);
+    pushw(pInt, X86_CS);
+    pushw(pInt, X86_IP);
     X86_CS = pInt->BIOSseg;
     X86_EIP = 0x0003;
     X86_ES = 0;                  /* standard pc es */
Index: XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/int10/xf86int10.h
===================================================================
RCS file: /cvs/xc/programs/Xserver/hw/xfree86/int10/xf86int10.h,v
retrieving revision 1.15
retrieving revision 1.16
diff -u -r1.15 -r1.16
--- XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/int10/xf86int10.h	2000/12/06 18:08:55	1.15
+++ XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/int10/xf86int10.h	2001/01/06 20:19:13	1.16
@@ -1,4 +1,4 @@
-/* $XFree86: xc/programs/Xserver/hw/xfree86/int10/xf86int10.h,v 1.15 2000/12/06 18:08:55 eich Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/int10/xf86int10.h,v 1.16 2001/01/06 20:19:13 tsi Exp $ */
 
 /*
  *                   XFree86 int10 module
@@ -12,11 +12,11 @@
 #include "Xmd.h"
 #include "Xdefs.h"
 
-#define SEG_ADDR(x) ((x>>4) & 0xF000)
-#define SEG_OFF(x) (x & 0xFFFF)
+#define SEG_ADDR(x) (((x) >> 4) & 0x00F000)
+#define SEG_OFF(x) ((x) & 0x0FFFF)
 
 /* int10 info structure */
-typedef  struct  {
+typedef struct {
     int entityIndex;
     int scrnIndex;
     pointer cpuRegs;
@@ -33,15 +33,16 @@
     int es;
     int bp;
     int flags;
-    } xf86Int10InfoRec, *xf86Int10InfoPtr;
+    int stackseg;
+} xf86Int10InfoRec, *xf86Int10InfoPtr;
 
 typedef struct _int10Mem {
-    CARD8(*rb)(xf86Int10InfoPtr,int);
-    CARD16(*rw)(xf86Int10InfoPtr,int);
-    CARD32(*rl)(xf86Int10InfoPtr,int);
-    void(*wb)(xf86Int10InfoPtr,int,CARD8);
-    void(*ww)(xf86Int10InfoPtr,int,CARD16);
-    void(*wl)(xf86Int10InfoPtr,int,CARD32);
+    CARD8(*rb)(xf86Int10InfoPtr, int);
+    CARD16(*rw)(xf86Int10InfoPtr, int);
+    CARD32(*rl)(xf86Int10InfoPtr, int);
+    void(*wb)(xf86Int10InfoPtr, int, CARD8);
+    void(*ww)(xf86Int10InfoPtr, int, CARD16);
+    void(*wl)(xf86Int10InfoPtr, int, CARD32);
 } int10MemRec, *int10MemPtr;
 
 typedef struct {
@@ -54,7 +55,7 @@
 /* OS dependent functions */
 xf86Int10InfoPtr xf86InitInt10(int entityIndex);
 void xf86FreeInt10(xf86Int10InfoPtr pInt);
-void * xf86Int10AllocPages(xf86Int10InfoPtr pInt,int num, int *off);
+void *xf86Int10AllocPages(xf86Int10InfoPtr pInt, int num, int *off);
 void xf86Int10FreePages(xf86Int10InfoPtr pInt, void *pbase, int num);
 pointer xf86int10Addr(xf86Int10InfoPtr pInt, CARD32 addr);
 
@@ -78,23 +79,25 @@
 #define V_BIOS 0xC0000
 #define HIGH_MEM V_BIOS
 #define HIGH_MEM_SIZE (SYS_BIOS - HIGH_MEM)
+#define SEG_ADR(type, seg, reg)  type((seg << 4) + (X86_##reg))
+#define SEG_EADR(type, seg, reg) type((seg << 4) + (X86_E##reg))
 
 #define X86_TF_MASK		0x00000100
 #define X86_IF_MASK		0x00000200
-#define X86_IOPL_MASK	        0x00003000
+#define X86_IOPL_MASK		0x00003000
 #define X86_NT_MASK		0x00004000
 #define X86_VM_MASK		0x00020000
 #define X86_AC_MASK		0x00040000
-#define X86_VIF_MASK	        0x00080000	/* virtual interrupt flag */
-#define X86_VIP_MASK	        0x00100000	/* virtual interrupt pending */
+#define X86_VIF_MASK		0x00080000	/* virtual interrupt flag */
+#define X86_VIP_MASK		0x00100000	/* virtual interrupt pending */
 #define X86_ID_MASK		0x00200000
 
-#define MEM_RB(name,addr) name->mem->rb(name,addr)
-#define MEM_RW(name,addr) name->mem->rw(name,addr)
-#define MEM_RL(name,addr) name->mem->rl(name,addr)
-#define MEM_WB(name,addr,val) name->mem->wb(name,addr,val)
-#define MEM_WW(name,addr,val) name->mem->ww(name,addr,val)
-#define MEM_WL(name,addr,val) name->mem->wl(name,addr,val)
+#define MEM_RB(name, addr)      (*name->mem->rb)(name, addr)
+#define MEM_RW(name, addr)      (*name->mem->rw)(name, addr)
+#define MEM_RL(name, addr)      (*name->mem->rl)(name, addr)
+#define MEM_WB(name, addr, val) (*name->mem->wb)(name, addr, val)
+#define MEM_WW(name, addr, val) (*name->mem->ww)(name, addr, val)
+#define MEM_WL(name, addr, val) (*name->mem->wl)(name, addr, val)
 
 /* OS dependent functions */
 void MapCurrentInt10(xf86Int10InfoPtr pInt);
@@ -108,8 +111,7 @@
 /* helper_exec.c */
 int setup_int(xf86Int10InfoPtr pInt);
 void finish_int(xf86Int10InfoPtr, int sig);
-CARD32 getIntVect(xf86Int10InfoPtr pInt,int num);
-int vm86_GP_fault(xf86Int10InfoPtr pInt);
+CARD32 getIntVect(xf86Int10InfoPtr pInt, int num);
 void pushw(xf86Int10InfoPtr pInt, CARD16 val);
 int run_bios_int(int num, xf86Int10InfoPtr pInt);
 void dump_code(xf86Int10InfoPtr pInt);
@@ -117,7 +119,7 @@
 void stack_trace(xf86Int10InfoPtr pInt);
 xf86Int10InfoPtr getInt10Rec(int entityIndex);
 CARD8 bios_checksum(CARD8 *start, int size);
-void LockLegacyVGA(int screenIndex,legacyVGAPtr vga);
+void LockLegacyVGA(int screenIndex, legacyVGAPtr vga);
 void UnlockLegacyVGA(int screenIndex, legacyVGAPtr vga);
 int port_rep_inb(xf86Int10InfoPtr pInt,
 		 CARD16 port, CARD32 base, int d_f, CARD32 count);
@@ -139,30 +141,12 @@
 CARD32 x_inl(CARD16 port);
 void x_outl(CARD16 port, CARD32 val);
 
-#ifndef _INT10_NO_INOUT_MACROS
-#if defined(PRINT_PORT) || (!defined(_PC) && !defined(_PC_IO))
-# define p_inb x_inb
-# define p_inw x_inw
-# define p_outb x_outb
-# define p_outw x_outw
-# define p_inl x_inl
-# define p_outl x_outl
-#else 
-# define p_inb inb
-# define p_inw inw
-# define p_outb outb
-# define p_outw outw
-# define p_inl inl
-# define p_outl outl
-#endif
-#endif
-
 CARD8 Mem_rb(int addr);
 CARD16 Mem_rw(int addr);
 CARD32 Mem_rl(int addr);
-void Mem_wb(int addr,CARD8 val);
-void Mem_ww(int addr,CARD16 val);
-void Mem_wl(int addr,CARD32 val);
+void Mem_wb(int addr, CARD8 val);
+void Mem_ww(int addr, CARD16 val);
+void Mem_wl(int addr, CARD32 val);
 
 /* helper_mem.c */
 void setup_int_vect(xf86Int10InfoPtr pInt);
@@ -177,9 +161,7 @@
 #endif
 
 /* pci.c */
-int mapPciRom(xf86Int10InfoPtr pInt, unsigned char * address);
+int mapPciRom(xf86Int10InfoPtr pInt, unsigned char *address);
 
 #endif /* _INT10_PRIVATE */
 #endif /* _XF86INT10_H */
-
-
Index: XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/int10/xf86x86emu.c
===================================================================
RCS file: /cvs/xc/programs/Xserver/hw/xfree86/int10/xf86x86emu.c,v
retrieving revision 1.9
retrieving revision 1.10
diff -u -r1.9 -r1.10
--- XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/int10/xf86x86emu.c	2000/12/06 15:35:26	1.9
+++ XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/int10/xf86x86emu.c	2001/01/06 20:19:13	1.10
@@ -1,4 +1,4 @@
-/* $XFree86: xc/programs/Xserver/hw/xfree86/int10/xf86x86emu.c,v 1.9 2000/12/06 15:35:26 eich Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/int10/xf86x86emu.c,v 1.10 2001/01/06 20:19:13 tsi Exp $ */
 /*
  *                   XFree86 int10 module
  *   execute BIOS int 10h calls in x86 real mode environment
@@ -6,128 +6,65 @@
  */
 #include <x86emu.h>
 #include "xf86.h"
-#include "xf86str.h"
 #include "xf86_ansic.h"
 #include "compiler.h"
 #include "xf86_OSproc.h"
 #include "xf86Pci.h"
 #include "xf86_libc.h"
 #define _INT10_PRIVATE
-#define _INT10_NO_INOUT_MACROS
 #include "xf86int10.h"
 #include "int10Defines.h"
 
-#define M            _X86EMU_env
+#define M _X86EMU_env
 
-#if defined(PRINT_PORT) || (!defined(_PC) && !defined(_PC_IO))
-# define p_inb x_inb
-# define p_inw x_inw
-# define p_outb x_outb
-# define p_outw x_outw
-# define p_inl x_inl
-# define p_outl x_outl
-#else
-# define p_inb f_inb
-# define p_inw f_inw
-# define p_outb f_outb
-# define p_outw f_outw
-# define p_inl f_inl
-# define p_outl f_outl
-#endif
-
-/*
- * inb/outb, etc are not available as functions (compler.h) on all
- * platforms (eg SVR4.0 with cc).  This provides versions that are guaranteed
- * to be functions.
- */
-
-static CARD8
-f_inb(CARD16 port)
-{
-    return inb(port);
-}
-
-static CARD16
-f_inw(CARD16 port)
-{
-    return inw(port);
-}
-
-static CARD32
-f_inl(CARD16 port)
-{
-    return inl(port);
-}
-
-static void
-f_outb(CARD16 port, CARD8 val)
-{
-    outb(port, val);
-}
-
-static void
-f_outw(CARD16 port, CARD16 val)
-{
-    outw(port,val);
-}
-
-static void
-f_outl(CARD16 port, CARD32 val)
-{
-    outl(port,val);
-}
-
 static void
 x86emu_do_int(int num)
 {
     Int10Current->num = num;
 
     if (!int_handler(Int10Current)) {
-	xf86DrvMsg(Int10Current->scrnIndex,
-		X_ERROR,"\nUnknown vm86_int: %X\n\n",num);
 	X86EMU_halt_sys();
     }
-    return;
 }
-    
+
 void
 xf86ExecX86int10(xf86Int10InfoPtr pInt)
 {
     int sig = setup_int(pInt);
 
     if (int_handler(pInt)) {
-	X86EMU_exec();	
+	X86EMU_exec();
     }
-    
+
     finish_int(pInt, sig);
 }
-    
+
 Bool
 xf86Int10ExecSetup(xf86Int10InfoPtr pInt)
 {
     int i;
     X86EMU_intrFuncs intFuncs[256];
     X86EMU_pioFuncs pioFuncs = {
-	(u8(*)(u16))p_inb,
-	(u16(*)(u16))p_inw,
-	(u32(*)(u16))p_inl,
-	(void(*)(u16,u8))p_outb,
-	(void(*)(u16,u16))p_outw,
-	(void(*)(u16,u32))p_outl
+	(u8(*)(u16))x_inb,
+	(u16(*)(u16))x_inw,
+	(u32(*)(u16))x_inl,
+	(void(*)(u16, u8))x_outb,
+	(void(*)(u16, u16))x_outw,
+	(void(*)(u16, u32))x_outl
     };
-    
+
     X86EMU_memFuncs memFuncs = {
 	(u8(*)(u32))Mem_rb,
 	(u16(*)(u32))Mem_rw,
 	(u32(*)(u32))Mem_rl,
-	(void(*)(u32,u8))Mem_wb,
-	(void(*)(u32,u16))Mem_ww,
-	(void(*)(u32,u32))Mem_wl
+	(void(*)(u32, u8))Mem_wb,
+	(void(*)(u32, u16))Mem_ww,
+	(void(*)(u32, u32))Mem_wl
     };
 
     X86EMU_setupMemFuncs(&memFuncs);
-    
-    pInt->cpuRegs =  &M;
+
+    pInt->cpuRegs = &M;
     M.mem_base = 0;
     M.mem_size = 1024*1024 + 1024;
     X86EMU_setupPioFuncs(&pioFuncs);
@@ -146,5 +83,3 @@
     VErrorF(fmt, argptr);
     va_end(argptr);
 }
-
-
Index: XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/int10/xf86x86emu.h
===================================================================
RCS file: /cvs/xc/programs/Xserver/hw/xfree86/int10/xf86x86emu.h,v
retrieving revision 1.1
retrieving revision 1.2
diff -u -r1.1 -r1.2
--- XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/int10/xf86x86emu.h	2000/01/23 04:44:35	1.1
+++ XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/int10/xf86x86emu.h	2001/01/06 20:19:13	1.2
@@ -1,4 +1,4 @@
-/* $XFree86: xc/programs/Xserver/hw/xfree86/int10/xf86x86emu.h,v 1.1 2000/01/23 04:44:35 dawes Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/int10/xf86x86emu.h,v 1.2 2001/01/06 20:19:13 tsi Exp $ */
 /*
  *                   XFree86 int10 module
  *   execute BIOS int 10h calls in x86 real mode environment
@@ -8,7 +8,7 @@
 #define XF86X86EMU_H_
 #include <x86emu.h>
 
-#define	M    	     _X86EMU_env
+#define M _X86EMU_env
 
 #define X86_EAX M.x86.R_EAX
 #define X86_EBX M.x86.R_EBX
@@ -37,10 +37,15 @@
 #define X86_SS M.x86.R_SS
 #define X86_FS M.x86.R_FS
 #define X86_GS M.x86.R_GS
-           
+
 #define X86_AL M.x86.R_AL
 #define X86_BL M.x86.R_BL
 #define X86_CL M.x86.R_CL
 #define X86_DL M.x86.R_DL
+
+#define X86_AH M.x86.R_AH
+#define X86_BH M.x86.R_BH
+#define X86_CH M.x86.R_CH
+#define X86_DH M.x86.R_DH
 
 #endif
Index: XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/loader/elf.h
===================================================================
RCS file: /cvs/xc/programs/Xserver/hw/xfree86/loader/elf.h,v
retrieving revision 1.9
retrieving revision 1.10
diff -u -r1.9 -r1.10
--- XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/loader/elf.h	2000/09/07 19:06:52	1.9
+++ XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/loader/elf.h	2001/01/06 20:19:13	1.10
@@ -1,11 +1,11 @@
-/* $XFree86: xc/programs/Xserver/hw/xfree86/loader/elf.h,v 1.9 2000/09/07 19:06:52 anderson Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/loader/elf.h,v 1.10 2001/01/06 20:19:13 tsi Exp $ */
 
 
-typedef unsigned long	Elf32_Addr;
+typedef unsigned int	Elf32_Addr;
 typedef unsigned short	Elf32_Half;
-typedef unsigned long	Elf32_Off;
+typedef unsigned int	Elf32_Off;
 typedef long		Elf32_Sword;
-typedef unsigned long	Elf32_Word;
+typedef unsigned int	Elf32_Word;
 
 typedef unsigned long	Elf64_Addr;
 typedef unsigned short	Elf64_Half;
Index: XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/loader/elfloader.c
===================================================================
RCS file: /cvs/xc/programs/Xserver/hw/xfree86/loader/elfloader.c,v
retrieving revision 1.31
retrieving revision 1.32
diff -u -r1.31 -r1.32
--- XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/loader/elfloader.c	2000/12/13 16:52:01	1.31
+++ XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/loader/elfloader.c	2001/01/06 20:19:14	1.32
@@ -1,4 +1,4 @@
-/* $XFree86: xc/programs/Xserver/hw/xfree86/loader/elfloader.c,v 1.31 2000/12/13 16:52:01 tsi Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/loader/elfloader.c,v 1.32 2001/01/06 20:19:14 tsi Exp $ */
 
 /*
  *
@@ -61,7 +61,11 @@
 #endif
 #endif
 
-#if defined (__alpha__) || defined (__ia64__) || (defined (__sparc__) && (defined (__arch64__) || defined (__sparcv9)))
+#if defined (__alpha__) || \
+    defined (__ia64__) || \
+    (defined (__sparc__) && \
+     (defined (__arch64__) || \
+      defined (__sparcv9)))
 typedef Elf64_Ehdr Elf_Ehdr;
 typedef Elf64_Shdr Elf_Shdr;
 typedef Elf64_Sym Elf_Sym;
@@ -135,6 +139,16 @@
 #define ELF_R_TYPE ELF32_R_TYPE
 #endif
 
+#if defined(__powerpc__) || \
+    defined(__mc68000__) || \
+    defined(__alpha__) || \
+    defined(__sparc__) || \
+    defined(__ia64__)
+typedef Elf_Rela Elf_Rel_t;
+#else
+typedef Elf_Rel  Elf_Rel_t;
+#endif
+
 /*
  * This structure contains all of the information about a module
  * that has been loaded.
@@ -222,12 +236,7 @@
  * to try later after more modules have been loaded.
  */
 typedef struct _elf_reloc {
-#if defined(i386)
-	Elf_Rel	*rel;
-#endif
-#if defined(__powerpc__) || defined(__mc68000__) || defined(__alpha__) || defined(__sparc__) || defined(__ia64__)
-	Elf_Rela	*rel;
-#endif
+	Elf_Rel_t	*rel;
 	ELFModulePtr	file;
 	unsigned char	*secp;
 	struct _elf_reloc	*next;
@@ -251,33 +260,25 @@
 static char *ElfGetStringIndex(ELFModulePtr, int, int);
 static char *ElfGetString(ELFModulePtr, int);
 static char *ElfGetSectionName(ELFModulePtr, int);
-#if defined(__powerpc__) || defined(__mc68000__) || defined(__alpha__) || defined(__sparc__) || defined(__ia64__)
-static ELFRelocPtr ElfDelayRelocation(ELFModulePtr, unsigned char *, Elf_Rela *);
-#else
-static ELFRelocPtr ElfDelayRelocation(ELFModulePtr, unsigned char *, Elf_Rel *);
-#endif
+static ELFRelocPtr ElfDelayRelocation(ELFModulePtr, unsigned char *, Elf_Rel_t *);
 static ELFCommonPtr ElfAddCOMMON(Elf_Sym *);
 static int ElfCOMMONSize(void);
 static int ElfCreateCOMMON(ELFModulePtr,LOOKUP *);
 static char *ElfGetSymbolNameIndex(ELFModulePtr, int, int);
 static char *ElfGetSymbolName(ELFModulePtr, int);
 static Elf_Addr ElfGetSymbolValue(ELFModulePtr, int);
-#if defined(__powerpc__) || defined(__mc68000__) || defined(__alpha__) || defined(__sparc__) || defined(__ia64__)
-static ELFRelocPtr Elf_RelocateEntry(ELFModulePtr, unsigned char *, Elf_Rela *, int);
-#else
-static ELFRelocPtr Elf_RelocateEntry(ELFModulePtr, unsigned char *, Elf_Rel *, int);
-#endif
+static ELFRelocPtr Elf_RelocateEntry(ELFModulePtr, unsigned char *, Elf_Rel_t *, int);
 static ELFRelocPtr ELFCollectRelocations(ELFModulePtr, int);
 static LOOKUP *ELF_GetSymbols(ELFModulePtr, unsigned short **);
 static void ELFCollectSections(ELFModulePtr, int, int *, int *);
 #if defined(__alpha__) || defined(__ia64__)
-static void ElfAddGOT(ELFModulePtr, Elf_Rela *);
+static void ElfAddGOT(ELFModulePtr, Elf_Rel_t *);
 static int ELFCreateGOT(ELFModulePtr, int);
 #endif
 #if defined(__ia64__)
 static void ElfAddOPD(ELFModulePtr, int, LOOKUP *);
 static void ELFCreateOPD(ELFModulePtr);
-static void ElfAddPLT(ELFModulePtr, Elf_Rela *);
+static void ElfAddPLT(ELFModulePtr, Elf_Rel_t *);
 static void ELFCreatePLT(ELFModulePtr);
 enum ia64_operand {
     IA64_OPND_IMM22,
@@ -343,12 +344,7 @@
 ElfDelayRelocation(elffile,secp,rel)
 ELFModulePtr	elffile;
 unsigned char	*secp;
-#if defined(i386)
-Elf_Rel	*rel;
-#endif
-#if defined(__powerpc__) || defined(__mc68000__) || defined(__alpha__) || defined(__sparc__) || defined(__ia64__)
-Elf_Rela	*rel;
-#endif
+Elf_Rel_t	*rel;
 {
     ELFRelocPtr	reloc;
 
@@ -361,11 +357,17 @@
     reloc->rel=rel;
     reloc->next=0;
 #ifdef ELFDEBUG
-    ELFDEBUG("ElfDelayRelocation %lx: file %lx, sec %lx, r_offset 0x%x, r_info 0x%x", reloc, elffile, secp, rel->r_offset, rel->r_info);
-#if defined(__powerpc__) || defined(__mc68000__) || defined(__alpha__) || defined(__sparc__) || defined(__ia64__)
-    ELFDEBUG(", r_addend 0x%x", rel->r_addend);
+    ELFDEBUG("ElfDelayRelocation %lx: file %lx, sec %lx,"
+	     " r_offset 0x%lx, r_info 0x%x",
+	     reloc, elffile, secp, rel->r_offset, rel->r_info);
+#if defined(__powerpc__) || \
+    defined(__mc68000__) || \
+    defined(__alpha__) || \
+    defined(__sparc__) || \
+    defined(__ia64__)
+    ELFDEBUG(", r_addend 0x%lx", rel->r_addend);
 #endif
-    ELFDEBUG("\n" );
+    ELFDEBUG("\n");
 #endif
     return reloc;
 }
@@ -396,7 +398,11 @@
 
     for (common = listCOMMON; common; common = common->next) {
 	size+=common->sym->st_size;
-#if defined(__alpha__) || defined(__ia64__) || (defined(__sparc__) && (defined(__arch64__) || defined(__sparcv9)))
+#if defined(__alpha__) || \
+    defined(__ia64__) || \
+    (defined(__sparc__) && \
+     (defined(__arch64__) || \
+      defined(__sparcv9)))
 	size = (size+7)&~0x7;
 #endif
     }
@@ -417,7 +423,11 @@
 
     for (common = listCOMMON; common; common = common->next) {
 	size+=common->sym->st_size;
-#if defined(__alpha__) || defined(__ia64__) || (defined(__sparc__) && (defined(__arch64__) || defined(__sparcv9)))
+#if defined(__alpha__) || \
+    defined(__ia64__) || \
+    (defined(__sparc__) && \
+     (defined(__arch64__) || \
+      defined(__sparcv9)))
 	size = (size+7)&~0x7;
 #endif
 	numsyms++;
@@ -453,10 +463,12 @@
 	/* this is xstrdup because is should be more efficient. it is freed
 	 * with xf86loaderfree
 	 */
-	pLookup[l].symName = xf86loaderstrdup(ElfGetString(elffile,common->sym->st_name));
+	pLookup[l].symName =
+	    xf86loaderstrdup(ElfGetString(elffile,common->sym->st_name));
 	pLookup[l].offset = (funcptr)(elffile->common + offset);
 #ifdef ELFDEBUG
-	ELFDEBUG("Adding common %lx %s\n", pLookup[l].offset, pLookup[l].symName );
+	ELFDEBUG("Adding common %lx %s\n",
+		 pLookup[l].offset, pLookup[l].symName);
 #endif
 	
 	/* Record the symbol address for gdb */
@@ -468,7 +480,11 @@
 	}
 	listCOMMON=common->next;
 	offset+=common->sym->st_size;
-#if defined(__alpha__) || defined(__ia64__) || (defined(__sparc__) && (defined(__arch64__) || defined(__sparcv9)))
+#if defined(__alpha__) || \
+    defined(__ia64__) || \
+    (defined(__sparc__) && \
+     (defined(__arch64__) || \
+      defined(__sparcv9)))
 	offset = (offset+7)&~0x7;  
 #endif
 	xf86loaderfree(common);
@@ -549,18 +565,7 @@
 ELFModulePtr	elffile;
 int index;
 {
-    char	*name,*symname;
-    symname=ElfGetSymbolNameIndex( elffile, index, elffile->symndx );
-    if( symname == NULL )
-	return NULL;
-   
-    name=xf86loadermalloc(strlen(symname)+1);
-    if (!name)
-	FatalError("ELFGetSymbolName: Out of memory\n");
-
-    strcpy(name,symname);
-
-    return name;
+    return ElfGetSymbolNameIndex(elffile, index, elffile->symndx);
 }
 
 static Elf_Addr
@@ -619,7 +624,7 @@
 		    break;
 		}
 #ifdef ELFDEBUG
-	    ELFDEBUG( "%x\t", symbol );
+	    ELFDEBUG( "%lx\t", symbol );
 	    ELFDEBUG( "%lx\t", symval );
 	    ELFDEBUG( "%s\n", symname ? symname : "NULL");
 #endif
@@ -711,8 +716,8 @@
 		    break;
 		}
 #ifdef ELFDEBUG
-	    ELFDEBUG( "ElfGetPlt: symbol=%x\t", symbol );
-	    ELFDEBUG( "newval=%x\t", symval );
+	    ELFDEBUG( "ElfGetPlt: symbol=%lx\t", symbol );
+	    ELFDEBUG( "newval=%lx\t", symval );
 	    ELFDEBUG( "name=\"%s\"\n", symname ? symname : "NULL");
 #endif
 	    break;
@@ -738,20 +743,18 @@
 static void
 ElfAddGOT(elffile,rel)
 ELFModulePtr	elffile;
-Elf_Rela	*rel;
+Elf_Rel_t	*rel;
 {
     ELFGotEntryPtr gotent;
 
 #ifdef ELFDEBUG
     {
     Elf_Sym *sym;
-    char *namestr;
 
     sym=(Elf_Sym *)&(elffile->symtab[ELF_R_SYM(rel->r_info)]);
     if( sym->st_name) {
 	ELFDEBUG("ElfAddGOT: Adding GOT entry for %s\n", 
-	    namestr=ElfGetSymbolName(elffile,ELF_R_SYM(rel->r_info)) );
-	xf86loaderfree(namestr);
+	    ElfGetSymbolName(elffile,ELF_R_SYM(rel->r_info)) );
 	}
     else
 	ELFDEBUG("ElfAddGOT: Adding GOT entry for %s\n", 
@@ -799,9 +802,7 @@
     int gotsize;
 #ifdef ELFDEBUG
     ELFDEBUG( "ELFCreateGOT: %x entries in the GOT\n", elffile->gotsize/8 );
-#endif
 
-#ifdef ELFDEBUG
     /*
      * Hmmm. Someone is getting here without any got entries, but they
      * may still have R_ALPHA_GPDISP relocations against the got.
@@ -836,7 +837,8 @@
 	gots->freeptr = gots->freeptr + elffile->gotsize;
 	gots->nuses++;
 #ifdef ELFDEBUG
-	ELFDEBUG( "ELFCreateGOT: GOT address %lx in shared GOT, nuses %d\n", elffile->got, gots->nuses );
+	ELFDEBUG( "ELFCreateGOT: GOT address %lx in shared GOT, nuses %d\n",
+		  elffile->got, gots->nuses );
 #endif
 	return TRUE;
     }
@@ -930,22 +932,18 @@
 ELFCreateOPD(elffile)
 ELFModulePtr	elffile;
 {
-    ELFOpdPtr opdent, last = NULL;
+    ELFOpdPtr opdent;
 
     if (elffile->got == NULL)
 	ErrorF( "ELFCreateOPD() Unallocated GOT!!!!\n" );
 
-    for (opdent = elffile->opd_entries; opdent; last = opdent, opdent = opdent->next) {
-	if (last && last->index == -1)
-	    xf86loaderfree(last);
+    for (opdent = elffile->opd_entries; opdent; opdent = opdent->next) {
 	if (opdent->index != -1)
 	    continue;
 	((unsigned long *)(elffile->got+opdent->offset))[0] = (long)opdent->l->offset;
 	((unsigned long *)(elffile->got+opdent->offset))[1] = (long)elffile->got;
 	opdent->l->offset = (funcptr)(elffile->got+opdent->offset);
     }
-    if (last && last->index == -1)
-	xf86loaderfree(last);
 }
 
 /*
@@ -954,20 +952,18 @@
 static void
 ElfAddPLT(elffile,rel)
 ELFModulePtr	elffile;
-Elf_Rela	*rel;
+Elf_Rel_t	*rel;
 {
     ELFPltEntryPtr pltent;
 
 #ifdef ELFDEBUG
     {
     Elf_Sym *sym;
-    char *namestr;
 
     sym=(Elf_Sym *)&(elffile->symtab[ELF_R_SYM(rel->r_info)]);
     if( sym->st_name) {
 	ELFDEBUG("ElfAddPLT: Adding PLT entry for %s\n", 
-	    namestr=ElfGetSymbolName(elffile,ELF_R_SYM(rel->r_info)) );
-	xf86loaderfree(namestr);
+	    ElfGetSymbolName(elffile,ELF_R_SYM(rel->r_info)) );
 	}
     else
 	ErrorF("ElfAddPLT: Add PLT entry for section??\n");
@@ -1046,7 +1042,7 @@
     case 0: data = *data128; break;
     case 1: memcpy(&data, (char *)data128 + 5, 8); break;
     case 2: memcpy(&data, (char *)data128 + 10, 6); break;
-    default: FatalError("Unexpected slot in nIA64InstallReloc()\n");
+    default: FatalError("Unexpected slot in IA64InstallReloc()\n");
     }
     switch (opnd) {
     case IA64_OPND_IMM22:
@@ -1072,7 +1068,7 @@
     case 0: *data128 = data; break;
     case 1: memcpy((char *)data128 + 5, &data, 8); break;
     case 2: memcpy((char *)data128 + 10, &data, 6); break;
-    default: FatalError("Unexpected slot in nIA64InstallReloc()\n");
+    default: FatalError("Unexpected slot in IA64InstallReloc()\n");
     }
 #ifdef ELFDEBUG
     ELFDEBUG( "After  [%016lx%016lx]\n", data128[1], data128[0]);
@@ -1091,12 +1087,7 @@
 Elf_RelocateEntry(elffile, secp, rel, force)
 ELFModulePtr	elffile;
 unsigned char *secp;	/* Begining of the target section */
-#if defined(i386)
-Elf_Rel	*rel;
-#endif
-#if defined(__powerpc__) || defined(__mc68000__) || defined(__alpha__) || defined(__sparc__) || defined(__ia64__)
-Elf_Rela	*rel;
-#endif
+Elf_Rel_t	*rel;
 int		force;
 {
     unsigned int *dest32;	/* address of the 32 bit place being modified */
@@ -1109,11 +1100,7 @@
 #if defined(__alpha__)
     unsigned int *dest32h;	/* address of the high 32 bit place being modified */
     unsigned long *dest64;
-#if 0				/* XXX unused */
-    unsigned long *gp=(unsigned long *)elffile->got+0x8000;	/*
-								 * location of the got table */
 #endif
-#endif
 #if defined(__ia64__)
     unsigned long *dest64;
     unsigned long *dest128;
@@ -1121,16 +1108,17 @@
     Elf_Addr symval = 0;	/* value of the indicated symbol */
 
 #ifdef ELFDEBUG
-#if defined(i386)
     ELFDEBUG( "%lx %d %d\n", rel->r_offset,
-	      ELF_R_SYM(rel->r_info),ELF_R_TYPE(rel->r_info) );
+	      ELF_R_SYM(rel->r_info), ELF_R_TYPE(rel->r_info) );
+#if defined(__powerpc__) || \
+    defined(__mc68000__) || \
+    defined(__alpha__) || \
+    defined(__sparc__) || \
+    defined(__ia64__)
+    ELFDEBUG( "%lx", rel->r_addend );
 #endif
-#if defined(__powerpc__) || defined(__mc68000__) || defined(__alpha__) || defined(__sparc__) || defined(__ia64__)
-    ELFDEBUG( "%x %d %d %x\n", rel->r_offset,
-	      ELF_R_SYM(rel->r_info),ELF_R_TYPE(rel->r_info),
-	      rel->r_addend );
+    ELFDEBUG("\n");
 #endif
-#endif
 #if defined(__alpha__)
     if (ELF_R_SYM(rel->r_info) && ELF_R_TYPE(rel->r_info) != R_ALPHA_GPDISP) {
 #else
@@ -1142,10 +1130,8 @@
 		symval = (Elf_Addr) &LoaderDefaultFunc;
 	    } else {
 #ifdef ELFDEBUG
-		char *namestr;
-		namestr = ElfGetSymbolName(elffile,ELF_R_SYM(rel->r_info));
-		ELFDEBUG("***Unable to resolve symbol %s\n", namestr);
-		xf86loaderfree(namestr);
+		ELFDEBUG("***Unable to resolve symbol %s\n",
+			 ElfGetSymbolName(elffile, ELF_R_SYM(rel->r_info)));
 #endif
 		return ElfDelayRelocation(elffile,secp,rel);
 	    }
@@ -1170,16 +1156,12 @@
 	case R_386_PC32:
 	    dest32=(unsigned int *)(secp+rel->r_offset);
 #ifdef ELFDEBUG
-	    {
-	    char *namestr;
 	    ELFDEBUG( "R_386_PC32 %s\t",
-			namestr=ElfGetSymbolName(elffile,ELF_R_SYM(rel->r_info)) );
-	    xf86loaderfree(namestr);
+			ElfGetSymbolName(elffile,ELF_R_SYM(rel->r_info)) );
 	    ELFDEBUG( "secp=%x\t", secp );
 	    ELFDEBUG( "symval=%lx\t", symval );
 	    ELFDEBUG( "dest32=%x\t", dest32 );
 	    ELFDEBUG( "*dest32=%8.8lx\t", *dest32 );
-	    }
 #endif
 
 	    *dest32=symval+(*dest32)-(Elf_Addr)dest32; /* S + A - P */
@@ -1188,7 +1170,7 @@
 	    ELFDEBUG( "*dest32=%8.8lx\n", *dest32 );
 #endif
 
-		break;
+	    break;
 #endif /* i386 */
 #if defined(__alpha__)
 	case R_ALPHA_NONE:
@@ -1216,16 +1198,12 @@
 	    dest32=(unsigned int *)dest64;
 
 #ifdef ELFDEBUG
-	    {
-	    char *namestr;
 	    ELFDEBUG( "R_ALPHA_GPREL32 %s\t", 
-			namestr=ElfGetSymbolName(elffile,ELF_R_SYM(rel->r_info)) );
-	    xf86loaderfree(namestr);
+			ElfGetSymbolName(elffile,ELF_R_SYM(rel->r_info)) );
 	    ELFDEBUG( "secp=%lx\t", secp );
 	    ELFDEBUG( "symval=%lx\t", symval );
 	    ELFDEBUG( "dest32=%lx\t", dest32 );
 	    ELFDEBUG( "*dest32=%8.8x\t", *dest32 );
-	    }
 #endif
 	    symval += rel->r_addend;
 	    symval = ((unsigned char *)symval)-((unsigned char *)elffile->got);
@@ -1249,16 +1227,12 @@
 	    ELFGotEntryPtr gotent;
 	    dest32=(unsigned int *)(secp+rel->r_offset);
 #ifdef ELFDEBUG
-	    {
-	    char *namestr;
 	    ELFDEBUG( "R_ALPHA_LITERAL %s\t", 
-			namestr=ElfGetSymbolName(elffile,ELF_R_SYM(rel->r_info)) );
-	    xf86loaderfree(namestr);
+			ElfGetSymbolName(elffile,ELF_R_SYM(rel->r_info)) );
 	    ELFDEBUG( "secp=%lx\t", secp );
 	    ELFDEBUG( "symval=%lx\t", symval );
 	    ELFDEBUG( "dest32=%lx\t", dest32 );
 	    ELFDEBUG( "*dest32=%8.8x\t", *dest32 );
-	    }
 #endif
 
 	    for (gotent=elffile->got_entries;gotent;gotent=gotent->next) {
@@ -1311,11 +1285,8 @@
 	    dest32=(unsigned int *)((secp+rel->r_offset)+rel->r_addend);
 
 #ifdef ELFDEBUG
-	    {
-	    char *namestr;
 	    ELFDEBUG( "R_ALPHA_GPDISP %s\t", 
-			namestr=ElfGetSymbolName(elffile,ELF_R_SYM(rel->r_info)) );
-	    xf86loaderfree(namestr);
+			ElfGetSymbolName(elffile,ELF_R_SYM(rel->r_info)) );
 	    ELFDEBUG( "secp=%lx\t", secp );
 	    ELFDEBUG( "got=%lx\t", elffile->got );
 	    ELFDEBUG( "gp=%lx\t", gp );
@@ -1323,13 +1294,10 @@
 	    ELFDEBUG( "*dest32=%8.8x\t", *dest32 );
 	    ELFDEBUG( "dest32h=%lx\t", dest32h );
 	    ELFDEBUG( "*dest32h=%8.8x\t", *dest32h );
-	    }
 #endif
 	    if ((*dest32h >> 26) != 9 || (*dest32 >> 26) != 8) {
-	        char *namestr;
 	        ErrorF( "***Bad instructions in relocating %s\n",
-			namestr=ElfGetSymbolName(elffile,ELF_R_SYM(rel->r_info)) );
-	        xf86loaderfree(namestr);
+			ElfGetSymbolName(elffile,ELF_R_SYM(rel->r_info)) );
 	    }
 
 	    symval = (*dest32h & 0xffff) << 16 | (*dest32 & 0xffff);
@@ -1362,16 +1330,12 @@
 	case R_ALPHA_HINT:
 	    dest32=(unsigned int *)((secp+rel->r_offset)+rel->r_addend);
 #ifdef ELFDEBUG
-	    {
-	    char *namestr;
 	    ELFDEBUG( "R_ALPHA_HINT %s\t", 
-			namestr=ElfGetSymbolName(elffile,ELF_R_SYM(rel->r_info)) );
-	    xf86loaderfree(namestr);
+			ElfGetSymbolName(elffile,ELF_R_SYM(rel->r_info)) );
 	    ELFDEBUG( "secp=%lx\t", secp );
 	    ELFDEBUG( "symval=%lx\t", symval );
 	    ELFDEBUG( "dest32=%lx\t", dest32 );
 	    ELFDEBUG( "*dest32=%8.8x\t", *dest32 );
-	    }
 #endif
 
 #ifdef ELFDEBUG
@@ -1405,32 +1369,30 @@
 	case R_68K_32:
 		dest32=(unsigned long *)(secp+rel->r_offset);
 #ifdef ELFDEBUG
-ELFDEBUG( "R_68K_32\t", dest32 );
-ELFDEBUG( "dest32=%x\t", dest32 );
-ELFDEBUG( "*dest32=%8.8x\t", *dest32 );
+		ELFDEBUG( "R_68K_32\t", dest32 );
+		ELFDEBUG( "dest32=%x\t", dest32 );
+		ELFDEBUG( "*dest32=%8.8x\t", *dest32 );
 #endif
 		*dest32=symval+(*dest32); /* S + A */
 #ifdef ELFDEBUG
-ELFDEBUG( "*dest32=%8.8x\n", *dest32 );
+		ELFDEBUG( "*dest32=%8.8x\n", *dest32 );
 #endif
 		break;
 	case R_68K_PC32:
 		dest32=(unsigned long *)(secp+rel->r_offset);
 #ifdef ELFDEBUG
-char *namestr;
-ELFDEBUG( "R_68K_PC32 %s\t",
-		  namestr=ElfGetSymbolName(elffile,ELF_R_SYM(rel->r_info)) );
-xf86loaderfree(namestr);
-ELFDEBUG( "secp=%x\t", secp );
-ELFDEBUG( "symval=%x\t", symval );
-ELFDEBUG( "dest32=%x\t", dest32 );
-ELFDEBUG( "*dest32=%8.8x\t", *dest32 );
+		ELFDEBUG( "R_68K_PC32 %s\t",
+		  ElfGetSymbolName(elffile,ELF_R_SYM(rel->r_info)) );
+		ELFDEBUG( "secp=%x\t", secp );
+		ELFDEBUG( "symval=%x\t", symval );
+		ELFDEBUG( "dest32=%x\t", dest32 );
+		ELFDEBUG( "*dest32=%8.8x\t", *dest32 );
 #endif
 
 		*dest32=symval+(*dest32)-(Elf_Addr)dest32; /* S + A - P */
 
 #ifdef ELFDEBUG
-ELFDEBUG( "*dest32=%8.8x\n", *dest32 );
+		ELFDEBUG( "*dest32=%8.8x\n", *dest32 );
 #endif
 
 		break;
@@ -1900,7 +1862,8 @@
 	    if (rel->r_addend)
 		FatalError("\nAddend for R_IA64_LTOFF_FPTR22 not supported\n");
 #ifdef ELFDEBUG
-	    ELFDEBUG( "opd=%016lx.%016lx\n", ((long *)symval)[0], ((long *)symval)[1] );
+	    ELFDEBUG( "opd=%016lx.%016lx\n",
+		((long *)symval)[0], ((long *)symval)[1] );
 #endif
 	    /* FALLTHROUGH */
 	case R_IA64_LTOFF22:
@@ -1908,18 +1871,14 @@
 	    ELFGotEntryPtr gotent;
 	    dest128=(unsigned long *)(secp+(rel->r_offset&~3));
 #ifdef ELFDEBUG
-	    {
-	    char *namestr;
 	    ELFDEBUG( "%s %s\t", ELF_R_TYPE(rel->r_info) == R_IA64_LTOFF22 ?
 			"R_IA64_LTOFF22" : "R_IA64_LTOFF_FPTR22",
-			namestr=ElfGetSymbolName(elffile,ELF_R_SYM(rel->r_info)) );
-	    xf86loaderfree(namestr);
+			ElfGetSymbolName(elffile,ELF_R_SYM(rel->r_info)) );
 	    ELFDEBUG( "secp=%lx\t", secp );
 	    ELFDEBUG( "symval=%lx\t", symval );
 	    ELFDEBUG( "dest128=%lx\t", dest128 );
-	    ELFDEBUG( "slot=%ld\t", rel->r_offset & 3);
-	    ELFDEBUG( "*dest128=[%016lx%016lx]\t", dest128[1], dest128[0]);
-	    }
+	    ELFDEBUG( "slot=%d\n", rel->r_offset & 3);
+	    ELFDEBUG( "*dest128=[%016lx%016lx]\n", dest128[1], dest128[0]);
 #endif
 
 	    for (gotent=elffile->got_entries;gotent;gotent=gotent->next) {
@@ -1933,7 +1892,7 @@
 		*(unsigned long *)(elffile->got+gotent->offset) =
 							symval+rel->r_addend;
 #ifdef ELFDEBUG
-		ELFDEBUG("Setting gotent[%x]=%lx\t",
+		ELFDEBUG("Setting gotent[%x]=%lx\n",
 				gotent->offset, symval+rel->r_addend);
 #endif
 		if ((gotent->offset & 0xffe00000) != 0)
@@ -1951,18 +1910,14 @@
 	    ELFPltEntryPtr pltent;
 	    dest128=(unsigned long *)(secp+(rel->r_offset&~3));
 #ifdef ELFDEBUG
-	    {
-	    char *namestr;
 	    ELFDEBUG( "R_IA64_PCREL21B %s\t",
-			namestr=ElfGetSymbolName(elffile,ELF_R_SYM(rel->r_info)) );
-	    xf86loaderfree(namestr);
+			ElfGetSymbolName(elffile,ELF_R_SYM(rel->r_info)) );
 	    ELFDEBUG( "secp=%lx\t", secp );
 	    ELFDEBUG( "symval=%lx\t", symval );
 	    ELFDEBUG( "opd=%lx.%lx\t", ((long *)symval)[0], ((long *)symval)[1]);
 	    ELFDEBUG( "dest128=%lx\t", dest128 );
-	    ELFDEBUG( "slot=%ld\t", rel->r_offset & 3);
-	    ELFDEBUG( "*dest128=[%016lx%016lx]\t", dest128[1], dest128[0]);
-	    }
+	    ELFDEBUG( "slot=%d\n", rel->r_offset & 3);
+	    ELFDEBUG( "*dest128=[%016lx%016lx]\n", dest128[1], dest128[0]);
 #endif
 	    if (rel->r_addend)
 		FatalError("\nAddend for PCREL21B not supported\n");
@@ -2010,16 +1965,12 @@
 	case R_IA64_FPTR64LSB:
 	    dest64=(unsigned long *)(secp+rel->r_offset);
 #ifdef ELFDEBUG
-	    {
-	    char *namestr;
 	    ELFDEBUG( "R_IA64_FPTR64LSB %s\t",
-			namestr=ElfGetSymbolName(elffile,ELF_R_SYM(rel->r_info)) );
-	    xf86loaderfree(namestr);
+			ElfGetSymbolName(elffile,ELF_R_SYM(rel->r_info)) );
 	    ELFDEBUG( "secp=%lx\t", secp );
 	    ELFDEBUG( "symval=%lx\t", symval );
 	    ELFDEBUG( "dest64=%lx\t", dest64 );
 	    ELFDEBUG( "opd=%016lx.%016lx\n", ((long *)symval)[0], ((long *)symval)[1] );
-	    }
 #endif
 
 	    if (rel->r_addend)
@@ -2030,15 +1981,11 @@
 	case R_IA64_DIR64LSB:
 	    dest64=(unsigned long *)(secp+rel->r_offset);
 #ifdef ELFDEBUG
-	    {
-	    char *namestr;
 	    ELFDEBUG( "R_IA64_DIR64LSB %s\t",
-			namestr=ElfGetSymbolName(elffile,ELF_R_SYM(rel->r_info)) );
-	    xf86loaderfree(namestr);
+			ElfGetSymbolName(elffile,ELF_R_SYM(rel->r_info)) );
 	    ELFDEBUG( "secp=%lx\t", secp );
 	    ELFDEBUG( "symval=%lx\t", symval );
-	    ELFDEBUG( "dest64=%lx\t", dest64 );
-	    }
+	    ELFDEBUG( "dest64=%lx\n", dest64 );
 #endif
 	    *dest64 = symval + rel->r_addend;
 	    break;
@@ -2046,26 +1993,22 @@
 	case R_IA64_GPREL22:
 	    dest128=(unsigned long *)(secp+(rel->r_offset&~3));
 #ifdef ELFDEBUG
-	    {
-	    char *namestr;
 	    ELFDEBUG( "R_IA64_GPREL22 %s\t",
-			namestr=ElfGetSymbolName(elffile,ELF_R_SYM(rel->r_info)) );
-	    xf86loaderfree(namestr);
+			ElfGetSymbolName(elffile,ELF_R_SYM(rel->r_info)) );
 	    ELFDEBUG( "secp=%lx\t", secp );
 	    ELFDEBUG( "symval=%lx\t", symval );
 	    ELFDEBUG( "dest128=%lx\t", dest128 );
-	    ELFDEBUG( "slot=%ld\t", rel->r_offset & 3);
-	    ELFDEBUG( "*dest128=[%016lx%016lx]\t", dest128[1], dest128[0]);
-	    }
+	    ELFDEBUG( "slot=%d\n", rel->r_offset & 3);
+	    ELFDEBUG( "*dest128=[%016lx%016lx]\n", dest128[1], dest128[0]);
 #endif
-	    IA64InstallReloc(dest128, rel->r_offset & 3, IA64_OPND_IMM22, symval + rel->r_addend - (long)elffile->got);
+	    IA64InstallReloc(dest128, rel->r_offset & 3, IA64_OPND_IMM22,
+		symval + rel->r_addend - (long)elffile->got);
 	    break;
 
 #endif
 	default:
-	    ErrorF(
-		   "Elf_RelocateEntry() Unsupported relocation type %d\n",
-		   ELF_R_TYPE(rel->r_info) );
+	    ErrorF("Elf_RelocateEntry() Unsupported relocation type %d\n",
+		   ELF_R_TYPE(rel->r_info));
 	    break;
 	    }
     return 0;
@@ -2078,12 +2021,7 @@
 {
     int	i, numrel;
     Elf_Shdr	*sect=&(elffile->sections[index]);
-#if defined(i386)
-    Elf_Rel	*rel=(Elf_Rel *)elffile->saddr[index];
-#endif
-#if defined(__powerpc__) || defined(__mc68000__) || defined(__alpha__) || defined(__sparc__) || defined(__sparc__) || defined(__ia64__)
-    Elf_Rela	*rel=(Elf_Rela *)elffile->saddr[index];
-#endif
+    Elf_Rel_t	*rel=(Elf_Rel_t *)elffile->saddr[index];
     Elf_Sym	*syms;
     unsigned char *secp;	/* Begining of the target section */
     ELFRelocPtr reloc_head = NULL;
@@ -2101,7 +2039,7 @@
 #if defined(__alpha__)
 	if( ELF_R_TYPE(rel[i].r_info) == R_ALPHA_LITERAL) {
 	    ElfAddGOT(elffile,&rel[i]);
-	    }   
+	}   
 #endif
 #if defined(__ia64__)
 	if (ELF_R_TYPE(rel[i].r_info) == R_IA64_LTOFF22
@@ -2500,7 +2438,7 @@
 	    elffile->reltxtndx=i;
 	    elffile->reltxtsize=SecSize(i);
 #ifdef ELFDEBUG
-	    ELFDEBUG(".rela.text starts at %x\n", elffile->reltext );
+	    ELFDEBUG(".rela.text starts at %lx\n", elffile->reltext );
 #endif
 	    continue;
 	}
@@ -2514,7 +2452,7 @@
 	    elffile->reldatndx=i;
 	    elffile->reldatsize=SecSize(i);
 #ifdef ELFDEBUG
-	    ELFDEBUG(".rela.data starts at %x\n", elffile->reldata );
+	    ELFDEBUG(".rela.data starts at %lx\n", elffile->reldata );
 #endif
 	    continue;
 	}
@@ -2528,7 +2466,7 @@
 	    elffile->relsdatndx=i;
 	    elffile->relsdatsize=SecSize(i);
 #ifdef ELFDEBUG
-	    ELFDEBUG(".rela.sdata starts at %x\n", elffile->relsdata );
+	    ELFDEBUG(".rela.sdata starts at %lx\n", elffile->relsdata );
 #endif
 	    continue;
 	}
@@ -2542,7 +2480,7 @@
 	    elffile->relrodatndx=i;
 	    elffile->relrodatsize=SecSize(i);
 #ifdef ELFDEBUG
-	    ELFDEBUG(".rela.rodata starts at %x\n", elffile->relrodata );
+	    ELFDEBUG(".rela.rodata starts at %lx\n", elffile->relrodata );
 #endif
 	    continue;
 	}
@@ -2724,7 +2662,8 @@
 /*
  *  Get the ELF header
  */
-    elffile->header=(Elf_Ehdr*)_LoaderFileToMem(elffd,0,sizeof(Elf_Ehdr),"header");
+    elffile->header=
+	(Elf_Ehdr*)_LoaderFileToMem(elffd, 0, sizeof(Elf_Ehdr), "header");
     header=(Elf_Ehdr *)elffile->header;
 
 /*
@@ -2732,8 +2671,9 @@
  */
     elffile->numsh=header->e_shnum;
     elffile->secsize=(header->e_shentsize*header->e_shnum);
-    elffile->sections=(Elf_Shdr *)_LoaderFileToMem(elffd,header->e_shoff,
-						     elffile->secsize, "sections");
+    elffile->sections=
+	(Elf_Shdr *)_LoaderFileToMem(elffd, header->e_shoff, elffile->secsize,
+				     "sections");
 #if defined(__alpha__) || defined(__ia64__)
     /*
      * Need to allocate space for the .got section which will be
@@ -2782,8 +2722,9 @@
  * Get the section header string table
  */
     elffile->shstrsize = SecSize(header->e_shstrndx);
-    elffile->shstraddr = _LoaderFileToMem(elffd,SecOffset(header->e_shstrndx),
-					  SecSize(header->e_shstrndx),".shstrtab");
+    elffile->shstraddr =
+	_LoaderFileToMem(elffd, SecOffset(header->e_shstrndx),
+			 SecSize(header->e_shstrndx), ".shstrtab");
     elffile->shstrndx = header->e_shstrndx;
 #if defined(__alpha__) || defined(__ia64__)
     /*
@@ -2991,6 +2932,10 @@
 {
     ELFModulePtr elffile = (ELFModulePtr)modptr;
     ELFRelocPtr  relptr, reltptr, *brelptr;
+#ifdef __ia64__
+    ELFOpdPtr opdent;
+    ELFPltEntryPtr pltent;
+#endif
 
 /*
  * Delete any unresolved relocations
@@ -3031,8 +2976,14 @@
 #if defined(__alpha__) || defined(__ia64__)
     if (elffile->shared_got) {
 	elffile->shared_got->nuses--;
-	if (!elffile->shared_got->nuses)
+	if (!elffile->shared_got->nuses) {
+	    ELFGotPtr *pgot = &ELFSharedGOTs;
+	    while (*pgot && *pgot != elffile->shared_got)
+		pgot = &(*pgot)->next;
+	    if (*pgot)
+		*pgot = elffile->shared_got->next;
 	    xf86loaderfree(elffile->shared_got);
+	}
     }
 #endif
 #else
@@ -3045,13 +2996,21 @@
     CheckandFreeFile(elffile->rodata,elffile->rodatsize);
     CheckandFreeFile(elffile->rodata1,elffile->rodat1size);
     CheckandFree(elffile->common,elffile->comsize);
-#if defined(__ia64__)
-    CheckandFree(elffile->plt,elffile->pltsize);
-#endif
 #if defined(__alpha__) || defined(__ia64__)
     CheckandFree(elffile->got,elffile->gotsize);
 #endif
 #endif
+#if defined(__ia64__)
+    CheckandFree(elffile->plt,elffile->pltsize);
+    while ((pltent = elffile->plt_entries)) {
+	elffile->plt_entries = pltent->next;
+	xf86loaderfree(pltent);
+    }
+    while ((opdent = elffile->opd_entries)) {
+	elffile->opd_entries = opdent->next;
+	xf86loaderfree(opdent);
+    }
+#endif
     CheckandFreeFile(elffile->reltext,elffile->reltxtsize);
     CheckandFreeFile(elffile->reldata,elffile->reldatsize);
     CheckandFreeFile(elffile->relrodata,elffile->relrodatsize);
@@ -3086,4 +3045,3 @@
 	}
     return NULL;
 }
-
Index: XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/os-support/int10Defines.h
===================================================================
RCS file: /cvs/xc/programs/Xserver/hw/xfree86/os-support/int10Defines.h,v
retrieving revision 1.1
retrieving revision 1.2
diff -u -r1.1 -r1.2
--- XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/os-support/int10Defines.h	2000/01/23 04:44:35	1.1
+++ XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/os-support/int10Defines.h	2001/01/06 20:19:14	1.2
@@ -1,46 +1,55 @@
-/* $XFree86: xc/programs/Xserver/hw/xfree86/os-support/int10Defines.h,v 1.1 2000/01/23 04:44:35 dawes Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/os-support/int10Defines.h,v 1.2 2001/01/06 20:19:14 tsi Exp $ */
+
+#ifndef _INT10DEFINES_H_
+#define _INT10DEFINES_H_ 1
+
 #ifdef _VM86_LINUX
 
 #include <asm/vm86.h>
 
-#define CPU_R(type,name) \
-        (*((type *)&(((struct vm86_struct *)REG->cpuRegs)->regs.##name)))
-#define CPU_RD(name) CPU_R(CARD32,name)
-#define CPU_RW(name) CPU_R(CARD16,name)
-#define CPU_RB(name) CPU_R(CARD8,name)
-	   
-#define X86_EAX CPU_RD(eax)
-#define X86_EBX CPU_RD(ebx)
-#define X86_ECX CPU_RD(ecx)
-#define X86_EDX CPU_RD(edx)
-#define X86_ESI CPU_RD(esi)
-#define X86_EDI CPU_RD(edi)
-#define X86_EBP CPU_RD(ebp)
-#define X86_EIP CPU_RD(eip)
-#define X86_ESP CPU_RD(esp)
-#define X86_EFLAGS CPU_RD(eflags)
-
-#define X86_FLAGS CPU_RW(eflags)
-#define X86_AX CPU_RW(eax)
-#define X86_BX CPU_RW(ebx)
-#define X86_CX CPU_RW(ecx)
-#define X86_DX CPU_RW(edx)
-#define X86_SI CPU_RW(esi)
-#define X86_DI CPU_RW(edi)
-#define X86_BP CPU_RW(ebp)
-#define X86_IP CPU_RW(eip)
-#define X86_SP CPU_RW(esp)
-#define X86_CS CPU_RW(cs)
-#define X86_DS CPU_RW(ds)
-#define X86_ES CPU_RW(es)
-#define X86_SS CPU_RW(ss)
-#define X86_FS CPU_RW(fs)
-#define X86_GS CPU_RW(gs)
-
-#define X86_AL CPU_RB(eax)
-#define X86_BL CPU_RB(ebx)
-#define X86_CL CPU_RB(ecx)
-#define X86_DL CPU_RB(edx)
+#define CPU_R(type,name,num) \
+	(((type *)&(((struct vm86_struct *)REG->cpuRegs)->regs.##name))[num])
+#define CPU_RD(name,num) CPU_R(CARD32,name,num)
+#define CPU_RW(name,num) CPU_R(CARD16,name,num)
+#define CPU_RB(name,num) CPU_R(CARD8,name,num)
+
+#define X86_EAX CPU_RD(eax,0)
+#define X86_EBX CPU_RD(ebx,0)
+#define X86_ECX CPU_RD(ecx,0)
+#define X86_EDX CPU_RD(edx,0)
+#define X86_ESI CPU_RD(esi,0)
+#define X86_EDI CPU_RD(edi,0)
+#define X86_EBP CPU_RD(ebp,0)
+#define X86_EIP CPU_RD(eip,0)
+#define X86_ESP CPU_RD(esp,0)
+#define X86_EFLAGS CPU_RD(eflags,0)
+
+#define X86_FLAGS CPU_RW(eflags,0)
+#define X86_AX CPU_RW(eax,0)
+#define X86_BX CPU_RW(ebx,0)
+#define X86_CX CPU_RW(ecx,0)
+#define X86_DX CPU_RW(edx,0)
+#define X86_SI CPU_RW(esi,0)
+#define X86_DI CPU_RW(edi,0)
+#define X86_BP CPU_RW(ebp,0)
+#define X86_IP CPU_RW(eip,0)
+#define X86_SP CPU_RW(esp,0)
+#define X86_CS CPU_RW(cs,0)
+#define X86_DS CPU_RW(ds,0)
+#define X86_ES CPU_RW(es,0)
+#define X86_SS CPU_RW(ss,0)
+#define X86_FS CPU_RW(fs,0)
+#define X86_GS CPU_RW(gs,0)
+
+#define X86_AL CPU_RB(eax,0)
+#define X86_BL CPU_RB(ebx,0)
+#define X86_CL CPU_RB(ecx,0)
+#define X86_DL CPU_RB(edx,0)
+
+#define X86_AH CPU_RB(eax,1)
+#define X86_BH CPU_RB(ebx,1)
+#define X86_CH CPU_RB(ecx,1)
+#define X86_DH CPU_RB(edx,1)
 
 #elif defined(_X86EMU)
 
@@ -48,3 +57,4 @@
 
 #endif
 
+#endif
Index: XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/os-support/bsd/bsdResource.c
===================================================================
RCS file: /cvs/xc/programs/Xserver/hw/xfree86/os-support/bsd/bsdResource.c,v
retrieving revision 1.2
retrieving revision 1.3
diff -u -r1.2 -r1.3
--- XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/os-support/bsd/bsdResource.c	2000/11/06 19:24:08	1.2
+++ XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/os-support/bsd/bsdResource.c	2001/01/06 20:19:14	1.3
@@ -1,4 +1,4 @@
-/* $XFree86: xc/programs/Xserver/hw/xfree86/os-support/bsd/bsdResource.c,v 1.2 2000/11/06 19:24:08 dawes Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/os-support/bsd/bsdResource.c,v 1.3 2001/01/06 20:19:14 tsi Exp $ */
 
 /* Resource information code */
 
@@ -80,10 +80,12 @@
     RANGE(range,0xc0000,0xeffff,ResExcMemBlock);
     ret = xf86AddResToList(ret, &range, -1);
 
-    /* Fallback is to claim well known ports in the 0x0 - 0x3ff range */
-    /* Possibly should claim some of them as sparse ranges */
-
-    RANGE(range,0,0x1ff,ResExcIoBlock | ResEstimated);
+    /*
+     * Fallback would be to claim well known ports in the 0x0 - 0x3ff range
+     * along with their sparse I/O aliases, but that's too imprecise.  Instead
+     * claim a bare minimum here.
+     */
+    RANGE(range, 0, 0x00ff, ResExcIoBlock);     /* For mainboard */
     ret = xf86AddResToList(ret, &range, -1);
     /* XXX add others */
     return ret;
Index: XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/os-support/bus/Pci.c
===================================================================
RCS file: /cvs/xc/programs/Xserver/hw/xfree86/os-support/bus/Pci.c,v
retrieving revision 1.42
retrieving revision 1.43
diff -u -r1.42 -r1.43
--- XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/os-support/bus/Pci.c	2000/12/07 15:43:45	1.42
+++ XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/os-support/bus/Pci.c	2001/01/06 20:19:15	1.43
@@ -1,4 +1,4 @@
-/* $XFree86: xc/programs/Xserver/hw/xfree86/os-support/bus/Pci.c,v 1.42 2000/12/07 15:43:45 tsi Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/os-support/bus/Pci.c,v 1.43 2001/01/06 20:19:15 tsi Exp $ */
 /*
  * Pci.c - New server PCI access functions
  *
@@ -1054,8 +1054,10 @@
 		unsigned char *Buf, int Len)
 {
     ADDRESS hostbase;
+    CARD8 *image = Buf;
+    unsigned long offset;
     CARD32 romaddr, savebase = 0, romsave = 0, newbase = 0;
-    int ret;
+    int ret, length, rlength, n;
 
     /* XXX This assumes that memory access is enabled */
 
@@ -1067,24 +1069,23 @@
     romsave = pciReadLong(Tag, PCI_MAP_ROM_REG);
     romaddr = PCIGETROM(romsave);
     if ((newbase = getValidBIOSBase(Tag, &basereg)) != romaddr) {
+RetryWithBase:
 	romaddr = PCIGETROM(newbase);
-	if (romaddr != 0 && romaddr == newbase) {
-#if 1
-	  /* move mem base out of the way if in conflict with ROM */
+	if (romaddr) {
+	  /* move mem base out of the way if in conflicts with ROM */
 	  if ((basereg >= 0) && (basereg <= 5)) {
-	      savebase = pciReadLong(Tag, PCI_MAP_REG_START + (basereg << 2));
+	      if (!savebase)
+	          savebase = pciReadLong(Tag, PCI_MAP_REG_START+(basereg<<2));
 	      if (PCIGETROM(savebase) == romaddr) {
 	          xf86MsgVerb(X_INFO,5,"xf86ReadPciBios: modifying membase[%i]"
 			    " for device %i:%i:%i\n", basereg,
 			    PCI_BUS_FROM_TAG(Tag), PCI_DEV_FROM_TAG(Tag),
 			    PCI_FUNC_FROM_TAG(Tag));
-		pciWriteLong(Tag, PCI_MAP_REG_START + (basereg << 2), 0);
+		pciWriteLong(Tag, PCI_MAP_REG_START + (basereg << 2),
+		    (CARD32)~0);
 	    }
 	  }
-#endif
-	    pciWriteLong(Tag, PCI_MAP_ROM_REG, romaddr);
-	} else
-	    romaddr = 0;
+	}
     }
 
 
@@ -1092,10 +1093,10 @@
 	xf86Msg(X_WARNING, "xf86ReadPciBIOS: cannot locate a BIOS address\n");
 	return -1;
     } 
-    else
-      xf86MsgVerb(X_INFO,5,"xf86ReadPciBIOS: found ValidBIOSBase for %i:%i:%i:"
-		  " %x\n", PCI_BUS_FROM_TAG(Tag), PCI_DEV_FROM_TAG(Tag),
-		  PCI_FUNC_FROM_TAG(Tag),newbase);
+    xf86MsgVerb(X_INFO, 5,
+	"xf86ReadPciBIOS: found ValidBIOSBase for %i:%i:%i: %x\n",
+	PCI_BUS_FROM_TAG(Tag), PCI_DEV_FROM_TAG(Tag), PCI_FUNC_FROM_TAG(Tag),
+	newbase);
 
     hostbase = pciBusAddrToHostAddr(Tag, PCI_MEM, PCIGETROM(romaddr));
 #ifdef DEBUG
@@ -1103,8 +1104,38 @@
 #endif
     /* Enable ROM address decoding */
     pciWriteLong(Tag, PCI_MAP_ROM_REG, romaddr | PCI_MAP_ROM_DECODE_ENABLE);
+
+    /* Read BIOS in 64kB chunks */
+    ret = 0;
+    offset = Offset;
+    while ((length = Len) > 0) {
+	if (length > 0x10000) length = 0x10000;
+	rlength = xf86ReadBIOS(hostbase, offset, image, length);
+	if (rlength < 0) {
+	    ret = rlength;
+	    break;
+	}
+	ret += rlength;
+	if (rlength < length) break;
+	offset += length;
+	image += length;
+	Len -= length;
+    }
 
-    ret = xf86ReadBIOS(hostbase, Offset, Buf, Len);
+    if ((ret != Len) || (Buf[0] != 0x55) || (Buf[1] != 0xaa) || !Buf[2] ||
+	(Len < (Buf[2] << 9))) {
+	n = 0;
+	if ((basereg >= 0) && (basereg <= 5) && xf86PciVideoInfo) do {
+	    pciVideoPtr pvp;
+
+	    if (!(pvp = xf86PciVideoInfo[n++])) break;
+	    if (pciTag(pvp->bus, pvp->device, pvp->func) == Tag) {
+		if (newbase == pvp->memBase[basereg]) break;
+		newbase = pvp->memBase[basereg];
+		goto RetryWithBase;
+	    }
+	} while (1);
+    }
 
     /* Restore ROM address decoding */
     pciWriteLong(Tag, PCI_MAP_ROM_REG, romsave);
@@ -1129,7 +1160,8 @@
 
   size = readPciBIOS(Offset,Tag,basereg,Buf,Len);
   
-  if (size != -1 && Buf[0] == 0x55 && Buf[1] == 0xaa)
+  if ((size == Len) && (Buf[0] == 0x55) && (Buf[1] == 0xaa) && Buf[2] &&
+      (Len >= (Buf[2] << 9)))
     return size;
 
   num = pciTestMultiDeviceCard(PCI_BUS_FROM_TAG(Tag),
@@ -1149,7 +1181,8 @@
 					     PCI_CMD_STAT_REG,(Acc2 | PCI_ENA));
     size = readPciBIOS(Offset,pTag[i],0,Buf,Len);
     ((WriteProcPtr)(pciLongFunc(pTag[i],WRITE)))(pTag[i],PCI_CMD_STAT_REG,Acc2);
-    if (size != -1 && ((CARD8*)Buf)[0] == 0x55 && ((CARD8*)Buf)[1] == 0xaa)
+    if ((size == Len) && (Buf[0] == 0x55) && (Buf[1] == 0xaa) && Buf[2] &&
+	(Len >= (Buf[2] << 9)))
       break;
   }
   ((WriteProcPtr)(pciLongFunc(Tag,WRITE)))(Tag,PCI_CMD_STAT_REG,Acc1);
Index: XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/os-support/linux/lnxResource.c
===================================================================
RCS file: /cvs/xc/programs/Xserver/hw/xfree86/os-support/linux/lnxResource.c,v
retrieving revision 3.11
retrieving revision 3.12
diff -u -r3.11 -r3.12
--- XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/os-support/linux/lnxResource.c	2000/10/17 16:53:20	3.11
+++ XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/os-support/linux/lnxResource.c	2001/01/06 20:19:15	3.12
@@ -1,4 +1,4 @@
-/* $XFree86: xc/programs/Xserver/hw/xfree86/os-support/linux/lnxResource.c,v 3.11 2000/10/17 16:53:20 tsi Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/os-support/linux/lnxResource.c,v 3.12 2001/01/06 20:19:15 tsi Exp $ */
 
 /* Resource information code */
 
@@ -141,10 +141,12 @@
     RANGE(range,0xc0000,0xeffff,ResExcMemBlock);
     ret = xf86AddResToList(ret, &range, -1);
 
-    /* Fallback is to claim well known ports in the 0x0 - 0x3ff range */
-    /* Possibly should claim some of them as sparse ranges */
-
-    RANGE(range,0,0x1ff,ResExcIoBlock | ResEstimated);
+    /*
+     * Fallback would be to claim well known ports in the 0x0 - 0x3ff range
+     * along with their sparse I/O aliases, but that's too imprecise.  Instead
+     * claim a bare minimum here.
+     */
+    RANGE(range, 0, 0x00ff, ResExcIoBlock);     /* For mainboard */
     ret = xf86AddResToList(ret, &range, -1);
     /* XXX add others */
     return ret;
Index: XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/os-support/linux/int10/linux.c
===================================================================
RCS file: /cvs/xc/programs/Xserver/hw/xfree86/os-support/linux/int10/linux.c,v
retrieving revision 1.19
retrieving revision 1.20
diff -u -r1.19 -r1.20
--- XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/os-support/linux/int10/linux.c	2000/12/06 15:35:31	1.19
+++ XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/os-support/linux/int10/linux.c	2001/01/06 20:19:15	1.20
@@ -1,10 +1,9 @@
-/* $XFree86: xc/programs/Xserver/hw/xfree86/os-support/linux/int10/linux.c,v 1.19 2000/12/06 15:35:31 eich Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/os-support/linux/int10/linux.c,v 1.20 2001/01/06 20:19:15 tsi Exp $ */
 /*
  * linux specific part of the int10 module
  * Copyright 1999 Egbert Eich
  */
 #include "xf86.h"
-#include "xf86str.h"
 #include "xf86_OSproc.h"
 #include "xf86_ansic.h"
 #include "xf86Pci.h"
@@ -28,12 +27,12 @@
 
 static int counter = 0;
 
-static CARD8 read_b(xf86Int10InfoPtr pInt,int addr);
-static CARD16 read_w(xf86Int10InfoPtr pInt,int addr);
-static CARD32 read_l(xf86Int10InfoPtr pInt,int addr);
-static void write_b(xf86Int10InfoPtr pInt,int addr, CARD8 val);
-static void write_w(xf86Int10InfoPtr pInt,int addr, CARD16 val);
-static void write_l(xf86Int10InfoPtr pInt,int addr, CARD32 val);
+static CARD8 read_b(xf86Int10InfoPtr pInt, int addr);
+static CARD16 read_w(xf86Int10InfoPtr pInt, int addr);
+static CARD32 read_l(xf86Int10InfoPtr pInt, int addr);
+static void write_b(xf86Int10InfoPtr pInt, int addr, CARD8 val);
+static void write_w(xf86Int10InfoPtr pInt, int addr, CARD16 val);
+static void write_l(xf86Int10InfoPtr pInt, int addr, CARD32 val);
 
 int10MemRec linuxMem = {
     read_b,
@@ -70,20 +69,20 @@
     legacyVGARec vga;
 
     screen = (xf86FindScreenForEntity(entityIndex))->scrnIndex;
-    if (int10skip(xf86Screens[screen],entityIndex))
+    if (int10skip(xf86Screens[screen], entityIndex))
 	return NULL;
 
     if ((!vidMem) || (!sysMem)) {
-	if ((fd = open(DEV_MEM,O_RDWR,0)) >= 0) {
+	if ((fd = open(DEV_MEM, O_RDWR, 0)) >= 0) {
 	    if (!sysMem) {
 #ifdef DEBUG
 		ErrorF("Mapping sys bios area\n");
 #endif
-		if ((sysMem = mmap((void *)(SYS_BIOS),BIOS_SIZE,PROT_READ
-				   | PROT_WRITE | PROT_EXEC,
-				   MAP_SHARED | MAP_FIXED,fd, SYS_BIOS))
+		if ((sysMem = mmap((void *)(SYS_BIOS), BIOS_SIZE,
+				   PROT_READ | PROT_WRITE | PROT_EXEC,
+				   MAP_SHARED | MAP_FIXED, fd, SYS_BIOS))
 		    == MAP_FAILED) {
-		    xf86DrvMsg(screen,X_ERROR,"Cannot map SYS BIOS\n");
+		    xf86DrvMsg(screen, X_ERROR, "Cannot map SYS BIOS\n");
 		    close(fd);
 		    goto error0;
 		}
@@ -92,33 +91,33 @@
 #ifdef DEBUG
 		ErrorF("Mapping VRAM area\n");
 #endif
-		if ((vidMem = mmap((void *)(V_RAM),VRAM_SIZE,PROT_READ
-				   | PROT_WRITE | PROT_EXEC,
-				   MAP_SHARED | MAP_FIXED,fd, V_RAM))
+		if ((vidMem = mmap((void *)(V_RAM), VRAM_SIZE,
+				   PROT_READ | PROT_WRITE | PROT_EXEC,
+				   MAP_SHARED | MAP_FIXED, fd, V_RAM))
 		    == MAP_FAILED) {
-		    xf86DrvMsg(screen,X_ERROR,"Cannot map V_RAM\n");
+		    xf86DrvMsg(screen, X_ERROR, "Cannot map V_RAM\n");
 		    close(fd);
 		    goto error0;
 		}
 	    }
 	    close(fd);
 	} else {
-	    xf86DrvMsg(screen,X_ERROR,"Cannot open %s\n",DEV_MEM);
+	    xf86DrvMsg(screen, X_ERROR, "Cannot open %s\n", DEV_MEM);
 	    goto error0;
 	}
     }
-    
-    pInt = (xf86Int10InfoPtr)xnfcalloc(1,sizeof(xf86Int10InfoRec));
+
+    pInt = (xf86Int10InfoPtr)xnfcalloc(1, sizeof(xf86Int10InfoRec));
     pInt->scrnIndex = screen;
     pInt->entityIndex = entityIndex;
     if (!xf86Int10ExecSetup(pInt))
 	goto error0;
     pInt->mem = &linuxMem;
     pagesize = getpagesize();
-    pInt->private = (pointer)xnfcalloc(1,sizeof(linuxInt10Priv));
+    pInt->private = (pointer)xnfcalloc(1, sizeof(linuxInt10Priv));
     ((linuxInt10Priv*)pInt->private)->screen = screen;
-    ((linuxInt10Priv*)pInt->private)->alloc = 
-	(pointer)xnfcalloc(1,ALLOC_ENTRIES(pagesize));
+    ((linuxInt10Priv*)pInt->private)->alloc =
+	(pointer)xnfcalloc(1, ALLOC_ENTRIES(pagesize));
 
 #ifdef DEBUG
     ErrorF("Mapping high memory area\n");
@@ -135,23 +134,23 @@
     ErrorF("Mapping 640kB area\n");
 #endif
     if ((low_mem = shmget(counter++, V_RAM,
-			      IPC_CREAT|SHM_R|SHM_W)) == -1)
+			      IPC_CREAT | SHM_R | SHM_W)) == -1)
 	goto error2;
-    
+
     ((linuxInt10Priv*)pInt->private)->lowMem = low_mem;
-    base = shmat(low_mem,0,0);
+    base = shmat(low_mem, 0, 0);
     ((linuxInt10Priv *)pInt->private)->base = base;
-    base_high = shmat(high_mem,0,0);
-    ((linuxInt10Priv *)pInt->private)->base_high = base_high;
-    
-    MapCurrentInt10(pInt);  
+    base_high = shmat(high_mem, 0, 0);
+    ((linuxInt10Priv*)pInt->private)->base_high = base_high;
+
+    MapCurrentInt10(pInt);
     Int10Current = pInt;
-    
+
 #ifdef DEBUG
     ErrorF("Mapping int area\n");
 #endif
-    if (xf86ReadBIOS(0,0,(unsigned char *)0,LOW_PAGE_SIZE) < 0) {
-	xf86DrvMsg(screen,X_ERROR,"Cannot read int vect\n");
+    if (xf86ReadBIOS(0, 0, (unsigned char *)0, LOW_PAGE_SIZE) < 0) {
+	xf86DrvMsg(screen, X_ERROR, "Cannot read int vect\n");
 	goto error3;
     }
 
@@ -165,33 +164,33 @@
 	if (xf86ReadBIOS(cs, 0, (pointer)cs, V_BIOS_SIZE) < V_BIOS_SIZE)
 	    xf86DrvMsg(screen, X_WARNING,
 		"Unable to retrieve all of segment 0x%06X.\n", cs);
-    
+
     if (xf86IsEntityPrimary(entityIndex)) {
-	cs = ((CARD16*)0)[(0x10<<1)+1];
+	cs = ((CARD16*)0)[(0x10 <<1) + 1];
 	bios_base = (unsigned char *)(cs << 4);
-	
+
 	if (!int10_check_bios(screen, cs, bios_base)) {
-	    cs = ((CARD16*)0)[(0x42<<1)+1];
+	    cs = ((CARD16*)0)[(0x42 << 1) + 1];
 	    bios_base = (unsigned char *)(cs << 4);
 	    if (!int10_check_bios(screen, cs, bios_base)) {
 		cs = V_BIOS >> 4;
 		bios_base = (unsigned char *)(cs << 4);
 		if (!int10_check_bios(screen, cs, bios_base)) {
-		    xf86DrvMsg(screen,X_ERROR,"No V_BIOS found\n");
+		    xf86DrvMsg(screen, X_ERROR, "No V_BIOS found\n");
 		    goto error3;
 		}
 	    }
 	}
-	xf86DrvMsg(screen,X_INFO,"Primary V_BIOS segment is: 0x%x\n",cs);
+	xf86DrvMsg(screen, X_INFO, "Primary V_BIOS segment is: 0x%x\n", cs);
 
 	pInt->BIOSseg = cs;
 	set_return_trap(pInt);
     } else {
-	if (!mapPciRom(pInt,(unsigned char *)(V_BIOS))) {
-	    xf86DrvMsg(screen,X_ERROR,"Cannot read V_BIOS\n");
+	if (!mapPciRom(pInt, (unsigned char *)(V_BIOS))) {
+	    xf86DrvMsg(screen, X_ERROR, "Cannot read V_BIOS\n");
 	    goto error3;
 	}
-	
+
 	pInt->BIOSseg = V_BIOS >> 4;
 	pInt->num = 0xe6;
 	reset_int_vect(pInt);
@@ -201,20 +200,20 @@
 	UnlockLegacyVGA(screen, &vga);
     }
 #ifdef DEBUG
-    dprint(0xc0000,0x20);
+    dprint(0xc0000, 0x20);
 #endif
-    
+
     return pInt;
-    
+
     error3:
     shmdt(base_high);
     shmdt(base);
     shmdt(0);
     shmdt((char*)HIGH_MEM);
-    shmctl(low_mem,IPC_RMID,NULL);
+    shmctl(low_mem, IPC_RMID, NULL);
     Int10Current = NULL;
     error2:
-    shmctl(high_mem,IPC_RMID,NULL);
+    shmctl(high_mem, IPC_RMID,NULL);
     error1:
     xfree(((linuxInt10Priv*)pInt->private)->alloc);
     xfree(pInt->private);
@@ -230,120 +229,119 @@
 	shmdt(0);
 	shmdt((char*)HIGH_MEM);
     }
-    shmat(((linuxInt10Priv *)pInt->private)->lowMem,(char*)1,SHM_RND);
-    shmat(((linuxInt10Priv *)pInt->private)->highMem,(char*)HIGH_MEM,0);
+    shmat(((linuxInt10Priv*)pInt->private)->lowMem, (char*)1, SHM_RND);
+    shmat(((linuxInt10Priv*)pInt->private)->highMem, (char*)HIGH_MEM, 0);
 }
 
 void
 xf86FreeInt10(xf86Int10InfoPtr pInt)
 {
     if (!pInt)
-        return;
+	return;
     if (Int10Current == pInt) {
 	shmdt(0);
 	shmdt((char*)HIGH_MEM);
 	Int10Current = NULL;
     }
-    shmdt(((linuxInt10Priv *)pInt->private)->base_high);
-    shmdt(((linuxInt10Priv *)pInt->private)->base);
-    shmctl(((linuxInt10Priv *)pInt->private)->lowMem,IPC_RMID,NULL);
-    shmctl(((linuxInt10Priv *)pInt->private)->highMem,IPC_RMID,NULL);
+    shmdt(((linuxInt10Priv*)pInt->private)->base_high);
+    shmdt(((linuxInt10Priv*)pInt->private)->base);
+    shmctl(((linuxInt10Priv*)pInt->private)->lowMem, IPC_RMID, NULL);
+    shmctl(((linuxInt10Priv*)pInt->private)->highMem, IPC_RMID, NULL);
     xfree(((linuxInt10Priv*)pInt->private)->alloc);
     xfree(pInt->private);
     xfree(pInt);
 }
 
 void *
-xf86Int10AllocPages(xf86Int10InfoPtr pInt,int num, int *off)
+xf86Int10AllocPages(xf86Int10InfoPtr pInt, int num, int *off)
 {
     int pagesize = getpagesize();
     int num_pages = ALLOC_ENTRIES(pagesize);
-    int i,j;
+    int i, j;
 
-    for (i=0;i<num_pages - num;i++) {
+    for (i = 0; i < (num_pages - num); i++) {
 	if (((linuxInt10Priv*)pInt->private)->alloc[i] == 0) {
-	    for (j=i;j < num + i;j++)
+	    for (j = i; j < (num + i); j++)
 		if ((((linuxInt10Priv*)pInt->private)->alloc[j] != 0))
 		    break;
-	    if (j == num + i)
+	    if (j == (num + i))
 		break;
 	    else
 		i = i + num;
 	}
     }
-    if (i == num_pages - num)
+    if (i == (num_pages - num))
 	return NULL;
-    
-    for (j = i; j < i + num; j++)
+
+    for (j = i; j < (i + num); j++)
 	((linuxInt10Priv*)pInt->private)->alloc[j] = 1;
 
     *off = (i + 1) * pagesize;
-    
-    return (void *)
-	(((linuxInt10Priv*)pInt->private)->base + (i + 1) * pagesize);
+
+    return ((linuxInt10Priv*)pInt->private)->base + ((i + 1) * pagesize);
 }
 
 void
 xf86Int10FreePages(xf86Int10InfoPtr pInt, void *pbase, int num)
 {
     int pagesize = getpagesize();
-    int first = ((unsigned long)pbase
+    int first = (((unsigned long)pbase
 		 - (unsigned long)((linuxInt10Priv*)pInt->private)->base)
-	/ pagesize - 1;
+	/ pagesize) - 1;
     int i;
 
-    for (i = first; i < first + num; i++)
+    for (i = first; i < (first + num); i++)
 	((linuxInt10Priv*)pInt->private)->alloc[i] = 0;
 }
 
 static CARD8
-read_b(xf86Int10InfoPtr pInt,int addr)
+read_b(xf86Int10InfoPtr pInt, int addr)
 {
-    return *((CARD8 *)(addr));
+    return *((CARD8 *)addr);
 }
 
 static CARD16
-read_w(xf86Int10InfoPtr pInt,int addr)
+read_w(xf86Int10InfoPtr pInt, int addr)
 {
-    return *((CARD16 *)(addr));
+    return *((CARD16 *)addr);
 }
 
 static CARD32
-read_l(xf86Int10InfoPtr pInt,int addr)
+read_l(xf86Int10InfoPtr pInt, int addr)
 {
-    return *((CARD32 *)(addr));
+    return *((CARD32 *)addr);
 }
 
 static void
-write_b(xf86Int10InfoPtr pInt,int addr, CARD8 val)
+write_b(xf86Int10InfoPtr pInt, int addr, CARD8 val)
 {
-    *((CARD8 *)(addr)) = (CARD8)val;
+    *((CARD8 *)addr) = val;
 }
 
 static void
-write_w(xf86Int10InfoPtr pInt,int addr, CARD16 val)
+write_w(xf86Int10InfoPtr pInt, int addr, CARD16 val)
 {
-    *((CARD16 *)(addr)) = (CARD16)val;
+    *((CARD16 *)addr) = val;
 }
 
 static
-void write_l(xf86Int10InfoPtr pInt,int addr, CARD32 val)
+void write_l(xf86Int10InfoPtr pInt, int addr, CARD32 val)
 {
-    *((CARD32 *)(addr)) = (CARD32)val;
+    *((CARD32 *)addr) = val;
 }
 
 pointer
 xf86int10Addr(xf86Int10InfoPtr pInt, CARD32 addr)
 {
     if (addr < V_RAM)
-	return  (pointer)(((linuxInt10Priv*)pInt->private)->base + addr);
+	return ((linuxInt10Priv*)pInt->private)->base + addr;
     else if (addr < V_BIOS)
-	return (pointer) addr;
+	return (pointer)addr;
     else if (addr < SYS_BIOS)
-	return  (pointer)(((linuxInt10Priv*)pInt->private)->base_high
+	return (pointer)(((linuxInt10Priv*)pInt->private)->base_high
 			  - V_BIOS + addr);
     else
-	return (pointer) addr;
+	return (pointer)addr;
 }
 
 #ifdef _VM86_LINUX
@@ -355,38 +353,200 @@
 {
 #define VM86S ((struct vm86_struct *)pInt->cpuRegs)
 
-    pInt->cpuRegs = (pointer) xnfcalloc(1,sizeof(struct vm86_struct));
+    pInt->cpuRegs = (pointer)xnfcalloc(1, sizeof(struct vm86_struct));
     VM86S->flags = 0;
     VM86S->screen_bitmap = 0;
     VM86S->cpu_type = CPU_586;
-    memset(&VM86S->int_revectored, 0xff,sizeof(VM86S->int_revectored)) ;
-    memset(&VM86S->int21_revectored, 0xff,sizeof(VM86S->int21_revectored)) ;
+    memset(&VM86S->int_revectored, 0xff, sizeof(VM86S->int_revectored));
+    memset(&VM86S->int21_revectored, 0xff, sizeof(VM86S->int21_revectored));
+    return TRUE;
+}
+
+/* get the linear address */
+#define LIN_PREF_SI ((pref_seg << 4) + X86_SI)
+#define LWECX       ((prefix66 ^ prefix67) ? X86_ECX : X86_CX)
+#define LWECX_ZERO  {if (prefix66 ^ prefix67) X86_ECX = 0; else X86_CX = 0;}
+#define DF (1 << 10)
+
+/* vm86 fault handling */
+static Bool
+vm86_GP_fault(xf86Int10InfoPtr pInt)
+{
+    unsigned char *csp, *lina;
+    CARD32 org_eip;
+    int pref_seg;
+    int done, is_rep, prefix66, prefix67;
+
+    csp = lina = SEG_ADR((unsigned char *), X86_CS, IP);
+
+    is_rep = 0;
+    prefix66 = prefix67 = 0;
+    pref_seg = -1;
+
+    /* eat up prefixes */
+    done = 0;
+    do {
+	switch (MEM_RB(pInt, (int)csp++)) {
+	case 0x66:      /* operand prefix */  prefix66=1; break;
+	case 0x67:      /* address prefix */  prefix67=1; break;
+	case 0x2e:      /* CS */              pref_seg=X86_CS; break;
+	case 0x3e:      /* DS */              pref_seg=X86_DS; break;
+	case 0x26:      /* ES */              pref_seg=X86_ES; break;
+	case 0x36:      /* SS */              pref_seg=X86_SS; break;
+	case 0x65:      /* GS */              pref_seg=X86_GS; break;
+	case 0x64:      /* FS */              pref_seg=X86_FS; break;
+	case 0xf2:      /* repnz */
+	case 0xf3:      /* rep */             is_rep=1; break;
+	default: done=1;
+	}
+    } while (!done);
+    csp--;   /* oops one too many */
+    org_eip = X86_EIP;
+    X86_IP += (csp - lina);
+
+    switch (MEM_RB(pInt, (int)csp)) {
+    case 0x6c:                    /* insb */
+	/* NOTE: ES can't be overwritten; prefixes 66,67 should use esi,edi,ecx
+	 * but is anyone using extended regs in real mode? */
+	/* WARNING: no test for DI wrapping! */
+	X86_EDI += port_rep_inb(pInt, X86_DX, SEG_EADR((CARD32), X86_ES, DI),
+				X86_FLAGS & DF, is_rep ? LWECX : 1);
+	if (is_rep) LWECX_ZERO;
+	X86_IP++;
+	break;
+
+    case 0x6d:                  /* (rep) insw / insd */
+	/* NOTE: ES can't be overwritten */
+	/* WARNING: no test for _DI wrapping! */
+	if (prefix66) {
+	    X86_DI += port_rep_inl(pInt, X86_DX, SEG_ADR((CARD32), X86_ES, DI),
+				   X86_EFLAGS & DF, is_rep ? LWECX : 1);
+	}
+	else {
+	    X86_DI += port_rep_inw(pInt, X86_DX, SEG_ADR((CARD32), X86_ES, DI),
+				   X86_FLAGS & DF, is_rep ? LWECX : 1);
+	}
+	if (is_rep) LWECX_ZERO;
+	X86_IP++;
+	break;
+
+    case 0x6e:                  /* (rep) outsb */
+	if (pref_seg < 0) pref_seg = X86_DS;
+	/* WARNING: no test for _SI wrapping! */
+	X86_SI += port_rep_outb(pInt, X86_DX, (CARD32)LIN_PREF_SI,
+			        X86_FLAGS & DF, is_rep ? LWECX : 1);
+	if (is_rep) LWECX_ZERO;
+	X86_IP++;
+	break;
+
+    case 0x6f:                  /* (rep) outsw / outsd */
+	if (pref_seg < 0) pref_seg = X86_DS;
+	/* WARNING: no test for _SI wrapping! */
+	if (prefix66) {
+	    X86_SI += port_rep_outl(pInt, X86_DX, (CARD32)LIN_PREF_SI,
+				    X86_EFLAGS & DF, is_rep ? LWECX : 1);
+	}
+	else {
+	    X86_SI += port_rep_outw(pInt, X86_DX, (CARD32)LIN_PREF_SI,
+				    X86_FLAGS & DF, is_rep ? LWECX : 1);
+	}
+	if (is_rep) LWECX_ZERO;
+	X86_IP++;
+	break;
+
+    case 0xe5:                  /* inw xx, inl xx */
+	if (prefix66) X86_EAX = x_inl(csp[1]);
+	else X86_AX = x_inw(csp[1]);
+	X86_IP += 2;
+	break;
+
+    case 0xe4:                  /* inb xx */
+	X86_AL = x_inb(csp[1]);
+	X86_IP += 2;
+	break;
+
+    case 0xed:                  /* inw dx, inl dx */
+	if (prefix66) X86_EAX = x_inl(X86_DX);
+	else X86_AX = x_inw(X86_DX);
+	X86_IP += 1;
+	break;
+
+    case 0xec:                  /* inb dx */
+	X86_AL = x_inb(X86_DX);
+	X86_IP += 1;
+	break;
+
+    case 0xe7:                  /* outw xx */
+	if (prefix66) x_outl(csp[1], X86_EAX);
+	else x_outw(csp[1], X86_AX);
+	X86_IP += 2;
+	break;
+
+    case 0xe6:                  /* outb xx */
+	x_outb(csp[1], X86_AL);
+	X86_IP += 2;
+	break;
+
+    case 0xef:                  /* outw dx */
+	if (prefix66) x_outl(X86_DX, X86_EAX);
+	else x_outw(X86_DX, X86_AX);
+	X86_IP += 1;
+	break;
+
+    case 0xee:                  /* outb dx */
+	x_outb(X86_DX, X86_AL);
+	X86_IP += 1;
+	break;
+
+    case 0xf4:
+#ifdef DEBUG
+	ErrorF("hlt at %p\n", lina);
+#endif
+	return FALSE;
+
+    case 0x0f:
+	xf86DrvMsg(pInt->scrnIndex, X_ERROR,
+	    "CPU 0x0f Trap at CS:EIP=0x%4.4x:0x%8.8x\n", X86_CS, X86_EIP);
+	goto op0ferr;
+
+    case 0xf0:                  /* lock */
+    default:
+	xf86DrvMsg(pInt->scrnIndex, X_ERROR, "unknown reason for exception\n");
+
+    op0ferr:
+	dump_registers(pInt);
+	stack_trace(pInt);
+	dump_code(pInt);
+	xf86DrvMsg(pInt->scrnIndex, X_ERROR, "cannot continue\n");
+	return FALSE;
+    }                           /* end of switch() */
     return TRUE;
 }
-    
+
 static int
 do_vm86(xf86Int10InfoPtr pInt)
 {
     int retval, signo;
-    
+
     xf86InterceptSignals(&signo);
     retval = vm86_rep(VM86S);
     xf86InterceptSignals(NULL);
 
     if (signo >= 0) {
-	xf86DrvMsg(pInt->scrnIndex, X_ERROR, "vm86() syscall generated signal %d.\n", signo);
+	xf86DrvMsg(pInt->scrnIndex, X_ERROR,
+	    "vm86() syscall generated signal %d.\n", signo);
 	dump_registers(pInt);
 	dump_code(pInt);
 	stack_trace(pInt);
 	return 0;
     }
-    
+
     switch (VM86_TYPE(retval)) {
     case VM86_UNKNOWN:
 	if (!vm86_GP_fault(pInt)) return 0;
 	break;
     case VM86_STI:
-	xf86DrvMsg(pInt->scrnIndex,X_ERROR,"vm86_sti :-((\n");
+	xf86DrvMsg(pInt->scrnIndex, X_ERROR, "vm86_sti :-((\n");
 	dump_registers(pInt);
 	dump_code(pInt);
 	stack_trace(pInt);
@@ -394,8 +554,8 @@
     case VM86_INTx:
 	pInt->num = VM86_ARG(retval);
 	if (!int_handler(pInt)) {
-	    xf86DrvMsg(pInt->scrnIndex,
-		    X_ERROR,"Unknown vm86_int: 0x%X\n\n",VM86_ARG(retval));
+	    xf86DrvMsg(pInt->scrnIndex, X_ERROR,
+		"Unknown vm86_int: 0x%X\n\n", VM86_ARG(retval));
 	    dump_registers(pInt);
 	    dump_code(pInt);
 	    stack_trace(pInt);
@@ -409,17 +569,17 @@
 	 * we used to warn here and bail out - but now the sigio stuff
 	 * always fires signals at us. So we just ignore them for now.
 	 */
-	xf86DrvMsg(pInt->scrnIndex,X_WARNING,"received signal\n");
+	xf86DrvMsg(pInt->scrnIndex, X_WARNING, "received signal\n");
 	return 0;
     default:
-	xf86DrvMsg(pInt->scrnIndex,X_ERROR,"unknown type(0x%x)=0x%x\n",
-		VM86_ARG(retval),VM86_TYPE(retval));
+	xf86DrvMsg(pInt->scrnIndex, X_ERROR, "unknown type(0x%x)=0x%x\n",
+		VM86_ARG(retval), VM86_TYPE(retval));
 	dump_registers(pInt);
 	dump_code(pInt);
 	stack_trace(pInt);
 	return 0;
     }
-    
+
     return 1;
 }
 
@@ -431,11 +591,11 @@
     if (int_handler(pInt))
 	while(do_vm86(pInt)) {};
 
-    finish_int(pInt,sig);
+    finish_int(pInt, sig);
 }
 
 static int
-vm86_rep(struct vm86_struct *ptr) 
+vm86_rep(struct vm86_struct *ptr)
 {
     int __res;
 
@@ -455,9 +615,9 @@
 			 "b" ((struct vm86_struct *)ptr));
 #endif
 
-	    if ((__res) < 0) {
+	    if (__res < 0) {
 		errno = -__res;
-		__res=-1;
+		__res = -1;
 	    }
 	    else errno = 0;
 	    return __res;
Index: XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/os-support/shared/stdResource.c
===================================================================
RCS file: /cvs/xc/programs/Xserver/hw/xfree86/os-support/shared/stdResource.c,v
retrieving revision 1.15
retrieving revision 1.16
diff -u -r1.15 -r1.16
--- XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/os-support/shared/stdResource.c	2000/04/23 19:27:03	1.15
+++ XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/os-support/shared/stdResource.c	2001/01/06 20:19:15	1.16
@@ -1,4 +1,4 @@
-/* $XFree86: xc/programs/Xserver/hw/xfree86/os-support/shared/stdResource.c,v 1.15 2000/04/23 19:27:03 tsi Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/os-support/shared/stdResource.c,v 1.16 2001/01/06 20:19:15 tsi Exp $ */
 
 /* Standard resource information code */
 
@@ -108,10 +108,12 @@
     RANGE(range,0xffe00000,0xffffffff,ResExcMemBlock | ResBios);
     ret = xf86AddResToList(ret, &range, -1);
 
-    /* Fallback is to claim well known ports in the 0x0 - 0x3ff range */
-    /* Possibly should claim some of them as sparse ranges */
-
-    RANGE(range,0,0x1ff,ResExcIoBlock | ResEstimated);
+    /*
+     * Fallback would be to claim well known ports in the 0x0 - 0x3ff range
+     * along with their sparse I/O aliases, but that's too imprecise.  Instead
+     * claim a bare minimum here.
+     */
+    RANGE(range, 0, 0x00ff, ResExcIoBlock);     /* For mainboard */
     ret = xf86AddResToList(ret, &range, -1);
     /* XXX add others */
     return ret;
--- XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/drivers/vesa/vesa.c.ia64-2	Sat Dec  2 10:31:00 2000
+++ XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/drivers/vesa/vesa.c	Mon Jan 29 11:48:02 2001
@@ -26,7 +26,7 @@
  *
  * Authors: Paulo Csar Pereira de Andrade <pcpa@conectiva.com.br>
  *
- * $XFree86: xc/programs/Xserver/hw/xfree86/drivers/vesa/vesa.c,v 1.8 2000/12/02 15:31:00 tsi Exp $
+ * $XFree86: xc/programs/Xserver/hw/xfree86/drivers/vesa/vesa.c,v 1.9 2001/01/11 03:36:59 tsi Exp $
  */
 
 #include "vesa.h"
@@ -144,14 +144,30 @@
 #endif
     "cfbScreenInit",
     "mfbScreenInit",
+    "cfb24_32ScreenInit",
     NULL
 };
 
 static const char *shadowSymbols[] = {
-    "ShadowInit",
+    "shadowAlloc",
+    "shadowInit",
+    "shadowUpdatePacked",
+    "shadowUpdatePlanar4",
+    "shadowUpdatePlanar4x8",
     NULL
 };
 
+static const char *vbeSymbols[] = {
+    "VBEInit",
+    "vbeDoEDID",
+    NULL
+};
+
+static const char *ddcSymbols[] = {
+    "xf86PrintEDID",
+    "xf86SetDDCproperties",
+    NULL};
+
 #ifdef XFree86LOADER
 
 /* Module loader interface */
@@ -186,7 +202,11 @@
     {
 	Initialised = TRUE;
 	xf86AddDriver(&VESA, Module, 0);
-	LoaderRefSymLists(fbSymbols, shadowSymbols, NULL);
+	LoaderRefSymLists(fbSymbols,
+			  shadowSymbols,
+			  vbeSymbols,
+			  ddcSymbols,
+			  NULL);
 	return (pointer)TRUE;
     }
 
--- XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/loader/elfloader.c.ia64-2	Mon Jan 29 11:48:01 2001
+++ XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/loader/elfloader.c	Mon Jan 29 11:48:02 2001
@@ -2932,10 +2932,6 @@
 {
     ELFModulePtr elffile = (ELFModulePtr)modptr;
     ELFRelocPtr  relptr, reltptr, *brelptr;
-#ifdef __ia64__
-    ELFOpdPtr opdent;
-    ELFPltEntryPtr pltent;
-#endif
 
 /*
  * Delete any unresolved relocations
@@ -2999,16 +2995,33 @@
 #if defined(__alpha__) || defined(__ia64__)
     CheckandFree(elffile->got,elffile->gotsize);
 #endif
-#endif
 #if defined(__ia64__)
     CheckandFree(elffile->plt,elffile->pltsize);
-    while ((pltent = elffile->plt_entries)) {
-	elffile->plt_entries = pltent->next;
-	xf86loaderfree(pltent);
+#endif
+#endif
+#if defined(__alpha__) || defined(__ia64__)
+    {
+	ELFGotEntryPtr gotent;
+	while((gotent = elffile->got_entries)) {
+	    elffile->got_entries = gotent->next;
+	    xf86loaderfree(gotent);
+	}
     }
-    while ((opdent = elffile->opd_entries)) {
-	elffile->opd_entries = opdent->next;
-	xf86loaderfree(opdent);
+#endif
+#if defined(__ia64__)
+    {
+	ELFPltEntryPtr pltent;
+	while ((pltent = elffile->plt_entries)) {
+	    elffile->plt_entries = pltent->next;
+	    xf86loaderfree(pltent);
+	}
+    }
+    {
+	ELFOpdPtr opdent;
+	while ((opdent = elffile->opd_entries)) {
+	    elffile->opd_entries = opdent->next;
+	    xf86loaderfree(opdent);
+	}
     }
 #endif
     CheckandFreeFile(elffile->reltext,elffile->reltxtsize);
--- XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/vgahw/vgaHW.c.ia64-2	Tue Nov 14 13:20:38 2000
+++ XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/vgahw/vgaHW.c	Mon Jan 29 11:48:02 2001
@@ -1,4 +1,4 @@
-/* $XFree86: xc/programs/Xserver/hw/xfree86/vgahw/vgaHW.c,v 1.42 2000/11/14 18:20:38 dawes Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/vgahw/vgaHW.c,v 1.43 2001/01/11 03:37:00 tsi Exp $ */
 
 /*
  *
@@ -1602,10 +1602,21 @@
 	rgb blackColour = scrp->display->blackColour,
 	    whiteColour = scrp->display->whiteColour;
 
-	/* Detect default for black & white */
-	if (!blackColour.red && !blackColour.green && !blackColour.blue &&
-	    !whiteColour.red && !whiteColour.green && !whiteColour.blue)
-	    whiteColour.red = whiteColour.green = whiteColour.blue = 0x3F;
+	if (blackColour.red   > 0x3F) blackColour.red   = 0x3F;
+	if (blackColour.green > 0x3F) blackColour.green = 0x3F;
+	if (blackColour.blue  > 0x3F) blackColour.blue  = 0x3F;
+
+	if (whiteColour.red   > 0x3F) whiteColour.red   = 0x3F;
+	if (whiteColour.green > 0x3F) whiteColour.green = 0x3F;
+	if (whiteColour.blue  > 0x3F) whiteColour.blue  = 0x3F;
+
+	if ((blackColour.red   == whiteColour.red  ) &&
+	    (blackColour.green == whiteColour.green) &&
+	    (blackColour.blue  == whiteColour.blue )) {
+	    blackColour.red   ^= 0x3F;
+	    blackColour.green ^= 0x3F;
+	    blackColour.blue  ^= 0x3F;
+	}
 
         /*
          * initialize default colormap for monochrome
diff -ru XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/loader/elfloader.c /usr/src/redhat/BUILD/XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/loader/elfloader.c
--- XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/loader/elfloader.c	Fri Feb 16 12:03:12 2001
+++ /usr/src/redhat/BUILD/XFree86-4.0.2/xc/programs/Xserver/hw/xfree86/loader/elfloader.c	Thu Feb 15 18:40:55 2001
@@ -2920,7 +2920,9 @@
 	flag = _LoaderHandleUnresolved(
 	    name, _LoaderHandleToName(erel->file->handle));
 	if(flag) fatalsym = 1;
-	xf86loaderfree(name);
+#ifndef __ia64__
+	xf86loaderfree(name); 
+#endif    
 	erel=erel->next;
     }
     return fatalsym;
