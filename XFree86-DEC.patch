diff -ur xc.orig/programs/Xserver/hw/xfree86/common/compiler.h xc/programs/Xserver/hw/xfree86/common/compiler.h
--- xc.orig/programs/Xserver/hw/xfree86/common/compiler.h	Fri Dec  8 22:58:34 2000
+++ xc/programs/Xserver/hw/xfree86/common/compiler.h	Sun Mar 18 17:23:33 2001
@@ -1514,19 +1514,17 @@
 /* Changed to kill noise generated by gcc's -Wcast-align */
 #define MMIO_IN8(base, offset) (*xf86ReadMmio8)(base, offset)
 #define MMIO_IN16(base, offset) (*xf86ReadMmio16)(base, offset)
-# if defined (JENSEN_SUPPORT)
 #define MMIO_IN32(base, offset) (*xf86ReadMmio32)(base, offset)
+# if defined (JENSEN_SUPPORT)
 #define MMIO_OUT32(base, offset, val) \
     (*xf86WriteMmio32)((CARD32)(val), base, offset)
 #define MMIO_ONB32(base, offset, val) \
     (*xf86WriteMmioNB32)((CARD32)(val), base, offset)
 # else
-#define MMIO_IN32(base, offset) \
-	*(volatile CARD32 *)(void *)(((CARD8*)(base)) + (offset))
 #define MMIO_OUT32(base, offset, val) \
     do { \
-	*(volatile CARD32 *)(void *)(((CARD8*)(base)) + (offset)) = (val); \
 	write_mem_barrier(); \
+	*(volatile CARD32 *)(void *)(((CARD8*)(base)) + (offset)) = (val); \
     } while (0)
 #define MMIO_ONB32(base, offset, val) \
 	*(volatile CARD32 *)(void *)(((CARD8*)(base)) + (offset)) = (val)
diff -ur xc.orig/programs/Xserver/hw/xfree86/drivers/ati/r128_accel.c xc/programs/Xserver/hw/xfree86/drivers/ati/r128_accel.c
--- xc.orig/programs/Xserver/hw/xfree86/drivers/ati/r128_accel.c	Mon Dec  4 19:55:22 2000
+++ xc/programs/Xserver/hw/xfree86/drivers/ati/r128_accel.c	Sun Apr  1 20:51:03 2001
@@ -838,6 +838,7 @@
     if (info->scanline_direct) return;
     --info->scanline_h;
     while (left) {
+        write_mem_barrier();
 	if (left <= 8) {
 	  /* Last scanline - finish write to DATA_LAST */
 	  if (info->scanline_h == 0) {
@@ -980,6 +981,7 @@
     if (info->scanline_direct) return;
     --info->scanline_h;
     while (left) {
+        write_mem_barrier();
 	if (left <= 8) {
 	  /* Last scanline - finish write to DATA_LAST */
 	  if (info->scanline_h == 0) {
diff -ur xc.orig/programs/Xserver/hw/xfree86/drivers/ati/r128_driver.c xc/programs/Xserver/hw/xfree86/drivers/ati/r128_driver.c
--- xc.orig/programs/Xserver/hw/xfree86/drivers/ati/r128_driver.c	Sat Mar 17 17:57:15 2001
+++ xc/programs/Xserver/hw/xfree86/drivers/ati/r128_driver.c	Sun Mar 18 16:51:29 2001
@@ -1016,8 +1016,8 @@
     if (!xf86LoadSubModule(pScrn, "ddc")) return FALSE;
     xf86LoaderReqSymLists(ddcSymbols, NULL);
 
-#if defined(__powerpc__)
-    /* Int10 is broken on PPC */
+#if defined(__powerpc__) || defined(__alpha__)
+    /* Int10 is broken on PPC and some Alphas */
     return TRUE;
 #else
     if (xf86LoadSubModule(pScrn, "vbe")) {
@@ -1156,7 +1156,8 @@
 static Bool R128PreInitInt10(ScrnInfoPtr pScrn)
 {
     R128InfoPtr   info = R128PTR(pScrn);
-#if 1
+#if 1 && !defined(__alpha__)
+    /* int10 is broken on some Alphas */
     if (xf86LoadSubModule(pScrn, "int10")) {
 	xf86Int10InfoPtr pInt;
 	xf86DrvMsg(pScrn->scrnIndex,X_INFO,"initializing int10\n");
diff -ur xc.orig/programs/Xserver/hw/xfree86/drivers/ati/radeon_accel.c xc/programs/Xserver/hw/xfree86/drivers/ati/radeon_accel.c
--- xc.orig/programs/Xserver/hw/xfree86/drivers/ati/radeon_accel.c	Wed Nov 29 11:42:11 2000
+++ xc/programs/Xserver/hw/xfree86/drivers/ati/radeon_accel.c	Fri Mar 23 16:20:46 2001
@@ -585,7 +585,13 @@
     info->scanline_h      = h;
     info->scanline_words  = (w + 31) >> 5;
 
-    if ((info->scanline_words * h) <= 9) {
+#ifdef __alpha__
+    /* always indirect for Alpha */
+    if (0)
+#else
+    if ((info->scanline_words * h) <= 9)
+#endif
+    {
 	/* Turn on direct for less than 9 dword colour expansion */
 	info->scratch_buffer[0]
 	    = (unsigned char *)(ADDRREG(RADEON_HOST_DATA_LAST)
@@ -621,6 +627,7 @@
     if (info->scanline_direct) return;
     --info->scanline_h;
     while (left) {
+        write_mem_barrier();
 	if (left <= 8) {
 	  /* Last scanline - finish write to DATA_LAST */
 	  if (info->scanline_h == 0) {
@@ -699,7 +706,13 @@
     info->scanline_h      = h;
     info->scanline_words  = (w * info->scanline_bpp + 31) >> 5;
 
-    if ((info->scanline_words * h) <= 9) {
+#ifdef __alpha__
+    /* always indirect for Alpha */
+    if (0)
+#else
+    if ((info->scanline_words * h) <= 9)
+#endif
+    {
 	/* Turn on direct for less than 9 dword colour expansion */
 	info->scratch_buffer[0]
 	    = (unsigned char *)(ADDRREG(RADEON_HOST_DATA_LAST)
@@ -735,6 +748,7 @@
     if (info->scanline_direct) return;
     --info->scanline_h;
     while (left) {
+        write_mem_barrier();
 	if (left <= 8) {
 	  /* Last scanline - finish write to DATA_LAST */
 	  if (info->scanline_h == 0) {
diff -ur xc.orig/programs/Xserver/hw/xfree86/drivers/glint/dualmx_accel.c xc/programs/Xserver/hw/xfree86/drivers/glint/dualmx_accel.c
--- xc.orig/programs/Xserver/hw/xfree86/drivers/glint/dualmx_accel.c	Sat Jun 24 14:19:54 2000
+++ xc/programs/Xserver/hw/xfree86/drivers/glint/dualmx_accel.c	Sun Mar 18 16:53:54 2001
@@ -324,28 +324,6 @@
     GLINT_WRITE_REG(d<<16,dY);
 }
 
-static void MoveDWORDS(
-   register CARD32* dest,
-   register CARD32* src,
-   register int dwords )
-{
-     while(dwords & ~0x03) {
-	*dest = *src;
-	*(dest + 1) = *(src + 1);
-	*(dest + 2) = *(src + 2);
-	*(dest + 3) = *(src + 3);
-	src += 4;
-	dest += 4;
-	dwords -= 4;
-     }	
-     if (!dwords) return;
-     *dest = *src;
-     if (dwords == 1) return;
-     *(dest + 1) = *(src + 1);
-     if (dwords == 2) return;
-     *(dest + 2) = *(src + 2);
-}
-
 #define Sync_tag 0x188
 
 static void
@@ -572,7 +550,8 @@
     while (dwords >= infoRec->ColorExpandRange) {
     	GLINT_WAIT(infoRec->ColorExpandRange);
     	GLINT_WRITE_REG((infoRec->ColorExpandRange - 2)<<16 | 0x0D, OutputFIFO);
-    	MoveDWORDS((CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4), src,
+    	GLINT_MoveDWORDS(
+		(CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4), src,
 		infoRec->ColorExpandRange - 1);
     	dwords -= (infoRec->ColorExpandRange - 1);
 	src += (infoRec->ColorExpandRange - 1);
@@ -580,7 +559,8 @@
     if (dwords) {
     	GLINT_WAIT(dwords);
     	GLINT_WRITE_REG((dwords - 1)<<16 | 0x0D, OutputFIFO);
-    	MoveDWORDS((CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4), src,dwords);
+    	GLINT_MoveDWORDS(
+		(CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4), src,dwords);
     }
     pGlint->cpucount += 1;
 #if 0
@@ -887,7 +867,8 @@
 	/* (0x15 << 4) | 0x05 is the TAG for FBSourceData */
        	GLINT_WRITE_REG(((infoRec->ColorExpandRange - 2) << 16) | (0x15 << 4) | 
 				0x05, OutputFIFO);
-	MoveDWORDS((CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4),
+	GLINT_MoveDWORDS(
+		(CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4),
  		(CARD32*)srcp, infoRec->ColorExpandRange - 1);
 	count -= infoRec->ColorExpandRange - 1;
 	srcp += infoRec->ColorExpandRange - 1;
@@ -897,7 +878,8 @@
 	/* (0x15 << 4) | 0x05 is the TAG for FBSourceData */
        	GLINT_WRITE_REG(((count - 1) << 16) | (0x15 << 4) | 
 				0x05, OutputFIFO);
-	MoveDWORDS((CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4),
+	GLINT_MoveDWORDS(
+		(CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4),
  		(CARD32*)srcp, count);
       }
       src += srcwidth;
diff -ur xc.orig/programs/Xserver/hw/xfree86/drivers/glint/glint.h xc/programs/Xserver/hw/xfree86/drivers/glint/glint.h
--- xc.orig/programs/Xserver/hw/xfree86/drivers/glint/glint.h	Wed Nov 29 11:42:16 2000
+++ xc/programs/Xserver/hw/xfree86/drivers/glint/glint.h	Sun Mar 18 21:36:41 2001
@@ -120,6 +120,7 @@
     Bool		UseBlockWrite;
     Bool		UseFireGL3000;
     Bool		VGAcore;
+    Bool		ScanlineDirect;
     int			MXFbSize;
     CARD32		rasterizerMode;
     int			MinClock;
@@ -141,6 +142,7 @@
     DrawablePtr		CurrentDrawable;
     I2CBusPtr		DDCBus, VSBus;
     CARD8*		XAAScanlineColorExpandBuffers[2];
+    CARD8*		ScratchBuffer;
     CARD32		RasterizerSwap;
     int			PM3_Config2D;
     int			PM3_Render2D;
@@ -282,6 +284,10 @@
     			  LOCO *colors, VisualPtr pVisual);
 void Permedia2LoadPalette16(ScrnInfoPtr pScrn, int numColors, int *indices,
     			  LOCO *colors, VisualPtr pVisual);
+void Permedia3LoadPalette(ScrnInfoPtr pScrn, int numColors, int *indices,
+    			  LOCO *colors, VisualPtr pVisual);
+void Permedia3LoadPalette16(ScrnInfoPtr pScrn, int numColors, int *indices,
+    			  LOCO *colors, VisualPtr pVisual);
 void Permedia2I2CUDelay(I2CBusPtr b, int usec);
 void Permedia2I2CPutBits(I2CBusPtr b, int scl, int sda);
 void Permedia2I2CGetBits(I2CBusPtr b, int *scl, int *sda);
@@ -314,4 +320,8 @@
 CARD32 GLINT_VERB_READ_REG(GLINTPtr, CARD32 r, char *file, int line);
 
 void GLINTRefreshArea(ScrnInfoPtr pScrn, int num, BoxPtr pbox);
+
+void GLINT_MoveBYTES(CARD32* dest, unsigned char* src, int dwords);
+void GLINT_MoveWORDS(CARD32* dest, unsigned short* src, int dwords);
+void GLINT_MoveDWORDS(CARD32* dest, CARD32* src, int dwords);
 #endif /* _GLINT_H_ */
diff -ur xc.orig/programs/Xserver/hw/xfree86/drivers/glint/glint_driver.c xc/programs/Xserver/hw/xfree86/drivers/glint/glint_driver.c
--- xc.orig/programs/Xserver/hw/xfree86/drivers/glint/glint_driver.c	Fri Dec  8 22:58:55 2000
+++ xc/programs/Xserver/hw/xfree86/drivers/glint/glint_driver.c	Sun Mar 18 21:39:59 2001
@@ -2610,8 +2610,17 @@
     if (!miCreateDefColormap(pScreen))
 	return FALSE;
 
+    if (pGlint->Chipset == PCI_VENDOR_3DLABS_CHIP_PERMEDIA3) {
+    	if (!xf86HandleColormaps(pScreen, 256, pScrn->rgbBits,
+	    (pGlint->FBDev) ? fbdevHWLoadPalette : 
+	    ((pScrn->depth == 16) ? Permedia3LoadPalette16:Permedia3LoadPalette),
+	    NULL,
+	    CMAP_RELOAD_ON_MODE_SWITCH |
+	    ((pScrn->overlayFlags & OVERLAY_8_32_PLANAR) 
+					? 0 : CMAP_PALETTED_TRUECOLOR)))
+	return FALSE;
+    } else
     if ((pGlint->Chipset == PCI_VENDOR_3DLABS_CHIP_PERMEDIA2V) ||
-	(pGlint->Chipset == PCI_VENDOR_3DLABS_CHIP_PERMEDIA3) || 
 	(pGlint->Chipset == PCI_VENDOR_3DLABS_CHIP_PERMEDIA2) || 
 	(pGlint->Chipset == PCI_VENDOR_TI_CHIP_PERMEDIA2)) {
     	if (!xf86HandleColormaps(pScreen, 256, pScrn->rgbBits,
@@ -3051,16 +3060,86 @@
 {
     if (xf86GetVerbosity() > 2)
 	ErrorF("[0x%04x] <- 0x%08x (%s, %d)\n",	r, v, file, line);
+#if defined(__alpha__)
+    GLINT_WRITE_REG(v, r);
+#else
     *(volatile CARD32 *)((char *) pGlint->IOBase + r) = v;
+#endif
 }
 
 CARD32
 GLINT_VERB_READ_REG(GLINTPtr pGlint, CARD32 r, char *file, int line)
 {
-    CARD32 v = *(volatile CARD32 *)((char *) pGlint->IOBase + r);
+    CARD32 v;
 
+#if defined(__alpha__)
+    v = GLINT_READ_REG(r);
+#else
+    v = *(volatile CARD32 *)((char *) pGlint->IOBase + r);
+#endif
     if (xf86GetVerbosity() > 2)
 	ErrorF("[0x%04x] -> 0x%08x (%s, %d)\n", r, v, file, line);
     return v;
 }
 #endif
+
+void GLINT_MoveBYTES(
+   register CARD32* dest,
+   register unsigned char* src,
+   register int dwords)
+{
+#if defined(__alpha__)
+    write_mem_barrier();
+#endif
+    while(dwords) {
+        *dest = *src;
+	src += 1;
+	dest += 1;
+	dwords -= 1;
+    }	
+}
+
+void GLINT_MoveWORDS(
+   register CARD32* dest,
+   register unsigned short* src,
+   register int dwords)
+{
+#if defined(__alpha__)
+    write_mem_barrier();
+#endif
+    while(dwords & ~0x01) {
+        *dest = *src;
+	*(dest + 1) = *(src + 1);
+	src += 2;
+	dest += 2;
+	dwords -= 2;
+    }	
+    if(dwords)
+        *dest = *src;
+    return;
+}
+
+void GLINT_MoveDWORDS(
+   register CARD32* dest,
+   register CARD32* src,
+   register int dwords)
+{
+#if defined(__alpha__)
+    write_mem_barrier();
+#endif
+    while(dwords & ~0x03) {
+        *dest = *src;
+	*(dest + 1) = *(src + 1);
+	*(dest + 2) = *(src + 2);
+	*(dest + 3) = *(src + 3);
+	src += 4;
+	dest += 4;
+	dwords -= 4;
+    }	
+    if (!dwords) return;
+    *dest = *src;
+    if (dwords == 1) return;
+    *(dest + 1) = *(src + 1);
+    if (dwords == 2) return;
+    *(dest + 2) = *(src + 2);
+}
diff -ur xc.orig/programs/Xserver/hw/xfree86/drivers/glint/glint_regs.h xc/programs/Xserver/hw/xfree86/drivers/glint/glint_regs.h
--- xc.orig/programs/Xserver/hw/xfree86/drivers/glint/glint_regs.h	Fri Oct 27 21:23:07 2000
+++ xc/programs/Xserver/hw/xfree86/drivers/glint/glint_regs.h	Sun Mar 18 17:05:13 2001
@@ -1201,10 +1201,17 @@
         
 #define GLINT_SLOW_WRITE_REG(v,r)				\
 do{								\
-	GLINTDACDelay(5);					\
+	mem_barrier();						\
+        GLINT_WAIT(1);						\
+	mem_barrier();						\
         GLINT_WRITE_REG(v,r);					\
-	GLINTDACDelay(5);					\
 }while(0)
+
+#define GLINT_SET_INDEX(index)					\
+do{								\
+	GLINT_SLOW_WRITE_REG(((index)>>8)&0xff,PM2VDACIndexRegHigh);	\
+	GLINT_SLOW_WRITE_REG((index)&0xff,PM2VDACIndexRegLow);	\
+} while(0)
 
 #define GLINT_SECONDARY_SLOW_WRITE_REG(v,r)				\
 do{									\
diff -ur xc.orig/programs/Xserver/hw/xfree86/drivers/glint/pm2_accel.c xc/programs/Xserver/hw/xfree86/drivers/glint/pm2_accel.c
--- xc.orig/programs/Xserver/hw/xfree86/drivers/glint/pm2_accel.c	Fri Mar 31 17:55:43 2000
+++ xc/programs/Xserver/hw/xfree86/drivers/glint/pm2_accel.c	Sun Mar 18 16:55:14 2001
@@ -356,8 +356,6 @@
 			Permedia2SubsequentColorExpandScanline;
     }
 
-    infoPtr->ColorExpandRange = MAX_FIFO_ENTRIES;
-
     infoPtr->WriteBitmap = Permedia2WriteBitmap;
 
     if (pScrn->bitsPerPixel == 8)
@@ -427,10 +425,14 @@
     CHECKCLIPPING;
 
     while (GLINT_READ_REG(DMACount) != 0);
-    GLINT_WAIT(1);
-    GLINT_WRITE_REG(0, GlintSync);
+
+    GLINT_SLOW_WRITE_REG(0xc00, FilterMode);
+
+    GLINT_WAIT(2);
+    GLINT_SLOW_WRITE_REG(0, GlintSync);
+
     do {
-   	while(GLINT_READ_REG(OutFIFOWords) == 0);
+        while(GLINT_READ_REG(OutFIFOWords) == 0);
 #define Sync_tag 0x188
     } while (GLINT_READ_REG(OutputFIFO) != Sync_tag);
 }
@@ -733,63 +735,6 @@
     TRACE_EXIT("Permedia2SubsequentFillRectSolid");
 }
 
-static void MoveBYTE(
-   register CARD32* dest,
-   register unsigned char* src,
-   register int dwords
-)
-{
-     while(dwords) {
-	*dest = *src;
-	src += 1;
-	dest += 1;
-	dwords -= 1;
-     }	
-}
-
-static void MoveWORDS(
-   register CARD32* dest,
-   register unsigned short* src,
-   register int dwords
-)
-{
-     while(dwords & ~0x01) {
-	*dest = *src;
-	*(dest + 1) = *(src + 1);
-	src += 2;
-	dest += 2;
-	dwords -= 2;
-     }	
-     switch(dwords) {
-	case 0:	return;
-	case 1: *dest = *src;
-		return;
-    }
-}
-
-static void MoveDWORDS(
-   register CARD32* dest,
-   register CARD32* src,
-   register int dwords )
-{
-     while(dwords & ~0x03) {
-	*dest = *src;
-	*(dest + 1) = *(src + 1);
-	*(dest + 2) = *(src + 2);
-	*(dest + 3) = *(src + 3);
-	src += 4;
-	dest += 4;
-	dwords -= 4;
-     }	
-     if (!dwords) return;
-     *dest = *src;
-     if (dwords == 1) return;
-     *(dest + 1) = *(src + 1);
-     if (dwords == 2) return;
-     *(dest + 2) = *(src + 2);
-}
-
-
 static void 
 Permedia2SetupForMono8x8PatternFill24bpp(ScrnInfoPtr pScrn, 
 					   int patternx, int patterny, 
@@ -1117,10 +1062,10 @@
     Permedia2SetClippingRectangle(pScrn,x+skipleft,y,x+w,y+h);
  
     if (pScrn->bitsPerPixel == 24) {
-	GLINT_WAIT(10);
+        GLINT_WAIT(10);
     } else {
         GLINT_WAIT(11);
-        DO_PLANEMASK(planemask);
+	DO_PLANEMASK(planemask);
     }
     LOADROP(rop);
     Permedia2LoadCoord(pScrn, x&0xFFFF, y, w, h);
@@ -1137,39 +1082,40 @@
 	mode = 0;
 	GLINT_WRITE_REG(UNIT_ENABLE, ColorDDAMode);
 	GLINT_WRITE_REG(BitMaskPackingEachScanline|
-		pGlint->RasterizerSwap,RasterizerMode);
+			pGlint->RasterizerSwap,RasterizerMode);
     }
 
     if(bg == -1) {
 	/* >>>>> set fg <<<<<<<< */
 	REPLICATE(fg);
-    if ((pScrn->bitsPerPixel != 24) && (rop == GXcopy)) {
-	    GLINT_WRITE_REG(fg, FBBlockColor);
+	if ((pScrn->bitsPerPixel != 24) && (rop == GXcopy)) {
+	  GLINT_WRITE_REG(fg, FBBlockColor);
 	} else {
-	    GLINT_WRITE_REG(fg, ConstantColor);
+	  GLINT_WRITE_REG(fg, ConstantColor);
 	}
     } else if(rop == GXcopy) {
-	/* >>>>> set bg <<<<<<< */
- 	/* >>>>> draw rect (x,y,w,h) */
-	REPLICATE(bg);
-    if ((pScrn->bitsPerPixel != 24) && (rop == GXcopy)) {
+        /* >>>>> set bg <<<<<<< */
+        /* >>>>> draw rect (x,y,w,h) */
+        REPLICATE(bg);
+	if ((pScrn->bitsPerPixel != 24) && (rop == GXcopy)) {
 	    GLINT_WRITE_REG(bg, FBBlockColor);
 	} else {
 	    GLINT_WRITE_REG(bg, ConstantColor);
 	}
-	GLINT_WRITE_REG(PrimitiveRectangle | XPositive | YPositive |mode,Render);
+	GLINT_WRITE_REG(PrimitiveRectangle | XPositive | YPositive |mode,
+			Render);
 	/* >>>>>> set fg <<<<<< */
 	REPLICATE(fg);
-    if ((pScrn->bitsPerPixel != 24) && (rop == GXcopy)) {
+	if ((pScrn->bitsPerPixel != 24) && (rop == GXcopy)) {
 	    GLINT_WRITE_REG(fg, FBBlockColor);
 	} else {
 	    GLINT_WRITE_REG(fg, ConstantColor);
 	}
     } else {
-	SecondPass = TRUE;
+        SecondPass = TRUE;
 	/* >>>>> set fg <<<<<<< */
 	REPLICATE(fg);
-    if ((pScrn->bitsPerPixel != 24) && (rop == GXcopy)) {
+	if ((pScrn->bitsPerPixel != 24) && (rop == GXcopy)) {
 	    GLINT_WRITE_REG(fg, FBBlockColor);
 	} else {
 	    GLINT_WRITE_REG(fg, ConstantColor);
@@ -1188,8 +1134,8 @@
     	GLINT_WAIT(dwords);
     	/* 0x0D is the TAG value for BitMaskPattern */
     	GLINT_WRITE_REG(((dwords - 1) << 16) | 0x0D, OutputFIFO);
-   	MoveDWORDS((CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4),
-		(CARD32 *)srcpntr, dwords);
+   	GLINT_MoveDWORDS((CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4),
+			 (CARD32 *)srcpntr, dwords);
 	srcpntr += srcwidth;
     }   
 
@@ -1198,12 +1144,13 @@
 	/* >>>>>> invert bitmask and set bg <<<<<<<< */
 	REPLICATE(bg);
 	GLINT_WAIT(3);
-    if ((pScrn->bitsPerPixel != 24) && (rop == GXcopy)) {
-   	    GLINT_WRITE_REG(InvertBitMask|pGlint->RasterizerSwap,RasterizerMode);
+	if ((pScrn->bitsPerPixel != 24) && (rop == GXcopy)) {
+	    GLINT_WRITE_REG(InvertBitMask|pGlint->RasterizerSwap,
+			    RasterizerMode);
 	    GLINT_WRITE_REG(bg, FBBlockColor);
 	} else {
-    	    GLINT_WRITE_REG(InvertBitMask|BitMaskPackingEachScanline|
-    	    			pGlint->RasterizerSwap, RasterizerMode);
+	    GLINT_WRITE_REG(InvertBitMask|BitMaskPackingEachScanline|
+			    pGlint->RasterizerSwap, RasterizerMode);
 	    GLINT_WRITE_REG(bg, ConstantColor);
 	}
 	goto SECOND_PASS;
@@ -1276,13 +1223,15 @@
 	      count = dwords;
 	      address = ((y * pScrn->displayWidth) + x) >> 2;
 	      srcp = (CARD32*)src;
+	      GLINT_WAIT(1);
 	      GLINT_WRITE_REG(address, TextureDownloadOffset);
 	      while(count >= MAX_FIFO_ENTRIES) {
     	    	GLINT_WAIT(MAX_FIFO_ENTRIES);
 		/* (0x11 << 4) | 0x0D is the TAG for TextureData */
         	GLINT_WRITE_REG(((MAX_FIFO_ENTRIES - 2) << 16) | (0x11 << 4) |
 						0x0D, OutputFIFO);
-		MoveDWORDS((CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4),
+		GLINT_MoveDWORDS(
+			(CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4),
 	 		(CARD32*)srcp, MAX_FIFO_ENTRIES - 1);
 		count -= MAX_FIFO_ENTRIES - 1;
 		address += MAX_FIFO_ENTRIES - 1;
@@ -1293,7 +1242,8 @@
 		/* (0x11 << 4) | 0x0D is the TAG for TextureData */
         	GLINT_WRITE_REG(((count - 1) << 16) | (0x11 << 4) | 0x0D,
 					 OutputFIFO);
-		MoveDWORDS((CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4),
+		GLINT_MoveDWORDS(
+			(CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4),
 	 		(CARD32*)srcp, count);
 	      }
 	      src += srcwidth;
@@ -1304,7 +1254,7 @@
 	} else {
   	   char align = (x & pGlint->bppalign);
 		
-
+	   GLINT_WAIT(1);
 	   GLINT_WRITE_REG(UNIT_DISABLE, ColorDDAMode);
 	   if (rop == GXcopy) {
 	     GLINT_WAIT(6);
@@ -1329,7 +1279,8 @@
 		/* (0x15 << 4) | 0x05 is the TAG for FBSourceData */
         	GLINT_WRITE_REG(((MAX_FIFO_ENTRIES - 2) << 16) | (0x15 << 4) | 
 					0x05, OutputFIFO);
-		MoveDWORDS((CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4),
+		GLINT_MoveDWORDS(
+			(CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4),
 	 		(CARD32*)srcp, MAX_FIFO_ENTRIES - 1);
 		count -= MAX_FIFO_ENTRIES - 1;
 		srcp += MAX_FIFO_ENTRIES - 1;
@@ -1339,7 +1290,8 @@
 		/* (0x15 << 4) | 0x05 is the TAG for FBSourceData */
         	GLINT_WRITE_REG(((count - 1) << 16) | (0x15 << 4) | 
 					0x05, OutputFIFO);
-		MoveDWORDS((CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4),
+		GLINT_MoveDWORDS(
+			(CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4),
 	 		(CARD32*)srcp, count);
 	      }
 	      src += srcwidth;
@@ -1353,7 +1305,8 @@
 		/* (0x15 << 4) | 0x05 is the TAG for FBSourceData */
         	GLINT_WRITE_REG(((MAX_FIFO_ENTRIES - 2) << 16) | (0x15 << 4) | 
 					0x05, OutputFIFO);
-		MoveBYTE((CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4),
+		GLINT_MoveBYTES(
+			(CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4),
 	 		(unsigned char *)srcpbyte, MAX_FIFO_ENTRIES - 1);
 		count -= MAX_FIFO_ENTRIES - 1;
 		srcpbyte += MAX_FIFO_ENTRIES - 1;
@@ -1363,7 +1316,8 @@
 		/* (0x15 << 4) | 0x05 is the TAG for FBSourceData */
         	GLINT_WRITE_REG(((count - 1) << 16) | (0x15 << 4) | 
 					0x05, OutputFIFO);
-		MoveBYTE((CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4),
+		GLINT_MoveBYTES(
+			(CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4),
 	 		(unsigned char *)srcpbyte, count);
 	      }
 	      src += srcwidth;
@@ -1435,13 +1389,15 @@
 	      count = dwords;
 	      address = ((y * pScrn->displayWidth) + x) >> 1;
 	      srcp = (CARD32*)src;
+	      GLINT_WAIT(1);
 	      GLINT_WRITE_REG(address, TextureDownloadOffset);
 	      while(count >= MAX_FIFO_ENTRIES) {
     	    	GLINT_WAIT(MAX_FIFO_ENTRIES);
 		/* (0x11 << 4) | 0x0D is the TAG for TextureData */
         	GLINT_WRITE_REG(((MAX_FIFO_ENTRIES - 2) << 16) | (0x11 << 4) |
 						0x0D, OutputFIFO);
-		MoveDWORDS((CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4),
+		GLINT_MoveDWORDS(
+			(CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4),
 	 		(CARD32*)srcp, MAX_FIFO_ENTRIES - 1);
 		count -= MAX_FIFO_ENTRIES - 1;
 		address += MAX_FIFO_ENTRIES - 1;
@@ -1452,7 +1408,8 @@
 		/* (0x11 << 4) | 0x0D is the TAG for TextureData */
         	GLINT_WRITE_REG(((count - 1) << 16) | (0x11 << 4) | 0x0D,
 					 OutputFIFO);
-		MoveDWORDS((CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4),
+		GLINT_MoveDWORDS(
+			(CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4),
 	 		(CARD32*)srcp, count);
 	      }
 	      src += srcwidth;
@@ -1488,7 +1445,8 @@
 		/* (0x15 << 4) | 0x05 is the TAG for FBSourceData */
         	GLINT_WRITE_REG(((MAX_FIFO_ENTRIES - 2) << 16) | (0x15 << 4) | 
 					0x05, OutputFIFO);
-		MoveDWORDS((CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4),
+		GLINT_MoveDWORDS(
+			(CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4),
 	 		(CARD32*)srcp, MAX_FIFO_ENTRIES - 1);
 		count -= MAX_FIFO_ENTRIES - 1;
 		srcp += MAX_FIFO_ENTRIES - 1;
@@ -1498,7 +1456,8 @@
 		/* (0x15 << 4) | 0x05 is the TAG for FBSourceData */
         	GLINT_WRITE_REG(((count - 1) << 16) | (0x15 << 4) | 
 					0x05, OutputFIFO);
-		MoveDWORDS((CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4),
+		GLINT_MoveDWORDS(
+			(CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4),
 	 		(CARD32*)srcp, count);
 	      }
 	      src += srcwidth;
@@ -1512,7 +1471,8 @@
 		/* (0x15 << 4) | 0x05 is the TAG for FBSourceData */
         	GLINT_WRITE_REG(((MAX_FIFO_ENTRIES - 2) << 16) | (0x15 << 4) | 
 					0x05, OutputFIFO);
-		MoveWORDS((CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4),
+		GLINT_MoveWORDS(
+			(CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4),
 	 		(unsigned short *)srcpword, MAX_FIFO_ENTRIES - 1);
 		count -= MAX_FIFO_ENTRIES - 1;
 		srcpword += MAX_FIFO_ENTRIES - 1;
@@ -1522,7 +1482,8 @@
 		/* (0x15 << 4) | 0x05 is the TAG for FBSourceData */
         	GLINT_WRITE_REG(((count - 1) << 16) | (0x15 << 4) | 
 					0x05, OutputFIFO);
-		MoveWORDS((CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4),
+		GLINT_MoveWORDS(
+			(CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4),
 	 		(unsigned short *)srcpword, count);
 	      }
 	      src += srcwidth;
@@ -1590,7 +1551,8 @@
 		/* (0x15 << 4) | 0x05 is the TAG for FBSourceData */
         	GLINT_WRITE_REG(((MAX_FIFO_ENTRIES - 2) << 16) | (0x15 << 4) | 
 					0x05, OutputFIFO);
-		MoveBYTE((CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4),
+		GLINT_MoveBYTES(
+			(CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4),
 	 		(unsigned char *)srcpbyte, MAX_FIFO_ENTRIES - 1);
 		count -= MAX_FIFO_ENTRIES - 1;
 		srcpbyte += MAX_FIFO_ENTRIES - 1;
@@ -1600,7 +1562,8 @@
 		/* (0x15 << 4) | 0x05 is the TAG for FBSourceData */
         	GLINT_WRITE_REG(((count - 1) << 16) | (0x15 << 4) | 
 					0x05, OutputFIFO);
-		MoveBYTE((CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4),
+		GLINT_MoveBYTES(
+			(CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4),
 	 		(unsigned char *)srcpbyte, count);
 	      }
 	      src += srcwidth;
@@ -1613,7 +1576,8 @@
 		/* (0x15 << 4) | 0x05 is the TAG for FBSourceData */
         	GLINT_WRITE_REG(((MAX_FIFO_ENTRIES - 2) << 16) | (0x15 << 4) | 
 					0x05, OutputFIFO);
-		MoveDWORDS((CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4),
+		GLINT_MoveDWORDS(
+			(CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4),
 	 		(CARD32*)srcp, MAX_FIFO_ENTRIES - 1);
 		count -= MAX_FIFO_ENTRIES - 1;
 		srcp += MAX_FIFO_ENTRIES - 1;
@@ -1623,7 +1587,8 @@
 		/* (0x15 << 4) | 0x05 is the TAG for FBSourceData */
         	GLINT_WRITE_REG(((count - 1) << 16) | (0x15 << 4) | 
 					0x05, OutputFIFO);
-		MoveDWORDS((CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4),
+		GLINT_MoveDWORDS(
+			(CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4),
 	 		(CARD32*)srcp, count);
 	      }
 	      src += srcwidth;
@@ -1689,13 +1654,15 @@
 	      count = dwords;
 	      address = (y * pScrn->displayWidth) + x;
 	      srcp = (CARD32*)src;
+	      GLINT_WAIT(1);
 	      GLINT_WRITE_REG(address, TextureDownloadOffset);
 	      while(count >= MAX_FIFO_ENTRIES) {
     	    	GLINT_WAIT(MAX_FIFO_ENTRIES);
 		/* (0x11 << 4) | 0x0D is the TAG for TextureData */
         	GLINT_WRITE_REG(((MAX_FIFO_ENTRIES - 2) << 16) | (0x11 << 4) |
 						0x0D, OutputFIFO);
-		MoveDWORDS((CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4),
+		GLINT_MoveDWORDS(
+			(CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4),
 	 		(CARD32*)srcp, MAX_FIFO_ENTRIES - 1);
 		count -= MAX_FIFO_ENTRIES - 1;
 		address += MAX_FIFO_ENTRIES - 1;
@@ -1706,7 +1673,8 @@
 		/* (0x11 << 4) | 0x0D is the TAG for TextureData */
         	GLINT_WRITE_REG(((count - 1) << 16) | (0x11 << 4) | 0x0D,
 					 OutputFIFO);
-		MoveDWORDS((CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4),
+		GLINT_MoveDWORDS(
+			(CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4),
 	 		(CARD32*)srcp, count);
 	      }
 	      src += srcwidth;
@@ -1732,7 +1700,8 @@
 		/* (0x15 << 4) | 0x05 is the TAG for FBSourceData */
         	GLINT_WRITE_REG(((MAX_FIFO_ENTRIES - 2) << 16) | (0x15 << 4) | 
 					0x05, OutputFIFO);
-		MoveDWORDS((CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4),
+		GLINT_MoveDWORDS(
+			(CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4),
 	 		(CARD32*)srcp, MAX_FIFO_ENTRIES - 1);
 		count -= MAX_FIFO_ENTRIES - 1;
 		srcp += MAX_FIFO_ENTRIES - 1;
@@ -1742,7 +1711,8 @@
 		/* (0x15 << 4) | 0x05 is the TAG for FBSourceData */
         	GLINT_WRITE_REG(((count - 1) << 16) | (0x15 << 4) | 
 					0x05, OutputFIFO);
-		MoveDWORDS((CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4),
+		GLINT_MoveDWORDS(
+			(CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4),
 	 		(CARD32*)srcp, count);
 	      }
 	      src += srcwidth;
diff -ur xc.orig/programs/Xserver/hw/xfree86/drivers/glint/pm2ramdac.c xc/programs/Xserver/hw/xfree86/drivers/glint/pm2ramdac.c
--- xc.orig/programs/Xserver/hw/xfree86/drivers/glint/pm2ramdac.c	Sat Jul 17 23:26:57 1999
+++ xc/programs/Xserver/hw/xfree86/drivers/glint/pm2ramdac.c	Sun Mar 18 22:26:08 2001
@@ -104,16 +104,21 @@
     VisualPtr pVisual
 ){
     GLINTPtr pGlint = GLINTPTR(pScrn);
-    int i, index, shift;
+    int i, index, shift = 0, j, repeat = 1;
 
-    shift = (pScrn->depth == 15) ? 3 : 0;
+    if (pScrn->depth == 15) {
+        repeat = 8;
+	shift = 3;
+    }
 
     for(i = 0; i < numColors; i++) {
 	index = indices[i];
-	Permedia2WriteAddress(pScrn, index << shift);
-	Permedia2WriteData(pScrn, colors[index].red);
-	Permedia2WriteData(pScrn, colors[index].green);
-	Permedia2WriteData(pScrn, colors[index].blue);
+	for (j = 0; j < repeat; j++) {
+	    Permedia2WriteAddress(pScrn, (index << shift)+j);
+	    Permedia2WriteData(pScrn, colors[index].red);
+	    Permedia2WriteData(pScrn, colors[index].green);
+	    Permedia2WriteData(pScrn, colors[index].blue);
+	}
 	/* for video i/o */
         GLINT_SLOW_WRITE_REG(index, TexelLUTIndex);
 	GLINT_SLOW_WRITE_REG((colors[index].red & 0xFF) |
@@ -132,14 +137,16 @@
     VisualPtr pVisual
 ){
     GLINTPtr pGlint = GLINTPTR(pScrn);
-    int i, index;
+    int i, index, j;
 
     for(i = 0; i < numColors; i++) {
 	index = indices[i];
-	Permedia2WriteAddress(pScrn, index << 2);
-	Permedia2WriteData(pScrn, colors[index >> 1].red);
-	Permedia2WriteData(pScrn, colors[index].green);
-	Permedia2WriteData(pScrn, colors[index >> 1].blue);
+	for (j = 0; j < 4; j++) {
+	    Permedia2WriteAddress(pScrn, (index << 2)+j);
+	    Permedia2WriteData(pScrn, colors[index >> 1].red);
+	    Permedia2WriteData(pScrn, colors[index].green);
+	    Permedia2WriteData(pScrn, colors[index >> 1].blue);
+	}
         GLINT_SLOW_WRITE_REG(index, TexelLUTIndex);
 	GLINT_SLOW_WRITE_REG((colors[index].red & 0xFF) |
 			     ((colors[index].green & 0xFF) << 8) |
@@ -147,10 +154,12 @@
 			     TexelLUTData);
 
 	if(index <= 31) {
-	    Permedia2WriteAddress(pScrn, index << 3);
-	    Permedia2WriteData(pScrn, colors[index].red);
-	    Permedia2WriteData(pScrn, colors[(index << 1) + 1].green);
-	    Permedia2WriteData(pScrn, colors[index].blue);
+	    for (j = 0; j < 4; j++) {
+	        Permedia2WriteAddress(pScrn, (index << 3)+j);
+		Permedia2WriteData(pScrn, colors[index].red);
+		Permedia2WriteData(pScrn, colors[(index << 1) + 1].green);
+		Permedia2WriteData(pScrn, colors[index].blue);
+	    }
 	}
     }
 }
diff -ur xc.orig/programs/Xserver/hw/xfree86/drivers/glint/pm2v_dac.c xc/programs/Xserver/hw/xfree86/drivers/glint/pm2v_dac.c
--- xc.orig/programs/Xserver/hw/xfree86/drivers/glint/pm2v_dac.c	Sat Mar 17 17:57:15 2001
+++ xc/programs/Xserver/hw/xfree86/drivers/glint/pm2v_dac.c	Sun Mar 18 17:43:30 2001
@@ -406,7 +406,10 @@
    int bg, int fg
 )
 {
-    /* A 2 color cursor uses last 2 indexes into hardware cursor palette */
+    GLINTPtr pGlint = GLINTPTR(pScrn);         
+
+    if (pGlint->Chipset == PCI_VENDOR_3DLABS_CHIP_PERMEDIA3) {
+    /* PM3 uses last 2 indexes into hardware cursor palette fg first...*/ 
     Permedia2vOutIndReg(pScrn, PM2VDACRDCursorPalette+39, 0x00, (fg>>16)&0xff);
     Permedia2vOutIndReg(pScrn, PM2VDACRDCursorPalette+40, 0x00, (fg>>8)&0xff);
     Permedia2vOutIndReg(pScrn, PM2VDACRDCursorPalette+41, 0x00, fg & 0xff);
@@ -414,6 +417,16 @@
     Permedia2vOutIndReg(pScrn, PM2VDACRDCursorPalette+42, 0x00, (bg>>16)&0xff);
     Permedia2vOutIndReg(pScrn, PM2VDACRDCursorPalette+43, 0x00, (bg>>8)&0xff);
     Permedia2vOutIndReg(pScrn, PM2VDACRDCursorPalette+44, 0x00, bg & 0xff);
+    } else {
+    /* PM2v uses first 2 indexes into hardware cursor palette bg first...*/
+    Permedia2vOutIndReg(pScrn, PM2VDACRDCursorPalette+0, 0x00, (bg>>16)&0xff);
+    Permedia2vOutIndReg(pScrn, PM2VDACRDCursorPalette+1, 0x00, (bg>>8)&0xff);
+    Permedia2vOutIndReg(pScrn, PM2VDACRDCursorPalette+2, 0x00, bg & 0xff);
+
+    Permedia2vOutIndReg(pScrn, PM2VDACRDCursorPalette+3, 0x00, (fg>>16)&0xff);
+    Permedia2vOutIndReg(pScrn, PM2VDACRDCursorPalette+4, 0x00, (fg>>8)&0xff);
+    Permedia2vOutIndReg(pScrn, PM2VDACRDCursorPalette+5, 0x00, fg & 0xff);
+    }
 }
 
 static Bool 
diff -ur xc.orig/programs/Xserver/hw/xfree86/drivers/glint/pm2vramdac.c xc/programs/Xserver/hw/xfree86/drivers/glint/pm2vramdac.c
--- xc.orig/programs/Xserver/hw/xfree86/drivers/glint/pm2vramdac.c	Fri Feb 12 17:52:05 1999
+++ xc/programs/Xserver/hw/xfree86/drivers/glint/pm2vramdac.c	Sun Mar 18 16:51:30 2001
@@ -43,8 +43,7 @@
   GLINTPtr pGlint = GLINTPTR(pScrn);
   unsigned char tmp = 0x00;
 
-  GLINT_SLOW_WRITE_REG((reg>>8) & 0xff, PM2VDACIndexRegHigh);
-  GLINT_SLOW_WRITE_REG(reg&0xff, PM2VDACIndexRegLow);
+  GLINT_SET_INDEX(reg);
 
   if (mask != 0x00)
     tmp = GLINT_READ_REG (PM2VDACIndexData) & mask;
@@ -58,8 +57,7 @@
   GLINTPtr pGlint = GLINTPTR(pScrn);
   unsigned char ret;
 
-  GLINT_SLOW_WRITE_REG (reg&0xff, PM2VDACIndexRegLow);
-  GLINT_SLOW_WRITE_REG((reg>>8) & 0xff, PM2VDACIndexRegHigh);
+  GLINT_SET_INDEX(reg);
   ret = GLINT_READ_REG (PM2VDACIndexData);
 
   return (ret);
diff -ur xc.orig/programs/Xserver/hw/xfree86/drivers/glint/pm3_accel.c xc/programs/Xserver/hw/xfree86/drivers/glint/pm3_accel.c
--- xc.orig/programs/Xserver/hw/xfree86/drivers/glint/pm3_accel.c	Wed Nov 29 11:42:17 2000
+++ xc/programs/Xserver/hw/xfree86/drivers/glint/pm3_accel.c	Sun Mar 18 20:15:21 2001
@@ -47,7 +47,6 @@
 #include "xaalocal.h"		/* For replacements */
 
 #define DEBUG 0
-#define USE_DIRECT_FIFO_WRITES 1
 
 #if DEBUG
 # define TRACE_ENTER(str)       ErrorF("pm3_accel: " str " %d\n",pScrn->scrnIndex)
@@ -86,26 +85,35 @@
 				int x_offset, int y_offset, int x, int y, 
 				int w, int h);
 /* Color Expansion Fills */
-static void Permedia3SetupForCPUToScreenColorExpandFill(ScrnInfoPtr pScrn,
-				int fg, int bg, int rop,unsigned int planemask);
-static void Permedia3SubsequentCPUToScreenColorExpandFill(ScrnInfoPtr pScrn, 
-				int x, int y, int w, int h, int skipleft);
+static void Permedia3SetupForScanlineCPUToScreenColorExpandFill(
+				ScrnInfoPtr pScrn,
+				int fg, int bg, int rop, 
+				unsigned int planemask);
+static void Permedia3SubsequentScanlineCPUToScreenColorExpandFill(
+				ScrnInfoPtr pScrn, int x,
+				int y, int w, int h, int skipleft);
+static void Permedia3SubsequentColorExpandScanline(
+				ScrnInfoPtr pScrn,
+				int bufno);
 /* Direct Fifo Bitmap Writes */
 static void Permedia3WriteBitmap(ScrnInfoPtr pScrn, int x, int y, int w, int h, 
 				unsigned char *src, int srcwidth, int skipleft, 
 				int fg, int bg, int rop,unsigned int planemask);
 /* Images Writes */
-static void Permedia3SetupForImageWrite(ScrnInfoPtr pScrn, int rop,
+static void Permedia3SetupForScanlineImageWrite(ScrnInfoPtr pScrn, int rop,
 				unsigned int planemask, int trans_color,
 				int bpp, int depth);
-static void Permedia3SubsequentImageWriteRect(ScrnInfoPtr pScrn, 
+static void Permedia3SubsequentScanlineImageWriteRect(ScrnInfoPtr pScrn, 
 				int x, int y, int w, int h, int skipleft);
+static void Permedia3SubsequentImageWriteScanline(ScrnInfoPtr pScrn, int bufno);
 /* Direct Fifo Pixmap Writes */
 static void Permedia3WritePixmap(ScrnInfoPtr pScrn, int x, int y, int w, int h,
 				unsigned char *src, int srcwidth, int rop,
 				unsigned int planemask, int transparency_color,
 				int bpp, int depth);
 
+#define MAX_FIFO_ENTRIES 120
+
 void
 Permedia3InitializeEngine(ScrnInfoPtr pScrn)
 {
@@ -407,51 +415,52 @@
     infoPtr->SubsequentMono8x8PatternFillRect = 
 	Permedia3SubsequentMono8x8PatternFillRect;
 
-#if USE_DIRECT_FIFO_WRITES
-    /* Direct Fifo Bitmap Writes */
+    /* Bitmap Writes */
     infoPtr->WriteBitmapFlags = 0;
     infoPtr->WriteBitmap = Permedia3WriteBitmap;
-#endif
-
-    /* Color Expand Fills */
-    infoPtr->CPUToScreenColorExpandFillFlags =
-	/*
-	SYNC_AFTER_COLOR_EXPAND |
-	*/
-	LEFT_EDGE_CLIPPING |
-	BIT_ORDER_IN_BYTE_LSBFIRST |
-	CPU_TRANSFER_BASE_FIXED |
-	CPU_TRANSFER_PAD_DWORD;
-    infoPtr->ColorExpandBase = pGlint->IOBase + BitMaskPattern;
-    infoPtr->ColorExpandRange = 4;
-    infoPtr->SetupForCPUToScreenColorExpandFill =
-	    Permedia3SetupForCPUToScreenColorExpandFill;
-    infoPtr->SubsequentCPUToScreenColorExpandFill = 
-	    Permedia3SubsequentCPUToScreenColorExpandFill;
 
-#if USE_DIRECT_FIFO_WRITES
-    /* Direct Fifo Images Writes */
+    /* Pixmap Writes */
     infoPtr->WritePixmapFlags = 0;
     infoPtr->WritePixmap = Permedia3WritePixmap;
-#else
+
+    /* Color Expand Fills */
+    infoPtr->ScanlineCPUToScreenColorExpandFillFlags = 
+						LEFT_EDGE_CLIPPING |
+						LEFT_EDGE_CLIPPING_NEGATIVE_X |
+					       	BIT_ORDER_IN_BYTE_LSBFIRST |
+						CPU_TRANSFER_PAD_DWORD;
+
+    infoPtr->NumScanlineColorExpandBuffers = 1;
+    pGlint->ScratchBuffer                 = xalloc(((pScrn->virtualX+62)/32*4)
+					    + (pScrn->virtualX
+					    * pScrn->bitsPerPixel / 8));
+    infoPtr->ScanlineColorExpandBuffers = 
+					pGlint->XAAScanlineColorExpandBuffers;
+    pGlint->XAAScanlineColorExpandBuffers[0] = 
+					pGlint->IOBase + OutputFIFO + 4;
+
+    infoPtr->SetupForScanlineCPUToScreenColorExpandFill =
+			Permedia3SetupForScanlineCPUToScreenColorExpandFill;
+    infoPtr->SubsequentScanlineCPUToScreenColorExpandFill = 
+			Permedia3SubsequentScanlineCPUToScreenColorExpandFill;
+    infoPtr->SubsequentColorExpandScanline = 
+			Permedia3SubsequentColorExpandScanline;
+    
     /* Images Writes */
-    infoPtr->ImageWriteFlags = 
-	NO_GXCOPY |
-	/*
-	SYNC_AFTER_IMAGE_WRITE |
-	*/
-	LEFT_EDGE_CLIPPING |
-	LEFT_EDGE_CLIPPING_NEGATIVE_X |
-	BIT_ORDER_IN_BYTE_LSBFIRST |
-	CPU_TRANSFER_BASE_FIXED |
-	CPU_TRANSFER_PAD_DWORD;
-    infoPtr->ImageWriteBase = pGlint->IOBase + PM3FBSourceData;
-    infoPtr->ImageWriteRange = 4;
-    infoPtr->SetupForImageWrite =
-	    Permedia3SetupForImageWrite;
-    infoPtr->SubsequentImageWriteRect =
-	    Permedia3SubsequentImageWriteRect;
-#endif
+    infoPtr->ScanlineImageWriteFlags = 	NO_GXCOPY |
+					LEFT_EDGE_CLIPPING |
+					LEFT_EDGE_CLIPPING_NEGATIVE_X |
+					BIT_ORDER_IN_BYTE_LSBFIRST |
+					CPU_TRANSFER_PAD_DWORD;
+    infoPtr->NumScanlineImageWriteBuffers = 1;
+    infoPtr->ScanlineImageWriteBuffers = 
+					pGlint->XAAScanlineColorExpandBuffers;
+    infoPtr->SetupForScanlineImageWrite =
+	    Permedia3SetupForScanlineImageWrite;
+    infoPtr->SubsequentScanlineImageWriteRect =
+	    Permedia3SubsequentScanlineImageWriteRect;
+    infoPtr->SubsequentImageWriteScanline = 
+			Permedia3SubsequentImageWriteScanline;
 
     /* Available Framebuffer Area for XAA. */
     AvailFBArea.x1 = 0;
@@ -461,7 +470,7 @@
 					  pScrn->bitsPerPixel / 8);
     /* Alan does this ???
     AvailFBArea.y2 = ((pGlint->FbMapSize > 16384*1024) ? 16384*1024 :
-	pGlint->FbMapSize)  / (pScrn->displayWidth 
+	pGlint->FbMapSize)  / (pScrn->displayWidth *
 	pScrn->bitsPerPixel / 8);
     */
 
@@ -491,8 +500,12 @@
     CHECKCLIPPING;
 
     while (GLINT_READ_REG(DMACount) != 0);
-    GLINT_WAIT(1);
+
+    GLINT_WAIT(3);
+    GLINT_WRITE_REG(3, BroadcastMask); /* hack! this shouldn't be needed */
+    GLINT_WRITE_REG(0x400, FilterMode);
     GLINT_WRITE_REG(0, GlintSync);
+
     do {
    	while(GLINT_READ_REG(OutFIFOWords) == 0);
     } while (GLINT_READ_REG(OutputFIFO) != PM3SyncTag);
@@ -700,11 +713,15 @@
 }
 
 /* Color Expansion Fills */
-static void Permedia3SetupForCPUToScreenColorExpandFill(ScrnInfoPtr pScrn,
-	int fg, int bg, int rop,unsigned int planemask)
-{
+static void
+Permedia3SetupForScanlineCPUToScreenColorExpandFill(
+	ScrnInfoPtr pScrn,
+	int fg, int bg, 
+	int rop, 
+	unsigned int planemask
+){
     GLINTPtr pGlint = GLINTPTR(pScrn);
-    TRACE_ENTER("Permedia3SetupForCPUToScreenColorExpandFill");
+
     REPLICATE(fg);
     pGlint->PM3_Render2D =
 	PM3Render2D_SpanOperation |
@@ -729,14 +746,23 @@
     GLINT_WRITE_REG(fg, PM3ForegroundColor);
     DO_PLANEMASK(planemask);
     GLINT_WRITE_REG(pGlint->PM3_Config2D, PM3Config2D);
-    TRACE_EXIT("Permedia3SetupForCPUToScreenColorExpandFill");
 }
-static void Permedia3SubsequentCPUToScreenColorExpandFill(ScrnInfoPtr pScrn, 
-	int x, int y, int w, int h, int skipleft)
-{
+
+static void
+Permedia3SubsequentScanlineCPUToScreenColorExpandFill(
+	ScrnInfoPtr pScrn,
+	int x, int y, int w, int h,
+	int skipleft
+){
     GLINTPtr pGlint = GLINTPTR(pScrn);
-    TRACE_ENTER("Permedia3SubsequentCPUToScreenColorExpandFill");
-    GLINT_WAIT(4);
+
+    TRACE_ENTER("Permedia2SubsequentScanlineCPUToScreenColorExpandFill");
+	
+    pGlint->dwords = ((w + 31) >> 5); /* dwords per scanline */
+ 
+    pGlint->cpucount = h;
+
+    GLINT_WAIT(5);
     GLINT_WRITE_REG(((y&0x0fff)<<16)|((x+skipleft)&0x0fff), ScissorMinXY);
     GLINT_WRITE_REG((((y+h)&0x0fff)<<16)|((x+w)&0x0fff), ScissorMaxXY);
     GLINT_WRITE_REG(
@@ -746,16 +772,60 @@
     GLINT_WRITE_REG(pGlint->PM3_Render2D |
 	PM3Render2D_Width(w) | PM3Render2D_Height(h),
 	PM3Render2D);
-    TRACE_EXIT("Permedia3SubsequentCPUToScreenColorExpandFill");
+
+#ifdef __alpha__
+    if (0) /* force ALPHA to use indirect always */
+#else
+    if ((pGlint->dwords*h) < MAX_FIFO_ENTRIES)
+#endif
+    {
+	/* Turn on direct for less than 120 dword colour expansion */
+    	pGlint->XAAScanlineColorExpandBuffers[0] = pGlint->IOBase+OutputFIFO+4;
+	pGlint->ScanlineDirect = 1;
+    	GLINT_WRITE_REG(((pGlint->dwords*h)-1)<<16 | 0x0D, OutputFIFO);
+    	GLINT_WAIT(pGlint->dwords*h);
+    } else {
+	/* Use indirect for anything else */
+    	pGlint->XAAScanlineColorExpandBuffers[0] = pGlint->ScratchBuffer;
+	pGlint->ScanlineDirect   = 0;
+    }
+
+    pGlint->cpucount--;
 }
 
+static void
+Permedia3SubsequentColorExpandScanline(ScrnInfoPtr pScrn, int bufno)
+{
+    GLINTPtr pGlint = GLINTPTR(pScrn);
+    CARD32 *srcp = (CARD32*)pGlint->XAAScanlineColorExpandBuffers[bufno];
+    int dwords = pGlint->dwords;
+
+    if (!pGlint->ScanlineDirect) {
+	while(dwords >= MAX_FIFO_ENTRIES) {
+	    GLINT_WAIT(MAX_FIFO_ENTRIES);
+            GLINT_WRITE_REG(((MAX_FIFO_ENTRIES - 2) << 16) | 0x0D, OutputFIFO);
+	    GLINT_MoveDWORDS(
+			(CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4),
+	 		(CARD32*)srcp, MAX_FIFO_ENTRIES - 1);
+	    dwords -= MAX_FIFO_ENTRIES - 1;
+	    srcp += MAX_FIFO_ENTRIES - 1;
+	}
+	if(dwords) {
+	    GLINT_WAIT(dwords + 1);
+            GLINT_WRITE_REG(((dwords - 1) << 16) | 0x0D, OutputFIFO);
+	    GLINT_MoveDWORDS(
+			(CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4),
+	 		(CARD32*)srcp, dwords);
+	}
+    }
+}
 
 /* Images Writes */
-static void Permedia3SetupForImageWrite(ScrnInfoPtr pScrn, int rop,
+static void Permedia3SetupForScanlineImageWrite(ScrnInfoPtr pScrn, int rop,
 	unsigned int planemask, int trans_color, int bpp, int depth)
 {
     GLINTPtr pGlint = GLINTPTR(pScrn);
-    TRACE_ENTER("Permedia3SetupForImageWrite");
+    TRACE_ENTER("Permedia3SetupForScanlineImageWrite");
     pGlint->PM3_Render2D =
 	PM3Render2D_SpanOperation |
 	PM3Render2D_XPositive |
@@ -771,14 +841,18 @@
     GLINT_WAIT(2);
     DO_PLANEMASK(planemask);
     GLINT_WRITE_REG(pGlint->PM3_Config2D, PM3Config2D);
-    TRACE_EXIT("Permedia3SetupForImageWrite");
+    TRACE_EXIT("Permedia3SetupForScanlineImageWrite");
 }
-static void Permedia3SubsequentImageWriteRect(ScrnInfoPtr pScrn, 
+
+static void Permedia3SubsequentScanlineImageWriteRect(ScrnInfoPtr pScrn, 
 	int x, int y, int w, int h, int skipleft)
 {
     GLINTPtr pGlint = GLINTPTR(pScrn);
-    TRACE_ENTER("Permedia3SubsequentImageWrite");
-    GLINT_WAIT(4);
+    TRACE_ENTER("Permedia3SubsequentScanlineImageWrite");
+    pGlint->dwords = (((w * pScrn->bitsPerPixel) + 3) >> 2); /* per scanline */
+
+    pGlint->cpucount = h;
+    GLINT_WAIT(5);
     GLINT_WRITE_REG(((y&0x0fff)<<16)|((x+skipleft)&0x0fff), ScissorMinXY);
     GLINT_WRITE_REG((((y+h)&0x0fff)<<16)|((x+w)&0x0fff), ScissorMaxXY);
     GLINT_WRITE_REG(
@@ -788,18 +862,63 @@
     GLINT_WRITE_REG(pGlint->PM3_Render2D |
 	PM3Render2D_Width(w) | PM3Render2D_Height(h),
 	PM3Render2D);
-    TRACE_EXIT("Permedia3SubsequentImageWrite");
-}
 
+#ifdef __alpha__
+    if (0) /* force ALPHA to use indirect always */
+#else
+    if (pGlint->dwords < MAX_FIFO_ENTRIES)
+#endif
+    {
+	/* Turn on direct for less than 120 dword colour expansion */
+    	pGlint->XAAScanlineColorExpandBuffers[0] = pGlint->IOBase+OutputFIFO+4;
+	pGlint->ScanlineDirect = 1;
+    	GLINT_WRITE_REG(((pGlint->dwords*h)-1)<<16 | (0x15<<4) | 0x05, 
+								OutputFIFO);
+    	GLINT_WAIT(pGlint->dwords);
+    } else {
+	/* Use indirect for anything else */
+    	pGlint->XAAScanlineColorExpandBuffers[0] = pGlint->ScratchBuffer;
+	pGlint->ScanlineDirect   = 0;
+    }
 
-/* Defines for Direct Fifo access */
+    pGlint->cpucount--;
+    TRACE_EXIT("Permedia3SubsequentScanlineImageWrite");
+}
 
-#define WriteRange 120
-#define PciRetryWriteRange 1023
-#define WriteBase_Fixed ((CARD32 *)(pGlint->IOBase + PM3FBSourceData))
-#define WriteBase ((CARD32 *)(pGlint->IOBase + OutputFIFO + 4))
+static void
+Permedia3SubsequentImageWriteScanline(ScrnInfoPtr pScrn, int bufno)
+{
+    GLINTPtr pGlint = GLINTPTR(pScrn);
+    int dwords = pGlint->dwords;
 
-/* Direct Fifo Bitmap Writes */
+    if (pGlint->ScanlineDirect) {
+    	if (pGlint->cpucount--)
+    	    GLINT_WAIT(dwords);
+	return;
+    } else {
+	while(dwords >= MAX_FIFO_ENTRIES) {
+	    GLINT_WAIT(MAX_FIFO_ENTRIES);
+            GLINT_WRITE_REG(((MAX_FIFO_ENTRIES - 2) << 16) | (0x15 << 4) |
+							0x05, OutputFIFO);
+	    GLINT_MoveDWORDS(
+			(CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4),
+	 		(CARD32*)pGlint->XAAScanlineColorExpandBuffers[bufno],
+			MAX_FIFO_ENTRIES - 1);
+	    dwords -= MAX_FIFO_ENTRIES - 1;
+	}
+	if(dwords) {
+	    GLINT_WAIT(dwords + 1);
+            GLINT_WRITE_REG(((dwords - 1) << 16) | (0x15 << 4) | 
+							0x05, OutputFIFO);
+	    GLINT_MoveDWORDS(
+			(CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4),
+	 		(CARD32*)pGlint->XAAScanlineColorExpandBuffers[bufno],
+			dwords);
+	}
+    }
+}
+
+/* Bitmap Writes */
 
 static void
 Permedia3WriteBitmap(ScrnInfoPtr pScrn,
@@ -810,59 +929,85 @@
     unsigned int planemask
 )
 {
-    int dwords;
-    int ApertureRange;
+    int dwords, count;
+    CARD32 *srcp;
     GLINTPtr pGlint = GLINTPTR(pScrn);
     TRACE_ENTER("Permedia3WriteBitmap");
 
     w += skipleft;
     x -= skipleft;
-    dwords = (w + 31) >>5;
-    if (pGlint->UsePCIRetry) ApertureRange = PciRetryWriteRange;
-    else ApertureRange = WriteRange;
 
     /* width of the stuff to copy in 32 bit words */
-    Permedia3SetupForCPUToScreenColorExpandFill(pScrn, fg, bg, rop, planemask);
-    Permedia3SubsequentCPUToScreenColorExpandFill(pScrn, x, y, w, h, skipleft);
+    dwords = (w + 31) >>5;
 
-    if (dwords > ApertureRange) {
-	while(h--) {
-	    XAAMoveDWORDS_FixedBase(WriteBase_Fixed, (CARD32*)src, dwords);
-	    src += srcwidth;
-	}
-    } else {
-	/* the src is exatcly as wide as the target rectangle. We copy all
-	 * of it, so no need to separate stuff by scanline */
-	if(srcwidth == (dwords << 5)) {
-	    /* decrement contains the number of lines that can be
-	     * put in the fifo */
- 	    int decrement = ApertureRange/dwords;
-
-	    while(h > decrement) {
-		GLINT_WAIT(dwords * decrement);
-       		GLINT_WRITE_REG((((dwords * decrement)-1) << 16) | 0xd,
-		    OutputFIFO);
-		XAAMoveDWORDS(WriteBase, (CARD32*)src, dwords * decrement);
-		src += (srcwidth * decrement);
-		h -= decrement;
-	    }
-	    if(h) {
-		GLINT_WAIT(dwords * h);
-       		GLINT_WRITE_REG((((dwords * h)-1) << 16) | 0xd, OutputFIFO);
-		XAAMoveDWORDS(WriteBase, (CARD32*)src, dwords * h);
-	    }
-	} else {
-	    while(h--) {
-		GLINT_WAIT(dwords);
-       		GLINT_WRITE_REG(((dwords-1) << 16) | 0xd, OutputFIFO);
-		XAAMoveDWORDS(WriteBase, (CARD32*)src, dwords);
-		src += srcwidth;
-	    }
-	}
+    REPLICATE(fg);
+    pGlint->PM3_Render2D =
+        PM3Render2D_SpanOperation |
+        PM3Render2D_XPositive |
+        PM3Render2D_YPositive |
+        PM3Render2D_Operation_SyncOnBitMask;
+    pGlint->PM3_Config2D =
+        PM3Config2D_UserScissorEnable |
+        PM3Config2D_UseConstantSource |
+        PM3Config2D_ForegroundROPEnable |
+        PM3Config2D_ForegroundROP(rop) |
+        PM3Config2D_FBWriteEnable;
+    if ((rop!=GXclear)&&(rop!=GXset)&&(rop!=GXcopy)&&(rop!=GXcopyInverted))
+        pGlint->PM3_Config2D |= PM3Config2D_FBDestReadEnable;
+    if (bg != -1) {
+        REPLICATE(bg);
+        pGlint->PM3_Config2D |= PM3Config2D_OpaqueSpan;
+        GLINT_WAIT(8);
+        GLINT_WRITE_REG(bg, BackgroundColor);
+    }
+    else GLINT_WAIT(7);
+    GLINT_WRITE_REG(fg, PM3ForegroundColor);
+    DO_PLANEMASK(planemask);
+    GLINT_WRITE_REG(pGlint->PM3_Config2D, PM3Config2D);
+    GLINT_WRITE_REG(((y&0x0fff)<<16)|((x+skipleft)&0x0fff), ScissorMinXY);
+    GLINT_WRITE_REG((((y+h)&0x0fff)<<16)|((x+w)&0x0fff), ScissorMaxXY);
+    GLINT_WRITE_REG(
+        PM3RectanglePosition_XOffset(x) |
+        PM3RectanglePosition_YOffset(y),
+        PM3RectanglePosition);
+    GLINT_WRITE_REG(pGlint->PM3_Render2D |
+        PM3Render2D_Width(w) | PM3Render2D_Height(h),
+        PM3Render2D);
+
+#ifdef __alpha__
+    mem_barrier(); /* dunno why, but this helps on older Alpha CPUs */
+#endif
+
+    while(h--) {
+        count = dwords;
+        srcp = (CARD32*)src;
+        while(count >= MAX_FIFO_ENTRIES) {
+            GLINT_WAIT(MAX_FIFO_ENTRIES);
+            GLINT_WRITE_REG(((MAX_FIFO_ENTRIES - 2) << 16) |
+                                        0x0D, OutputFIFO);
+            GLINT_MoveDWORDS(
+                        (CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4),
+                        (CARD32*)srcp, MAX_FIFO_ENTRIES - 1);
+            count -= MAX_FIFO_ENTRIES - 1;
+            srcp += MAX_FIFO_ENTRIES - 1;
+        }
+        if(count) {
+            GLINT_WAIT(count + 1);
+            GLINT_WRITE_REG(((count - 1) << 16) | 0x0D, OutputFIFO);
+            GLINT_MoveDWORDS(
+                        (CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4),
+                        (CARD32*)srcp, count);
+        }
+        src += srcwidth;
     }
+ 
+    Permedia3DisableClipping(pScrn);
+    Permedia3Sync(pScrn);
+
     TRACE_EXIT("Permedia3WriteBitmap");
 }
-/* Direct Fifo Images Writes */
+
+/* Pixmap Writes */
 
 static void
 Permedia3WritePixmap(
@@ -876,10 +1021,10 @@
     int bpp, int depth
 )
 {
-    int dwords;
+    int dwords, count;
     int skipleft = (long)src & 0x03L;
     int Bpp = bpp >> 3;
-    int ApertureRange;
+    CARD32 *srcp;
     GLINTPtr pGlint = GLINTPTR(pScrn);
     TRACE_ENTER("Permedia3WritePixmap");
 
@@ -896,48 +1041,67 @@
 	
 	src = (unsigned char*)((long)src & ~0x03L);     
     }
-    Permedia3SetupForImageWrite(pScrn, rop, planemask, trans, bpp, depth);
-    Permedia3SubsequentImageWriteRect(pScrn, x, y, w, h, skipleft);
+
+    pGlint->PM3_Render2D =
+        PM3Render2D_SpanOperation |
+        PM3Render2D_XPositive |
+        PM3Render2D_YPositive |
+        PM3Render2D_Operation_SyncOnHostData;
+    pGlint->PM3_Config2D =
+        PM3Config2D_UserScissorEnable |
+        PM3Config2D_ForegroundROPEnable |
+        PM3Config2D_ForegroundROP(rop) |
+        PM3Config2D_FBWriteEnable;
+    if ((rop!=GXclear)&&(rop!=GXset)&&(rop!=GXcopy)&&(rop!=GXcopyInverted))
+        pGlint->PM3_Config2D |= PM3Config2D_FBDestReadEnable;
+    GLINT_WAIT(6);
+    DO_PLANEMASK(planemask);
+    GLINT_WRITE_REG(pGlint->PM3_Config2D, PM3Config2D);
+    GLINT_WRITE_REG(((y&0x0fff)<<16)|((x+skipleft)&0x0fff), ScissorMinXY);
+    GLINT_WRITE_REG((((y+h)&0x0fff)<<16)|((x+w)&0x0fff), ScissorMaxXY);
+    GLINT_WRITE_REG(
+        PM3RectanglePosition_XOffset(x) |
+        PM3RectanglePosition_YOffset(y),
+        PM3RectanglePosition);
+    GLINT_WRITE_REG(pGlint->PM3_Render2D |
+        PM3Render2D_Width(w) | PM3Render2D_Height(h),
+        PM3Render2D);
+
+#ifdef __alpha__
+    mem_barrier(); /* dunno why, but this helps on older Alpha CPUs */
+#endif
 
     /* width of the stuff to copy in 32 bit words */
     dwords = ((w * Bpp) + 3) >> 2;
-    if (pGlint->UsePCIRetry) ApertureRange = PciRetryWriteRange;
-    else ApertureRange = WriteRange;
 
-    if (dwords > ApertureRange) {
-	while(h--) {
-	    XAAMoveDWORDS_FixedBase(WriteBase_Fixed, (CARD32*)src, dwords);
-	    src += srcwidth;
-	}
-    } else {
-	/* the src is exatcly as wide as the target rectangle. We copy all
-	 * of it, so no need to separate stuff by scanline */
-	if(srcwidth == (dwords << 2)) {
-	    /* decrement contains the number of lines that can be
-	     * put in the fifo */
- 	    int decrement = ApertureRange/dwords;
-
-	    while(h > decrement) {
-		GLINT_WAIT(dwords * decrement);
-       		GLINT_WRITE_REG((((dwords * decrement)-1) << 16) | 0x155,
-		    OutputFIFO);
-		XAAMoveDWORDS(WriteBase, (CARD32*)src, dwords * decrement);
-		src += (srcwidth * decrement);
-		h -= decrement;
-	    }
-	    if(h) {
-		GLINT_WAIT(dwords * h);
-       		GLINT_WRITE_REG((((dwords * h)-1) << 16) | 0x155, OutputFIFO);
-		XAAMoveDWORDS(WriteBase, (CARD32*)src, dwords * h);
-	    }
-	} else {
-	    while(h--) {
-		GLINT_WAIT(dwords);
-       		GLINT_WRITE_REG(((dwords-1) << 16) | 0x155, OutputFIFO);
-		XAAMoveDWORDS(WriteBase, (CARD32*)src, dwords);
-		src += srcwidth;
-	    }
-	}
+    while(h--) {
+        count = dwords;
+        srcp = (CARD32*)src;
+        while(count >= MAX_FIFO_ENTRIES) {
+            GLINT_WAIT(MAX_FIFO_ENTRIES);
+            /* (0x15 << 4) | 0x05 is the TAG for FBSourceData */
+            GLINT_WRITE_REG(((MAX_FIFO_ENTRIES - 2) << 16) | (0x15 << 4) |
+                                        0x05, OutputFIFO);
+            GLINT_MoveDWORDS(
+                        (CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4),
+                        (CARD32*)srcp, MAX_FIFO_ENTRIES - 1);
+            count -= MAX_FIFO_ENTRIES - 1;
+            srcp += MAX_FIFO_ENTRIES - 1;
+        }
+        if(count) {
+            GLINT_WAIT(count + 1);
+            /* (0x15 << 4) | 0x05 is the TAG for FBSourceData */
+            GLINT_WRITE_REG(((count - 1) << 16) | (0x15 << 4) |
+                                        0x05, OutputFIFO);
+            GLINT_MoveDWORDS(
+                        (CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4),
+                        (CARD32*)srcp, count);
+        }
+        src += srcwidth;
     }
+
+    Permedia3DisableClipping(pScrn);
+    Permedia3Sync(pScrn); 
+
     TRACE_EXIT("Permedia3WritePixmap");
 }
diff -ur xc.orig/programs/Xserver/hw/xfree86/drivers/glint/pm3_dac.c xc/programs/Xserver/hw/xfree86/drivers/glint/pm3_dac.c
--- xc.orig/programs/Xserver/hw/xfree86/drivers/glint/pm3_dac.c	Sat Mar 17 17:57:15 2001
+++ xc/programs/Xserver/hw/xfree86/drivers/glint/pm3_dac.c	Sun Mar 18 21:35:54 2001
@@ -320,7 +320,7 @@
     pReg->glintRegs[VClkCtl >> 3] = (GLINT_READ_REG(VClkCtl) & 0xFFFFFFFC);
     pReg->glintRegs[PMScreenBase >> 3] = 0; 
 
-    pReg->glintRegs[ChipConfig >> 3] = GLINT_READ_REG(ChipConfig) & 0xFFFFFFDD;
+    pReg->glintRegs[ChipConfig >> 3] = GLINT_READ_REG(ChipConfig) & 0xFFFFFFFD;
     pReg->DacRegs[PM2VDACRDDACControl] = 0x00;
   
     {
@@ -524,4 +524,80 @@
     Permedia2vOutIndReg(pScrn, PM2VDACRDDClk0PostScale, 0x00, 
 	glintReg->DacRegs[PM2VDACRDDClk0PostScale]);
     Permedia2vOutIndReg(pScrn, PM2VDACIndexClockControl, 0x00, temp|0x03);
+}
+
+void Permedia3LoadPalette(
+    ScrnInfoPtr pScrn, 
+    int numColors, 
+    int *indices,
+    LOCO *colors,
+    VisualPtr pVisual
+){
+#if 0 /* NOT YET */
+    GLINTPtr pGlint = GLINTPTR(pScrn);
+#endif
+    int i, index, shift = 0, j, repeat = 1;
+
+    if (pScrn->depth == 15) {
+	repeat = 8;
+	shift = 3;
+    }
+
+    for(i = 0; i < numColors; i++) {
+	index = indices[i];
+	for (j = 0; j < repeat; j++) {
+	    Permedia2WriteAddress(pScrn, (index << shift)+j);
+	    Permedia2WriteData(pScrn, colors[index].red);
+	    Permedia2WriteData(pScrn, colors[index].green);
+	    Permedia2WriteData(pScrn, colors[index].blue);
+	}
+	/* for video i/o */
+#if 0 /* NOT YET */
+        GLINT_SLOW_WRITE_REG(index, PM3LUTIndex);
+	GLINT_SLOW_WRITE_REG((colors[index].red & 0xFF) |
+			     ((colors[index].green & 0xFF) << 8) |
+			     ((colors[index].blue & 0xFF) << 16),
+			     PM3LUTData);
+#endif
+    }
+}
+
+/* special one for 565 mode */
+void Permedia3LoadPalette16(
+    ScrnInfoPtr pScrn, 
+    int numColors, 
+    int *indices,
+    LOCO *colors,
+    VisualPtr pVisual
+){
+#if 0 /* NOT YET */
+    GLINTPtr pGlint = GLINTPTR(pScrn);
+#endif
+    int i, index, j;
+
+    for(i = 0; i < numColors; i++) {
+	index = indices[i];
+	for (j = 0; j < 4; j++) {
+	    Permedia2WriteAddress(pScrn, (index << 2)+j);
+	    Permedia2WriteData(pScrn, colors[index >> 1].red);
+	    Permedia2WriteData(pScrn, colors[index].green);
+	    Permedia2WriteData(pScrn, colors[index >> 1].blue);
+	}
+#if 0 /* NOT YET */
+        GLINT_SLOW_WRITE_REG(index, PM3LUTIndex);
+	GLINT_SLOW_WRITE_REG((colors[index].red & 0xFF) |
+			     ((colors[index].green & 0xFF) << 8) |
+			     ((colors[index].blue & 0xFF) << 16),
+			     PM3LUTData);
+#endif
+
+	if(index <= 31) {
+	    for (j = 0; j < 4; j++) {
+	    	Permedia2WriteAddress(pScrn, (index << 3)+j);
+	    	Permedia2WriteData(pScrn, colors[index].red);
+	    	Permedia2WriteData(pScrn, colors[(index << 1) + 1].green);
+	    	Permedia2WriteData(pScrn, colors[index].blue);
+	    }
+	}
+    }
 }
diff -ur xc.orig/programs/Xserver/hw/xfree86/drivers/glint/pm_accel.c xc/programs/Xserver/hw/xfree86/drivers/glint/pm_accel.c
--- xc.orig/programs/Xserver/hw/xfree86/drivers/glint/pm_accel.c	Sat Jun 24 14:19:55 2000
+++ xc/programs/Xserver/hw/xfree86/drivers/glint/pm_accel.c	Sun Mar 18 16:57:17 2001
@@ -301,62 +301,6 @@
     return (XAAInit(pScreen, infoPtr));
 }
 
-static void MoveBYTE(
-   register CARD32* dest,
-   register unsigned char* src,
-   register int dwords
-)
-{
-     while(dwords) {
-	*dest = *src;
-	src += 1;
-	dest += 1;
-	dwords -= 1;
-     }	
-}
-
-static void MoveWORDS(
-   register CARD32* dest,
-   register unsigned short* src,
-   register int dwords
-)
-{
-     while(dwords & ~0x01) {
-	*dest = *src;
-	*(dest + 1) = *(src + 1);
-	src += 2;
-	dest += 2;
-	dwords -= 2;
-     }	
-     switch(dwords) {
-	case 0:	return;
-	case 1: *dest = *src;
-		return;
-    }
-}
-
-static void MoveDWORDS(
-   register CARD32* dest,
-   register CARD32* src,
-   register int dwords )
-{
-     while(dwords & ~0x03) {
-	*dest = *src;
-	*(dest + 1) = *(src + 1);
-	*(dest + 2) = *(src + 2);
-	*(dest + 3) = *(src + 3);
-	src += 4;
-	dest += 4;
-	dwords -= 4;
-     }	
-     if (!dwords) return;
-     *dest = *src;
-     if (dwords == 1) return;
-     *(dest + 1) = *(src + 1);
-     if (dwords == 2) return;
-     *(dest + 2) = *(src + 2);
-}
-
 static void PermediaLoadCoord(
 	ScrnInfoPtr pScrn,
 	int x, int y,
@@ -779,15 +723,16 @@
     while (dwords >= infoRec->ColorExpandRange) {
     	GLINT_WAIT(infoRec->ColorExpandRange);
     	GLINT_WRITE_REG((infoRec->ColorExpandRange - 2)<<16 | 0x0D, OutputFIFO);
-    	MoveDWORDS((CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4), src,
-		infoRec->ColorExpandRange - 1);
+    	GLINT_MoveDWORDS((CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4),
+		src, infoRec->ColorExpandRange - 1);
     	dwords -= (infoRec->ColorExpandRange - 1);
 	src += (infoRec->ColorExpandRange - 1);
     }
     if (dwords) {
     	GLINT_WAIT(dwords);
     	GLINT_WRITE_REG((dwords - 1)<<16 | 0x0D, OutputFIFO);
-    	MoveDWORDS((CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4), src,dwords);
+    	GLINT_MoveDWORDS((CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4),
+		src,dwords);
     }
     pGlint->cpucount += 1;
 #if 0
@@ -915,7 +860,8 @@
 		/* (0x11 << 4) | 0x0D is the TAG for TextureData */
         	GLINT_WRITE_REG(((infoRec->ColorExpandRange - 2) << 16)
 					| (0x11 << 4) |	0x0D, OutputFIFO);
-		MoveDWORDS((CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4),
+		GLINT_MoveDWORDS(
+			(CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4),
 	 		(CARD32*)srcp, infoRec->ColorExpandRange - 1);
 		count -= infoRec->ColorExpandRange - 1;
 		address += infoRec->ColorExpandRange - 1;
@@ -926,7 +872,8 @@
 		/* (0x11 << 4) | 0x0D is the TAG for TextureData */
         	GLINT_WRITE_REG(((count - 1) << 16) | (0x11 << 4) | 0x0D,
 					 OutputFIFO);
-		MoveDWORDS((CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4),
+		GLINT_MoveDWORDS(
+			(CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4),
 	 		(CARD32*)srcp, count);
 	      }
 	      src += srcwidth;
@@ -955,7 +902,8 @@
 		/* (0x15 << 4) | 0x05 is the TAG for FBSourceData */
         	GLINT_WRITE_REG(((infoRec->ColorExpandRange - 2) << 16) | 
 				(0x15 << 4) | 0x05, OutputFIFO);
-		MoveBYTE((CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4),
+		GLINT_MoveBYTES(
+			(CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4),
 	 		(unsigned char *)srcpbyte, infoRec->ColorExpandRange-1);
 		count -= infoRec->ColorExpandRange - 1;
 		srcpbyte += infoRec->ColorExpandRange - 1;
@@ -965,7 +913,8 @@
 		/* (0x15 << 4) | 0x05 is the TAG for FBSourceData */
         	GLINT_WRITE_REG(((count - 1) << 16) | (0x15 << 4) | 
 					0x05, OutputFIFO);
-		MoveBYTE((CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4),
+		GLINT_MoveBYTES(
+			(CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4),
 	 		(unsigned char *)srcpbyte, count);
 	      }
 	      src += srcwidth;
@@ -1038,7 +987,8 @@
 		/* (0x11 << 4) | 0x0D is the TAG for TextureData */
         	GLINT_WRITE_REG(((infoRec->ColorExpandRange - 2) << 16) |
 					(0x11 << 4) | 0x0D, OutputFIFO);
-		MoveDWORDS((CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4),
+		GLINT_MoveDWORDS(
+			(CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4),
 	 		(CARD32*)srcp, infoRec->ColorExpandRange - 1);
 		count -= infoRec->ColorExpandRange - 1;
 		address += infoRec->ColorExpandRange - 1;
@@ -1049,7 +999,8 @@
 		/* (0x11 << 4) | 0x0D is the TAG for TextureData */
         	GLINT_WRITE_REG(((count - 1) << 16) | (0x11 << 4) | 0x0D,
 					 OutputFIFO);
-		MoveDWORDS((CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4),
+		GLINT_MoveDWORDS(
+			(CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4),
 	 		(CARD32*)srcp, count);
 	      }
 	      src += srcwidth;
@@ -1078,7 +1029,8 @@
 		/* (0x15 << 4) | 0x05 is the TAG for FBSourceData */
         	GLINT_WRITE_REG(((infoRec->ColorExpandRange - 2) << 16) | 
 				(0x15 << 4) | 0x05, OutputFIFO);
-		MoveWORDS((CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4),
+		GLINT_MoveWORDS(
+			(CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4),
 	 		(unsigned short *)srcpword,infoRec->ColorExpandRange-1);
 		count -= infoRec->ColorExpandRange - 1;
 		srcpword += infoRec->ColorExpandRange - 1;
@@ -1088,7 +1040,8 @@
 		/* (0x15 << 4) | 0x05 is the TAG for FBSourceData */
         	GLINT_WRITE_REG(((count - 1) << 16) | (0x15 << 4) | 
 					0x05, OutputFIFO);
-		MoveWORDS((CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4),
+		GLINT_MoveWORDS(
+			(CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4),
 	 		(unsigned short *)srcpword, count);
 	      }
 	      src += srcwidth;
@@ -1162,7 +1115,8 @@
 		/* (0x11 << 4) | 0x0D is the TAG for TextureData */
         	GLINT_WRITE_REG(((infoRec->ColorExpandRange - 2) << 16) |
 					(0x11 << 4) | 0x0D, OutputFIFO);
-		MoveDWORDS((CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4),
+		GLINT_MoveDWORDS(
+			(CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4),
 	 		(CARD32*)srcp, infoRec->ColorExpandRange - 1);
 		count -= infoRec->ColorExpandRange - 1;
 		address += infoRec->ColorExpandRange - 1;
@@ -1173,7 +1127,8 @@
 		/* (0x11 << 4) | 0x0D is the TAG for TextureData */
         	GLINT_WRITE_REG(((count - 1) << 16) | (0x11 << 4) | 0x0D,
 					 OutputFIFO);
-		MoveDWORDS((CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4),
+		GLINT_MoveDWORDS(
+			(CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4),
 	 		(CARD32*)srcp, count);
 	      }
 	      src += srcwidth;
@@ -1196,7 +1151,8 @@
 		/* (0x15 << 4) | 0x05 is the TAG for FBSourceData */
         	GLINT_WRITE_REG(((infoRec->ColorExpandRange - 2) << 16) |
 				(0x15 << 4) | 0x05, OutputFIFO);
-		MoveDWORDS((CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4),
+		GLINT_MoveDWORDS(
+			(CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4),
 	 		(CARD32*)srcp, infoRec->ColorExpandRange - 1);
 		count -= infoRec->ColorExpandRange - 1;
 		srcp += infoRec->ColorExpandRange - 1;
@@ -1206,7 +1162,8 @@
 		/* (0x15 << 4) | 0x05 is the TAG for FBSourceData */
         	GLINT_WRITE_REG(((count - 1) << 16) | (0x15 << 4) | 
 					0x05, OutputFIFO);
-		MoveDWORDS((CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4),
+		GLINT_MoveDWORDS(
+			(CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4),
 	 		(CARD32*)srcp, count);
 	      }
 	      src += srcwidth;
diff -ur xc.orig/programs/Xserver/hw/xfree86/drivers/glint/sx_accel.c xc/programs/Xserver/hw/xfree86/drivers/glint/sx_accel.c
--- xc.orig/programs/Xserver/hw/xfree86/drivers/glint/sx_accel.c	Wed Apr 12 10:44:41 2000
+++ xc/programs/Xserver/hw/xfree86/drivers/glint/sx_accel.c	Sun Mar 18 16:57:36 2001
@@ -298,28 +298,6 @@
     }
 }
 
-static void MoveDWORDS(
-   register CARD32* dest,
-   register CARD32* src,
-   register int dwords )
-{
-     while(dwords & ~0x03) {
-	*dest = *src;
-	*(dest + 1) = *(src + 1);
-	*(dest + 2) = *(src + 2);
-	*(dest + 3) = *(src + 3);
-	src += 4;
-	dest += 4;
-	dwords -= 4;
-     }	
-     if (!dwords) return;
-     *dest = *src;
-     if (dwords == 1) return;
-     *(dest + 1) = *(src + 1);
-     if (dwords == 2) return;
-     *(dest + 2) = *(src + 2);
-}
-
 static void
 SXSync(
 	ScrnInfoPtr pScrn
@@ -519,7 +497,8 @@
     while (dwords >= infoRec->ColorExpandRange) {
     	GLINT_WAIT(infoRec->ColorExpandRange);
     	GLINT_WRITE_REG((infoRec->ColorExpandRange - 2)<<16 | 0x0D, OutputFIFO);
-    	MoveDWORDS((CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4), src,
+    	GLINT_MoveDWORDS(
+		(CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4), src,
 		infoRec->ColorExpandRange - 1);
     	dwords -= (infoRec->ColorExpandRange - 1);
 	src += (infoRec->ColorExpandRange - 1);
@@ -527,7 +506,8 @@
     if (dwords) {
     	GLINT_WAIT(dwords);
     	GLINT_WRITE_REG((dwords - 1)<<16 | 0x0D, OutputFIFO);
-    	MoveDWORDS((CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4), src,dwords);
+    	GLINT_MoveDWORDS(
+		(CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4), src,dwords);
     }
     pGlint->cpucount += 1;
 }
@@ -809,7 +789,8 @@
 	/* (0x0f << 4) | 0x0e is the TAG for GLINTColor */
        	GLINT_WRITE_REG(((infoRec->ColorExpandRange - 2) << 16) | (0x0F << 4) | 
 				0x0E, OutputFIFO);
-	MoveDWORDS((CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4),
+	GLINT_MoveDWORDS(
+		(CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4),
  		(CARD32*)srcp, infoRec->ColorExpandRange - 1);
 	count -= infoRec->ColorExpandRange - 1;
 	srcp += infoRec->ColorExpandRange - 1;
@@ -819,7 +800,8 @@
 	/* (0x0F << 4) | 0x0E is the TAG for GLINTColor */
        	GLINT_WRITE_REG(((count - 1) << 16) | (0x0f << 4) | 
 				0x0e, OutputFIFO);
-	MoveDWORDS((CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4),
+	GLINT_MoveDWORDS(
+		(CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4),
  		(CARD32*)srcp, count);
       }
       src += srcwidth;
diff -ur xc.orig/programs/Xserver/hw/xfree86/drivers/glint/tx_accel.c xc/programs/Xserver/hw/xfree86/drivers/glint/tx_accel.c
--- xc.orig/programs/Xserver/hw/xfree86/drivers/glint/tx_accel.c	Wed May 10 16:01:32 2000
+++ xc/programs/Xserver/hw/xfree86/drivers/glint/tx_accel.c	Sun Mar 18 16:57:58 2001
@@ -326,28 +326,6 @@
 #endif
 }
 
-static void MoveDWORDS(
-   register CARD32* dest,
-   register CARD32* src,
-   register int dwords )
-{
-     while(dwords & ~0x03) {
-	*dest = *src;
-	*(dest + 1) = *(src + 1);
-	*(dest + 2) = *(src + 2);
-	*(dest + 3) = *(src + 3);
-	src += 4;
-	dest += 4;
-	dwords -= 4;
-     }	
-     if (!dwords) return;
-     *dest = *src;
-     if (dwords == 1) return;
-     *(dest + 1) = *(src + 1);
-     if (dwords == 2) return;
-     *(dest + 2) = *(src + 2);
-}
-
 static void
 TXSync(
 	ScrnInfoPtr pScrn
@@ -541,7 +519,8 @@
     while (dwords >= infoRec->ColorExpandRange) {
     	GLINT_WAIT(infoRec->ColorExpandRange);
     	GLINT_WRITE_REG((infoRec->ColorExpandRange - 2)<<16 | 0x0D, OutputFIFO);
-    	MoveDWORDS((CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4), src,
+    	GLINT_MoveDWORDS(
+		(CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4), src,
 		infoRec->ColorExpandRange - 1);
     	dwords -= (infoRec->ColorExpandRange - 1);
 	src += (infoRec->ColorExpandRange - 1);
@@ -549,7 +528,8 @@
     if (dwords) {
     	GLINT_WAIT(dwords);
     	GLINT_WRITE_REG((dwords - 1)<<16 | 0x0D, OutputFIFO);
-    	MoveDWORDS((CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4), src,dwords);
+    	GLINT_MoveDWORDS(
+		(CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4), src,dwords);
     }
     pGlint->cpucount += 1;
 }
@@ -848,7 +828,8 @@
 	/* (0x15 << 4) | 0x05 is the TAG for FBSourceData */
        	GLINT_WRITE_REG(((infoRec->ColorExpandRange - 2) << 16) | (0x15 << 4) | 
 				0x05, OutputFIFO);
-	MoveDWORDS((CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4),
+	GLINT_MoveDWORDS(
+		(CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4),
  		(CARD32*)srcp, infoRec->ColorExpandRange - 1);
 	count -= infoRec->ColorExpandRange - 1;
 	srcp += infoRec->ColorExpandRange - 1;
@@ -858,7 +839,8 @@
 	/* (0x15 << 4) | 0x05 is the TAG for FBSourceData */
        	GLINT_WRITE_REG(((count - 1) << 16) | (0x15 << 4) | 
 				0x05, OutputFIFO);
-	MoveDWORDS((CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4),
+	GLINT_MoveDWORDS(
+		(CARD32*)((char*)pGlint->IOBase + OutputFIFO + 4),
  		(CARD32*)srcp, count);
       }
       src += srcwidth;
diff -ur xc.orig/programs/Xserver/hw/xfree86/drivers/mga/mga_storm.c xc/programs/Xserver/hw/xfree86/drivers/mga/mga_storm.c
--- xc.orig/programs/Xserver/hw/xfree86/drivers/mga/mga_storm.c	Sat Mar 17 17:57:15 2001
+++ xc/programs/Xserver/hw/xfree86/drivers/mga/mga_storm.c	Sun Mar 18 17:19:13 2001
@@ -37,6 +37,16 @@
 #include "mga_dri.h"
 #endif
 
+#if defined(__alpha__)
+#define MGAMoveDWORDS(d,s,c) \
+do { \
+  write_mem_barrier(); \
+  XAAMoveDWORDS((d),(s),(c)); \
+} while (0)
+#else
+#define MGAMoveDWORDS(d,s,c)   XAAMoveDWORDS((d),(s),(c))
+#endif
+
 static void MGANAME(SubsequentScreenToScreenCopy)(ScrnInfoPtr pScrn,
 				int srcX, int srcY, int dstX, int dstY,
 				int w, int h);
@@ -964,6 +974,8 @@
 
     CHECK_DMA_QUIESCENT(pMga, pScrn);
    
+    mem_barrier(); /*??*/
+
     while(MGAISBUSY());
     /* flush cache before a read (mga-1064g 5.1.6) */
     OUTREG8(MGAREG_CRTC_INDEX, 0); 
@@ -1599,7 +1611,13 @@
     OUTREG(MGAREG_FXBNDRY, ((x + w - 1) << 16) | (x & 0xFFFF));
     OUTREG(MGAREG_YDSTLEN + MGAREG_EXEC, (y << 16) | h);
 
-    if(pMga->expandDWORDs > pMga->FifoSize) {
+#ifdef __alpha__
+    /* force Alpha to always use indirect */
+    if(1)
+#else
+    if(pMga->expandDWORDs > pMga->FifoSize)
+#endif
+    {
         pMga->AccelInfoRec->SubsequentColorExpandScanline =
                 MGANAME(SubsequentColorExpandScanlineIndirect);
         pMga->AccelInfoRec->ScanlineColorExpandBuffers =
@@ -1624,13 +1642,13 @@
    
     while(dwords > pMga->FifoSize) {
 	WAITFIFO(pMga->FifoSize);
-	XAAMoveDWORDS((CARD32*)(pMga->ColorExpandBase), src, pMga->FifoSize);
+	MGAMoveDWORDS((CARD32*)(pMga->ColorExpandBase), src, pMga->FifoSize);
 	src += pMga->FifoSize;
 	dwords -= pMga->FifoSize;
     }
     
     WAITFIFO(dwords);
-    XAAMoveDWORDS((CARD32*)(pMga->ColorExpandBase), src, dwords);
+    MGAMoveDWORDS((CARD32*)(pMga->ColorExpandBase), src, dwords);
 
     if(!(--pMga->expandRows)) {
 	if(pMga->expandRemaining) {
@@ -1726,13 +1744,13 @@
 
     while(dwords > pMga->FifoSize) {
 	WAITFIFO(pMga->FifoSize);
-        XAAMoveDWORDS((CARD32*)(pMga->ColorExpandBase), src, pMga->FifoSize);
+        MGAMoveDWORDS((CARD32*)(pMga->ColorExpandBase), src, pMga->FifoSize);
         src += pMga->FifoSize;
         dwords -= pMga->FifoSize;
     }
 
     WAITFIFO(dwords);
-    XAAMoveDWORDS((CARD32*)(pMga->ColorExpandBase), src, dwords);
+    MGAMoveDWORDS((CARD32*)(pMga->ColorExpandBase), src, dwords);
 
     if(!(--pMga->expandRows)) {
 	DISABLE_CLIP();
diff -ur xc.orig/programs/Xserver/hw/xfree86/drivers/tga/IBM561ramdac.c xc/programs/Xserver/hw/xfree86/drivers/tga/IBM561ramdac.c
--- xc.orig/programs/Xserver/hw/xfree86/drivers/tga/IBM561ramdac.c	Mon Oct 23 17:16:50 2000
+++ xc/programs/Xserver/hw/xfree86/drivers/tga/IBM561ramdac.c	Sun Mar 18 16:51:30 2001
@@ -533,7 +533,6 @@
   TGAPtr pTga = TGAPTR(pScrn);
 
     unsigned int temp1[6] = {0,0,0,0,0,0};
-    struct monitor_data * c_table = &crystal_table;
 
     /*
      *  Set-up av9110 to 14.3 Mhz as reference for 561's PLL
@@ -555,10 +554,10 @@
   IBM561WriteReg(pScrn, IBM561_CONFIG_REG_4, 0x20 );
 
 /* IBM561WriteReg(pScrn, IBM561_PLL_VCO_DIV_REG, 0xc8 ); */
-  IBM561WriteReg(pScrn, IBM561_PLL_VCO_DIV_REG, c_table->ibm561_vco_div);
+  IBM561WriteReg(pScrn, IBM561_PLL_VCO_DIV_REG, tga_c_table->ibm561_vco_div);
 
 /* IBM561WriteReg(pScrn, IBM561_PLL_REF_REG, 0x08 ); */
-  IBM561WriteReg(pScrn, IBM561_PLL_REF_REG, c_table->ibm561_ref );
+  IBM561WriteReg(pScrn, IBM561_PLL_REF_REG, tga_c_table->ibm561_ref );
 
   IBM561WriteReg(pScrn, IBM561_DIV_DOT_CLK_REG, 0xb0 );
 
diff -ur xc.orig/programs/Xserver/hw/xfree86/drivers/tga/tga.h xc/programs/Xserver/hw/xfree86/drivers/tga/tga.h
--- xc.orig/programs/Xserver/hw/xfree86/drivers/tga/tga.h	Fri Oct 27 21:23:37 2000
+++ xc/programs/Xserver/hw/xfree86/drivers/tga/tga.h	Sun Mar 18 16:51:30 2001
@@ -120,7 +120,9 @@
   unsigned int ibm561_ref;
 };
 
-extern struct monitor_data crystal_table;
+extern struct monitor_data tga_crystal_table[];
+extern int tga_crystal_table_entries;
+extern struct monitor_data *tga_c_table;
 
 /* Prototypes */
 
@@ -131,6 +133,7 @@
 		   Bool saveFonts*/);
 Bool DEC21030Init(ScrnInfoPtr pScrn, DisplayModePtr mode);
 void write_av9110(ScrnInfoPtr pScrn, unsigned int *);
+void TGA2SetupMode(ScrnInfoPtr pScrn);
 
 /* tga_accel.c */
 Bool DEC21030AccelInit(ScreenPtr pScreen);
diff -ur xc.orig/programs/Xserver/hw/xfree86/drivers/tga/tga_dac.c xc/programs/Xserver/hw/xfree86/drivers/tga/tga_dac.c
--- xc.orig/programs/Xserver/hw/xfree86/drivers/tga/tga_dac.c	Fri Oct 27 21:23:37 2000
+++ xc/programs/Xserver/hw/xfree86/drivers/tga/tga_dac.c	Sun Mar 18 16:51:30 2001
@@ -49,45 +49,114 @@
   /* There lies an ICS1562 Clock Generator. */
   ICS1562_CalcClockBits(freq, pll_bits);
 
-  switch (pTga->Chipset) {
-  case PCI_CHIP_DEC21030:
-    /*
-     * For the DEC 21030 TGA:
-     * This requires the 55 clock bits be written in a serial manner to
-     * bit 0 of the CLOCK register and on the 56th bit set the hold flag.
-     */
-    for (i = 0;i <= 6; i++) {
-	for (j = 0; j <= 7; j++) {
-	    temp = (pll_bits[i] >> (7-j)) & 1;
-	    if (i == 6 && j == 7)
-	    	temp |= 2;
-	    TGA_WRITE_REG(temp, TGA_CLOCK_REG);
-	}
+  /*
+   * For the DEC 21030 TGA:
+   * This requires the 55 clock bits be written in a serial manner to
+   * bit 0 of the CLOCK register and on the 56th bit set the hold flag.
+   */
+  for (i = 0;i <= 6; i++) {
+    for (j = 0; j <= 7; j++) {
+      temp = (pll_bits[i] >> (7-j)) & 1;
+      if (i == 6 && j == 7)
+	temp |= 2;
+      TGA_WRITE_REG(temp, TGA_CLOCK_REG);
     }
-    break;
-
-  case PCI_CHIP_TGA2:
-    /*
-     * For the DEC TGA2:
-     * This requires the 55 clock bits be written in a serial manner to
-     * bit 0 of the CLOCK register and on the 56th bit set the hold flag.
-     */
-#if 0
-    /* ?? FIXME FIXME FIXME ?? */
-    for (i = 0;i <= 6; i++) {
-	for (j = 0; j <= 7; j++) {
-	    temp = (pll_bits[i] >> (7-j)) & 1;
-	    if (i == 6 && j == 7)
-	    	temp |= 2;
-	    TGA_WRITE_REG(temp, TGA_CLOCK_REG);
-	}
-    }
-#endif
-    break;
   }
 }
 
-struct monitor_data crystal_table = 
+struct monitor_data tga_crystal_table[] = {
+{
+/*  Option 0 Monitor Info  130.8            */
+1024,                        /* rows                         */
+1280,                        /* columns                      */
+130,                         /* 130.8 Mhz                    */
+72,                          /* refresh rate                 */
+1024,                        /* v scanlines                  */
+3,                           /* v front porch                */
+3,                           /* v sync                       */
+33,                          /* v back porch                 */
+1280,                        /* h pixels                     */
+32,                          /* h front porch                */
+160,                         /* h sync                       */
+232,                         /* h back porch                 */
+/* AV9110 clock serial load information    130.808     */
+0x40,                           /* 0:6  VCO frequency divider  N         */
+0x7,                            /* 7:13 Reference frequency divide  M   */
+0x0,                            /* 14 VCO pre-scale divide V (0=div.by 1,1=by 8)
+*/
+0x1,                            /* 15:16 CLK/X output divide X          */
+0x1,                            /* 17:18 VCO output divide R            */
+1,                              /* 19 CLK Output enable. */
+1,                              /* 20 CLK/X Output enable */
+0,                              /* reserved, should be set to 0         */
+0,                              /* Reference clock select on CLK 1=ref  */
+1,                              /* reserved, should be set to 1         */
+/* IBM561 PLL setup data 130.808 */
+0xC8,                           /* VCO Div: PFR=0x3, M-65=49 */
+0x8                             /* REF: N=0x8 */
+},
+{
+/*  Option 3 Monitor Info 104.00 Mhz                   */
+900,                         /* rows                         */
+1152,                        /* columns                      */
+104,                         /* 104 Mhz                      */
+72,                          /* refresh rate                 */
+900,                         /* v scanlines                  */
+6,                           /* v front porch                */
+10,                          /* v sync                       */
+44,                          /* v back porch                 */
+1152,                        /* h pixels                     */
+64,                          /* h front porch                */
+112,                         /* h sync                       */
+176,                         /* h back porch                 */
+/* 103.994 MHz av9110 clock serial load information         */
+0x6d,                           /* 0:6  VCO frequency divider  N         */
+0xf,                            /* 7:13 Reference frequency divide  M   */
+0x0,                            /* 14 VCO pre-scale divide V (0=div.by 1,1=by 8)
+*/
+0x1,                            /* 15:16 CLK/X output divide X          */
+0x1,                            /* 17:18 VCO output divide R            */
+1,                              /* 19 CLK Output enable. */
+1,                              /* 20 CLK/X Output enable */
+0,                              /* reserved, should be set to 0         */
+0,                              /* Reference clock select on CLK 1=ref  */
+1,                              /* reserved, should be set to 1         */
+/* 104.00 MHz IBM561 PLL setup data */
+0x96,                           /* VCO Div: PFR=2, M=57 */
+0x6                             /* REF: N=6 */
+},
+#if 1
+{
+/*  Option 6 Monitor Info 74.00 Mhz                    */
+768,                         /* rows                         */
+1024,                        /* columns                      */
+74,                          /* 74 Mhz                       */
+72,                          /* refresh rate                 */
+768,                         /* v scanlines                  */
+1,                           /* v front porch                */
+6,                           /* v sync                       */
+22,                          /* v back porch                 */
+1024,                        /* h pixels                     */
+16,                          /* h front porch                */
+128,                         /* h sync                       */
+128,                         /* h back porch                 */
+/* 74.00 MHz AV9110 clock serial load information         */
+0x2a,                           /* 0:6  VCO frequency divider  N         */
+0x41,                           /* 7:13 Reference frequency divide  M   */
+0x1,                            /* 14 VCO pre-scale divide V (0=div.by 1,1=by 8)
+*/
+0x1,                            /* 15:16 CLK/X output divide X          */
+0x1,                            /* 17:18 VCO output divide R            */
+1,                              /* 19 CLK Output enable. */
+1,                              /* 20 CLK/X Output enable */
+0,                              /* reserved, should be set to 0         */
+0,                              /* Reference clock select on CLK 1=ref  */
+1,                              /* reserved, should be set to 1         */
+/* 74.00 MHz IBM561 PLL setup data */
+0x9C,                           /* VCO Div: PFR=2, M=0x5D*/
+0x9                             /* REF: N=0x9 */
+},
+#else
 {
 /*  Option 5 Monitor Info 75.00 Mhz                    */
 768,                         /* rows                         */
@@ -117,8 +186,406 @@
 /* 75.00 MHz IBM561 PLL setup data */
 0x93,                           /* VCO Div: PFR=2, M=0x54 */
 0x8                             /* REF: N=0x8 */
+},
+#endif
+{
+/*  Option 9 Monitor Info 50 Mhz ergo SVGA             */
+600,                         /* rows                         */
+800,                         /* columns                      */
+50,                          /* 50 Mhz                       */
+72,                          /* refresh rate                 */
+600,                         /* v scanlines                  */
+37,                          /*(31 tga)v front porch                */
+6,                           /* v sync                       */
+23,                          /*(29 tga)v back porch                 */
+800,                         /* h pixels                     */
+56,                          /* h front porch                */
+120,                         /* h sync                       */
+64,                          /* h back porch                 */
+/*50.00 Mhz AV9110 clock serial load information         */
+0x37,                           /* 0:6  VCO frequency divider  N         */
+0x3f,                           /* 7:13 Reference frequency divide  M   */
+0x1,                            /* 14 VCO pre-scale divide V (0=div.by 1,1=by 8)
+*/
+0x1,                            /* 15:16 CLK/X output divide X          */
+0x2,                            /* 17:18 VCO output divide R            */
+1,                              /* 19 CLK Output enable. */
+1,                              /* 20 CLK/X Output enable */
+0,                              /* reserved, should be set to 0         */
+0,                              /* Reference clock select on CLK 1=ref  */
+1,                              /* reserved, should be set to 1         */
+/* 50.00 MHz IBM561 PLL setup data */
+0x45,                           /* VCO Div: PFR=1, M=46*/
+0x5                             /* REF: N=5 */
+},
+{
+/*  Option B Monitor Info 31.5 Mhz ergo VGA            */
+480,                         /* rows                         */
+640,                         /* columns                      */
+32,                          /* 32 Mhz                       */
+72,                          /* refresh rate                 */
+480,                         /* v scanlines                  */
+9,                           /* v front porch                */
+3,                           /* v sync                       */
+28,                          /* v back porch                 */
+640,                         /* h pixels                     */
+24,                          /* h front porch                */
+40,                          /* h sync                       */
+128,                         /* h back porch                 */
+/* 31.50 MHz AV9110 clock serial load information         */
+0x16,                           /* 0:6  VCO frequency divider  N         */
+0x05,                           /* 7:13 Reference frequency divide  M   */
+0x0,                            /* 14 VCO pre-scale divide V (0=div.by 1,1=by 8)
+*/
+0x1,                            /* 15:16 CLK/X output divide X          */
+0x2,                            /* 17:18 VCO output divide R            */
+1,                              /* 19 CLK Output enable. */
+1,                              /* 20 CLK/X Output enable */
+0,                              /* reserved, should be set to 0         */
+0,                              /* Reference clock select on CLK 1=ref  */
+1,                              /* reserved, should be set to 1         */
+/* 31.50 MHz IBM561 PLL setup data  */
+0x17,                           /* VCO Div: PFR=0, M=0x58 */
+0x5                             /* REF: N=0x5 */
+},
+#ifdef ALLOW_LT_72_HZ
+{
+/*  Option 1 Monitor Info 119.84 Mhz                   */
+1024,                        /* rows                         */
+1280,                        /* columns                      */
+119,                         /* 119 Mhz                      */
+66,                          /* refresh rate                 */
+1024,                        /* v scanlines                  */
+3,                           /* v front porch                */
+3,                           /* v sync                       */
+33,                          /* v back porch                 */
+1280,                        /* h pixels                     */
+32,                          /* h front porch                */
+160,                         /* h sync                       */
+232,                         /* h back porch                 */
+/* 119.84MHz AV9110 clock serial load information         */
+0x2d,                           /* 0:6  VCO frequency divider  N         */
+0x2b,                           /* 7:13 Reference frequency divide  M   */
+0x1,                            /* 14 VCO pre-scale divide V (0=div.by 1,1=by 8) */
+0x1,                            /* 15:16 CLK/X output divide X          */
+0x1,                            /* 17:18 VCO output divide R            */
+1,                              /* 19 CLK Output enable. */
+1,                              /* 20 CLK/X Output enable */
+0,                              /* reserved, should be set to 0         */
+0,                              /* Reference clock select on CLK 1=ref  */
+1,                              /* reserved, should be set to 1         */
+/* IBM561 PLL setup data 119.84 */
+0x82,                           /* VCO Div: PFR=0x2, M=0x43 */
+0x4                             /* REF: N=0x4 */
+},
+{
+/*  Option 2 Monitor Info 108.18 Mhz                   */
+1024,                        /* rows                         */
+1280,                        /* columns                      */
+108,                         /* 108 Mhz                      */
+60,                          /* refresh rate                 */
+1024,                        /* v scanlines                  */
+3,                           /* v front porch                */
+3,                           /* v sync                       */
+26,                          /* v back porch                 */
+1280,                        /* h pixels                     */
+44,                          /* h front porch                */
+184,                         /* h sync                       */
+200,                         /* h back porch                 */
+/* 108.18 MHz av9110 Clk serial load information         */
+0x11,                           /* 0:6  VCO frequency divider  N         */
+0x9,                           /* 7:13 Reference frequency divide  M   */
+0x1,                            /* 14 VCO pre-scale divide V (0=div.by 1,1=by 8)
+*/
+0x1,                            /* 15:16 CLK/X output divide X          */
+0x2,                            /* 17:18 VCO output divide R            */
+1,                              /* 19 CLK Output enable. */
+1,                              /* 20 CLK/X Output enable */
+0,                              /* reserved, should be set to 0         */
+0,                              /* Reference clock select on CLK 1=ref  */
+1,                              /* reserved, should be set to 1         */
+/* 108.18 MHz IBM561 PLL setup data */
+0xB8,                           /* VCO Div: PFR=2, M=79 */
+0x8                             /* REF: N=0x8 */
+},
+{
+/*  Option 5 Monitor Info 75.00 Mhz                    */
+768,                         /* rows                         */
+1024,                        /* columns                      */
+75,                          /* 74 Mhz                       */
+70,                          /* refresh rate                 */
+768,                         /* v scanlines                  */
+3,                           /* v front porch                */
+6,                           /* v sync                       */
+29,                          /* v back porch                 */
+1024,                        /* h pixels                     */
+24,                          /* h front porch                */
+136,                         /* h sync                       */
+144,                         /* h back porch                 */
+/* 75.00 MHz AV9110 clock serial load information         */
+0x6e,                           /* 0:6  VCO frequency divider  N         */
+0x15,                           /* 7:13 Reference frequency divide  M   */
+0x0,                            /* 14 VCO pre-scale divide V (0=div.by 1,1=by 8)
+*/
+0x1,                            /* 15:16 CLK/X output divide X          */
+0x1,                            /* 17:18 VCO output divide R            */
+1,                              /* 19 CLK Output enable. */
+1,                              /* 20 CLK/X Output enable */
+0,                              /* reserved, should be set to 0         */
+0,                              /* Reference clock select on CLK 1=ref  */
+1,                              /* reserved, should be set to 1         */
+/* 75.00 MHz IBM561 PLL setup data */
+0x93,                           /* VCO Div: PFR=2, M=0x54 */
+0x8                             /* REF: N=0x8 */
+},
+{
+/*  Option 7 Monitor Info 69 Mhz DEC 72 Hz             */
+864,                         /* rows                         */
+1024,                        /* columns                      */
+69,                          /* 69.x Mhz                     */
+60,                          /* refresh rate                 */
+864,                         /* v scanlines                  */
+0,                           /* v front porch                */
+3,                           /* v sync                       */
+34,                          /* v back porch                 */
+1024,                        /* h pixels                     */
+12,                          /* h front porch                */
+128,                         /* h sync                       */
+116,                         /* h back porch                 */
+/* 69.00 Mhz AV9110 clock serial load information         */
+0x35,                           /* 0:6  VCO frequency divider  N         */
+0xb,                            /* 7:13 Reference frequency divide  M   */
+0x0,                            /* 14 VCO pre-scale divide V (0=div.by 1,1=by 8)
+*/
+0x1,                            /* 15:16 CLK/X output divide X          */
+0x1,                            /* 17:18 VCO output divide R            */
+1,                              /* 19 CLK Output enable. */
+1,                              /* 20 CLK/X Output enable */
+0,                              /* reserved, should be set to 0         */
+0,                              /* Reference clock select on CLK 1=ref  */
+1,                              /* reserved, should be set to 1         */
+/* 69.00 MHz IBM561 PLL setup data */
+0xA9,                           /* VCO Div: PFR=2, M=0x6A */
+0xB                             /* REF: N=0xB */
+},
+{
+/*  Option 8 Monitor Info 65 Mhz                       */
+768,                         /* rows                         */
+1024,                        /* columns                      */
+65,                          /* 65 Mhz                       */
+60,                          /* refresh rate                 */
+768,                         /* v scanlines                  */
+7,                           /* v front porch                */
+9,                           /* v sync                       */
+26,                          /* v back porch                 */
+1024,                        /* h pixels                     */
+56,                          /* h front porch                */
+64,                          /* h sync                       */
+200,                         /* h back porch                 */
+/* 65.00 MHz AV9110 clock serial load information         */
+0x6d,                           /* 0:6  VCO frequency divider  N         */
+0x0c,                           /* 7:13 Reference frequency divide  M   */
+0x0,                            /* 14 VCO pre-scale divide V (0=div.by 1,1=by 8)
+*/
+0x1,                            /* 15:16 CLK/X output divide X          */
+0x2,                            /* 17:18 VCO output divide R            */
+1,                              /* 19 CLK Output enable. */
+1,                              /* 20 CLK/X Output enable */
+0,                              /* reserved, should be set to 0         */
+0,                              /* Reference clock select on CLK 1=ref  */
+1,                              /* reserved, should be set to 1         */
+/* 65.00 MHz IBM561 PLL setup data */
+0xAC,                           /* VCO Div: PFR=2, M=0x6D */
+0xC                             /* REF: N=0xC */
+},
+{
+/*  Option A Monitor Info 40  Mhz SVGA                 */
+600,                         /* rows                         */
+800,                         /* columns                      */
+40,                          /* 40 Mhz                       */
+60,                          /* refresh rate                 */
+600,                         /* v scanlines                  */
+1,                           /* v front porch                */
+4,                           /* v sync                       */
+23,                          /* v back porch                 */
+800,                         /* h pixels                     */
+40,                          /* h front porch                */
+128,                         /* h sync                       */
+88,                          /* h back porch                 */
+/* 40.00 MHz AV9110 clock serial load information         */
+0x5f,                           /* 0:6  VCO frequency divider  N         */
+0x11,                           /* 7:13 Reference frequency divide  M   */
+0x0,                            /* 14 VCO pre-scale divide V (0=div.by 1,1=by 8)
+*/
+0x1,                            /* 15:16 CLK/X output divide X          */
+0x2,                            /* 17:18 VCO output divide R            */
+1,                              /* 19 CLK Output enable. */
+1,                              /* 20 CLK/X Output enable */
+0,                              /* reserved, should be set to 0         */
+0,                              /* Reference clock select on CLK 1=ref  */
+1,                              /* reserved, should be set to 1         */
+/* 40.00 MHz IBM561 PLL setup data  */
+0x42,                           /* VCO Div: PFR=1, M=43 */
+0x6                             /* REF: N=0x6 */
+},
+{
+/*  Option C Monitor Info 25.175 Mhz VGA                      */
+480,                         /* rows                         */
+640,                         /* columns                      */
+25,                          /* 25.175 Mhz                   */
+60,                          /* refresh rate                 */
+480,                         /* v scanlines                  */
+10,                          /* v front porch                */
+2,                           /* v sync                       */
+33,                          /* v back porch                 */
+640,                         /* h pixels                     */
+16,                          /* h front porch                */
+96,                          /* h sync                       */
+48,                          /* h back porch                 */
+/* 25.175 MHz  AV9110 clock serial load information         */
+0x66,                           /* 0:6  VCO frequency divider  N         */
+0x1d,                           /* 7:13 Reference frequency divide  M   */
+0x0,                            /* 14 VCO pre-scale divide V (0=div.by 1,1=by 8)
+*/
+0x1,                            /* 15:16 CLK/X output divide X          */
+0x2,                            /* 17:18 VCO output divide R            */
+1,                              /* 19 CLK Output enable. */
+1,                              /* 20 CLK/X Output enable */
+0,                              /* reserved, should be set to 0         */
+0,                              /* Reference clock select on CLK 1=ref  */
+1,                              /* reserved, should be set to 1         */
+/* 25.175 MHz IBM561 PLL setup data  */
+0x3E,                           /* VCO Div: PFR=0, M=0x7F */
+0x9                             /* REF: N=0x9 */
+},
+{
+/*  Option E Monitor Info 110 Mhz                  */
+1024,                        /* rows                         */
+1280,                        /* columns                      */
+110,
+60,                          /* refresh rate                 */
+1024,                        /* v scanlines                  */
+6,                           /* v front porch                */
+7,                           /* v sync                       */
+44,                          /* v back porch                 */
+1280,                        /* h pixels                     */
+19,                          /* h front porch                */
+163,                         /* h sync                       */
+234,                         /* h back porch                 */
+/* 110.0 MHz AV9110 clock serial load information         */
+0x60,                           /* 0:6  VCO frequency divider  N         */
+0x32,                           /* 7:13 Reference frequency divide  M   */
+0x1,                            /* 14 VCO pre-scale divide V (0=div.by 1,1=by 8) */
+0x1,                            /* 15:16 CLK/X output divide X          */
+0x2,                            /* 17:18 VCO output divide R            */
+1,                              /* 19 CLK Output enable. */
+1,                              /* 20 CLK/X Output enable */
+0,                              /* reserved, should be set to 0         */
+0,                              /* Reference clock select on CLK 1=ref  */
+1,                              /* reserved, should be set to 1         */
+/* 110.0 MHz IBM561 PLL setup data  */
+0xBA,                           /* VCO Div: PFR=0x2, M=0x7B */
+0x8                             /* REF: N=0x8 */
+},
+#endif /* ALLOW_LT_72_HZ */
+#ifdef /* ALLOW_GT_72_HZ */
+{
+/*  Option D Monitor Info 135 Mhz                  */
+1024,                        /* rows                         */
+1280,                        /* columns                      */
+135,                         /* 135 Mhz                      */
+75,                          /* refresh rate                 */
+1024,                        /* v scanlines                  */
+1,                           /* v front porch                */
+3,                           /* v sync                       */
+38,                          /* v back porch                 */
+1280,                        /* h pixels                     */
+16,                          /* h front porch                */
+144,                         /* h sync                       */
+248,                         /* h back porch                 */
+/* 135.0 MHz AV9110 clock serial load information         */
+0x42,                           /* 0:6  VCO frequency divider  N         */
+0x07,                           /* 7:13 Reference frequency divide  M   */
+0x0,                            /* 14 VCO pre-scale divide V (0=div.by 1,1=by 8) */
+0x1,                            /* 15:16 CLK/X output divide X          */
+0x1,                            /* 17:18 VCO output divide R            */
+1,                              /* 19 CLK Output enable. */
+1,                              /* 20 CLK/X Output enable */
+0,                              /* reserved, should be set to 0         */
+0,                              /* Reference clock select on CLK 1=ref  */
+1,                              /* reserved, should be set to 1         */
+/* 135.0 MHz IBM561 PLL setup data  */
+0xC1,                           /* VCO Div: PFR=0x3, M=0x42 */
+0x7                             /* REF: N=0x7 */
+},
+#ifdef ALLOW_GT_1280x1024
+{
+/*  Option 4 Monitor Info 175.5 Mhz (8-plane)                */
+1200,                        /* rows                         */
+1600,                        /* columns                      */
+175,                         /* clock */
+65,                          /* refresh rate                 */
+1200,                        /* v scanlines                  */
+1,                           /* v front porch                */
+3,                           /* v sync                       */
+46,                          /* v back porch                 */
+1600,                        /* h pixels                     */
+32,                          /* h front porch                */
+192,                         /* h sync                       */
+336,                         /* h back porch                 */
+/* 110.0 MHz AV9110 clock serial load information         */
+0x5F,                           /* 0:6  VCO frequency divider  N         */
+0x3E,                           /* 7:13 Reference frequency divide  M   */
+0x1,                            /* 14 VCO pre-scale divide V (0=div.by 1,1=by 8)
+*/
+0x1,                            /* 15:16 CLK/X output divide X          */
+0x1,                            /* 17:18 VCO output divide R            */
+1,                              /* 19 CLK Output enable. */
+1,                              /* 20 CLK/X Output enable */
+0,                              /* reserved, should be set to 0         */
+0,                              /* Reference clock select on CLK 1=ref  */
+1,                              /* reserved, should be set to 1         */
+/* 110.0 MHz IBM561 PLL setup data  */
+0xE1,                           /* VCO Div: PFR=0x3, M-65=0x21 */
+0x8                             /* REF: N=0x8 */
+},
+{
+/*  Option F Monitor Info  (24-plane)                        */
+1200,                        /* rows                         */
+1600,                        /* columns                      */
+202.5,                       /* 130.8 Mhz                    */
+75,                          /* refresh rate                 */
+1200,                        /* v scanlines                  */
+1,                           /* v front porch                */
+3,                           /* v sync                       */
+46,                          /* v back porch                 */
+1600,                        /* h pixels                     */
+32,                          /* h front porch                */
+192,                         /* h sync                       */
+336,                         /* h back porch                 */
+/* AV9110 clock serial load information    130.808     */
+0x60,                           /* 0:6  VCO frequency divider  N         */
+0x32,                           /* 7:13 Reference frequency divide  M   */
+0x1,                            /* 14 VCO pre-scale divide V (0=div.by 1,1=by 8) */
+0x1,                            /* 15:16 CLK/X output divide X          */
+0x2,                            /* 17:18 VCO output divide R            */
+1,                              /* 19 CLK Output enable. */
+1,                              /* 20 CLK/X Output enable */
+0,                              /* reserved, should be set to 0         */
+0,                              /* Reference clock select on CLK 1=ref  */
+1,                              /* reserved, should be set to 1         */
+/* 110.0 MHz IBM561 PLL setup data  */
+0xE2,                           /* bogus VCO Div: PFR=0x2, M=0x7B */
+0x7                             /* bogus REF: N=0x8 */
+}
+#endif /* ALLOW_GT_1280x1024 */
+#endif /* ALLOW_GT_72_HZ */
 };
 
+int tga_crystal_table_entries = sizeof(tga_crystal_table)/sizeof(struct monitor_data);
+
+struct monitor_data *tga_c_table;
+
 /* ICS av9110 is only used on TGA2 */
 
 void
@@ -142,30 +609,58 @@
     TGA2_WRITE_CLOCK_REG(0x0, 0xf800);
 }
 
+void TGA2SetupMode(ScrnInfoPtr pScrn)
+{
+  int i;
+
+  /*
+   * HACK HACK HACK
+   *
+   * We do not know how to generate arbitrary clocks, so we search
+   * the crystal_table above for a match. Sigh...
+   */
+  tga_c_table = tga_crystal_table;
+  for (i = 0; i < tga_crystal_table_entries; i++, tga_c_table++) {
+    if ((tga_c_table->max_rows == pScrn->currentMode->VDisplay) &&
+	(tga_c_table->max_cols == pScrn->currentMode->HDisplay)) {
+      ErrorF("Found a matching mode (%d)!\n", i);
+      break;
+    }
+  }
+  if (i == tga_crystal_table_entries) {
+#ifdef FOR_NOW
+    FatalError("Unable to find a workable mode");
+#else
+    ErrorF("Unable to find a matching mode!\n");
+    /* tga_c_table = &tga_crystal_table[4]; *//* 640x480 @ 72 */
+    tga_c_table = &tga_crystal_table[2]; /* 1024x768 @ 72 */
+#endif
+  }
+  return;
+}
+
 static void
 ICS9110ClockSelect(ScrnInfoPtr pScrn, int freq)
 {
     unsigned int temp, temp1[6];
-    struct monitor_data *c_table;
+    int i;
 
     /* There lies an ICS9110 Clock Generator. */
     /* ICS9110_CalcClockBits(freq, pll_bits); */
 
-    c_table = &crystal_table;
-
     /* the following is based on munge_ics() from the
        TRU64 kernel TGA driver */
 
-    temp = (unsigned int)(c_table->vco_div |
-			  (c_table->ref_div << 7) |
-			  (c_table->vco_pre << 14) |
-			  (c_table->clk_div << 15) |
-			  (c_table->vco_out_div << 17) |
-			  (c_table->clk_out_en << 19) |
-			  (c_table->clk_out_enX << 20) |
-			  (c_table->res0 << 21) |
-			  (c_table->clk_sel << 22) |
-			  (c_table->res1 << 23));
+    temp = (unsigned int)(tga_c_table->vco_div |
+			  (tga_c_table->ref_div << 7) |
+			  (tga_c_table->vco_pre << 14) |
+			  (tga_c_table->clk_div << 15) |
+			  (tga_c_table->vco_out_div << 17) |
+			  (tga_c_table->clk_out_en << 19) |
+			  (tga_c_table->clk_out_enX << 20) |
+			  (tga_c_table->res0 << 21) |
+			  (tga_c_table->clk_sel << 22) |
+			  (tga_c_table->res1 << 23));
 
     temp1[0] = (temp & 0x00000001)         | ((temp & 0x00000002) << 7) |
       ((temp & 0x00000004) << 14) | ((temp & 0x00000008) << 21);
diff -ur xc.orig/programs/Xserver/hw/xfree86/drivers/tga/tga_driver.c xc/programs/Xserver/hw/xfree86/drivers/tga/tga_driver.c
--- xc.orig/programs/Xserver/hw/xfree86/drivers/tga/tga_driver.c	Mon Dec  4 19:56:22 2000
+++ xc/programs/Xserver/hw/xfree86/drivers/tga/tga_driver.c	Sun Mar 18 16:51:30 2001
@@ -954,6 +954,15 @@
     /* Set the current mode to the first in the list */
     pScrn->currentMode = pScrn->modes;
 
+    /*
+     This is a bit of a hack; we seem to have to init
+     the TGA2 chipset knowing what the mode is, so we
+     do this now as soon as we know it...
+    */
+    if (pTga->Chipset == PCI_CHIP_TGA2) {
+      TGA2SetupMode(pScrn);
+    }
+
     /* Print the list of modes being used */
     xf86PrintModes(pScrn);
 
diff -ur xc.orig/programs/Xserver/hw/xfree86/os-support/linux/lnx_axp.c xc/programs/Xserver/hw/xfree86/os-support/linux/lnx_axp.c
--- xc.orig/programs/Xserver/hw/xfree86/os-support/linux/lnx_axp.c	Sat Mar 17 17:57:16 2001
+++ xc/programs/Xserver/hw/xfree86/os-support/linux/lnx_axp.c	Sun Mar 18 16:51:30 2001
@@ -10,28 +10,28 @@
 axpDevice lnxGetAXP(void);
 
 static AXP axpList[] = {
-  { "Tsunami", NULL, NULL, TSUNAMI },
-  { "Eiger", NULL, NULL, TSUNAMI }, 
-  {"Noname", NULL, NULL, LCA },
-  { "AlphaBook1", NULL, NULL, LCA }, 
-  {"EB66", NULL, NULL, LCA}, 
-  {"EB64+",NULL,NULL, APECS}, 
+  {"Tsunami",NULL,NULL,TSUNAMI},
+  {"Eiger",NULL,NULL,TSUNAMI},
+  {"Noname",NULL,NULL,LCA},
+  {"AlphaBook1",NULL,NULL,LCA},
+  {"EB66",NULL,NULL,LCA},
+  {"EB64+",NULL,NULL,APECS},
   {"Noritake",NULL,"EV5",CIA},
   {"Noritake",NULL,"EV56",CIA},
   {"Noritake",NULL,NULL,APECS},
-  {"XL",NULL,NULL,APECS},              
+  {"XL",NULL,NULL,APECS},             
   {"Avanti",NULL,NULL,APECS},
   {"Mikasa",NULL,"EV5",CIA},
   {"Mikasa",NULL,"EV56",CIA},
   {"Mikasa",NULL,NULL,APECS},
   {"EB164","EB164",NULL,CIA},
-  {"EB164","PC164", NULL,CIA},
-  {"EB164","RX164",NULL, POLARIS},
-  {"EB164","SX164",NULL, PYXIS},
-  {"EB164","LX164",NULL, PYXIS},
+  {"EB164","PC164",NULL,CIA},
+  {"EB164","RX164",NULL,POLARIS},
+  {"EB164","SX164",NULL,PYXIS},
+  {"EB164","LX164",NULL,PYXIS},
   {"Alcor",NULL,NULL,CIA},
   {"Takara",NULL,NULL,CIA},
-  {"Sable",NULL, "EV5",T2_GAMMA},
+  {"Sable",NULL,"EV5",T2_GAMMA},
   {"Sable",NULL,"EV56",T2_GAMMA},
   {"Sable",NULL,NULL,T2},
   {"Rawhide",NULL,NULL,MCPCIA},
diff -ur xc.orig/programs/Xserver/hw/xfree86/os-support/linux/lnx_ev56.c xc/programs/Xserver/hw/xfree86/os-support/linux/lnx_ev56.c
--- xc.orig/programs/Xserver/hw/xfree86/os-support/linux/lnx_ev56.c	Thu Feb 17 08:45:49 2000
+++ xc/programs/Xserver/hw/xfree86/os-support/linux/lnx_ev56.c	Sun Mar 18 16:51:30 2001
@@ -29,18 +29,21 @@
 int
 readDense8(pointer Base, register unsigned long Offset)
 {
+    mem_barrier();
     return *(volatile CARD8*) ((unsigned long)Base+(Offset));
 }
 
 int
 readDense16(pointer Base, register unsigned long Offset)
 {
+    mem_barrier();
     return *(volatile CARD16*) ((unsigned long)Base+(Offset));
 }
 
 int
 readDense32(pointer Base, register unsigned long Offset)
 {
+    mem_barrier();
     return *(volatile CARD32*)((unsigned long)Base+(Offset));
 }
 
@@ -65,20 +68,20 @@
 void
 writeDense8(int Value, pointer Base, register unsigned long Offset)
 {
+    write_mem_barrier();
     *(volatile CARD8 *)((unsigned long)Base+(Offset)) = Value;
-    mem_barrier();
 }
 
 void
 writeDense16(int Value, pointer Base, register unsigned long Offset)
 {
+    write_mem_barrier();
     *(volatile CARD16 *)((unsigned long)Base+(Offset)) = Value;
-    mem_barrier();
 }
 
 void
 writeDense32(int Value, pointer Base, register unsigned long Offset)
 {
+    write_mem_barrier();
     *(volatile CARD32 *)((unsigned long)Base+(Offset)) = Value;
-    mem_barrier();
 }
diff -ur xc.orig/programs/Xserver/hw/xfree86/os-support/linux/lnx_video.c xc/programs/Xserver/hw/xfree86/os-support/linux/lnx_video.c
--- xc.orig/programs/Xserver/hw/xfree86/os-support/linux/lnx_video.c	Fri Dec  8 22:59:56 2000
+++ xc/programs/Xserver/hw/xfree86/os-support/linux/lnx_video.c	Sun Mar 18 17:29:04 2001
@@ -614,15 +614,16 @@
 
     Offset += (unsigned long)Base - (unsigned long)lnxBase;
     shift = (Offset & 0x3) << 3;
-      if (Offset >= (hae_thresh)) {
+    if (Offset >= (hae_thresh)) {
         msb = Offset & hae_mask;
         Offset -= msb;
 	if (msb_set != msb) {
-	sethae(msb);
-	msb_set = msb;
+	    sethae(msb);
+	    msb_set = msb;
 	}
-      }
+    }
 
+    mem_barrier();
     result = *(vuip) ((unsigned long)lnxSBase + (Offset << 5));
     result >>= shift;
     return 0xffUL & result;
@@ -636,14 +637,16 @@
 
     Offset += (unsigned long)Base - (unsigned long)lnxBase;
     shift = (Offset & 0x2) << 3;
-      if (Offset >= hae_thresh) {
+    if (Offset >= hae_thresh) {
         msb = Offset & hae_mask;
         Offset -= msb;
-      if (msb_set != msb) {
-	sethae(msb);
-	msb_set = msb;
-      }
+	if (msb_set != msb) {
+	    sethae(msb);
+	    msb_set = msb;
+	}
     }
+
+    mem_barrier();
     result = *(vuip)((unsigned long)lnxSBase+(Offset<<5)+(1<<(5-2)));
     result >>= shift;
     return 0xffffUL & result;
@@ -652,6 +655,8 @@
 static int
 readSparse32(pointer Base, register unsigned long Offset)
 {
+    /* note that this is actually doing a DENSE read... */
+    mem_barrier();
     return *(vuip)((unsigned long)Base+(Offset));
 }
 
@@ -670,8 +675,8 @@
 	msb_set = msb;
       }
     }
+    write_mem_barrier();
     *(vuip) ((unsigned long)lnxSBase + (Offset << 5)) = b * 0x01010101;
-    mem_barrier();
 }
 
 static void
@@ -689,17 +694,16 @@
 	msb_set = msb;
       }
     }
-    *(vuip)((unsigned long)lnxSBase+(Offset<<5)+(1<<(5-2))) =
-      w * 0x00010001;
-    mem_barrier();
-
+    write_mem_barrier();
+    *(vuip)((unsigned long)lnxSBase+(Offset<<5)+(1<<(5-2))) = w * 0x00010001;
 }
 
 static void
 writeSparse32(int Value, pointer Base, register unsigned long Offset)
 {
+    /* note that this is actually doing a DENSE write... */
+    write_mem_barrier();
     *(vuip)((unsigned long)Base + (Offset)) = Value;
-    mem_barrier();
     return;
 }
 
diff -ur xc.orig/programs/Xserver/hw/xfree86/os-support/xf86_OSproc.h xc/programs/Xserver/hw/xfree86/os-support/xf86_OSproc.h
--- xc.orig/programs/Xserver/hw/xfree86/os-support/xf86_OSproc.h	Fri Dec  8 22:59:49 2000
+++ xc/programs/Xserver/hw/xfree86/os-support/xf86_OSproc.h	Sun Mar 18 16:51:30 2001
@@ -194,13 +194,6 @@
 extern Bool xf86UnbindGARTMemory(int screenNum, int key);
 extern Bool xf86EnableAGP(int screenNum, CARD32 mode);
 
-#if defined(__alpha__)
-extern void xf86JensenMemToBus(char *, long, long, int);
-extern void xf86JensenBusToMem(char *, char *, unsigned long, int);
-extern void xf86SlowBCopyFromBus(unsigned char *, unsigned char *, int);
-extern void xf86SlowBCopyToBus(unsigned char *, unsigned char *, int);
-#endif /* __alpha__ */
-
 /* These routines are in shared/sigio.c and are not loaded as part of the
    module.  These routines are small, and the code if very POSIX-signal (or
    OS-signal) specific, so it seemed better to provide more complex
